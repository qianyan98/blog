<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>打广告招人</title>
      <link href="/blog/article/beedc7b4.html"/>
      <url>/blog/article/beedc7b4.html</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.makiru.top/images/202408101914853.jpg"></p><span id="more"></span><p>先介绍楼主自己的情况：</p><ol><li>24届毕业，毕业后入职（到现在满打满算4个月）</li><li>之前在pdd实习过3个月</li><li>整体感觉下来，组内的同学们都很好，这么说吧，我现在做的东西，是我之前从没接触过的（不是说偏，只是我在学校期间没弄过，就目前来看，还是挺热门？），到现在为止一共实打实地做了4个月，很多都不会，在“万能”的CSDN帮不了我的时候，也只能去问组内大佬，他们真的是超级厉害（五体投地！！）不仅帮我耐心解答，还会安慰说不要急，都这么过来的，暖到了～</li><li>平时，晚上吃完饭后，组内还会一起去闲逛（哈哈，其实我是怕坐久了胖）</li><li>重点：要说不累，肯定是假话，只能说，收获和付出成正比，机会真的很多，只是缺少抓住的人，说不定就是你～（ps: 好腻，emmmm，广告看多了）</li></ol><p>再介绍下工作情况：</p><ol><li>工作压力看组，我所在的组还是很不错的（只能说这么多了，怕被盒）</li><li>每天中午和晚上都有休息时间，长短也看组，我组也不算短，据我所知，应该是第二长的？</li><li>工作内容嘛，看你兴趣啦</li></ol><p>最后，在组内大佬们的“压迫”下（小声说，bushi），恳请各位同学，在看我码了这么点字（额，不少了，真不少了）的前提下，有兴趣的可以给我发简历，也可以私聊我问相关的事情哦</p><p>差点忘了，最重要的事：<a href="https://careers.pinduoduo.com/campus/grad?t=WmC0mJo9gd">拼多多校园招聘</a></p><p>我的邮箱：**<a href="mailto:3406128464a@gmail.com">3406128464a@gmail.com</a>**，任何相关事项都可以联系我哟，最好带上简历就是啦</p><p><strong>省流版：</strong></p><p><strong>1. 缺人：缺干活的人</strong><br><strong>2. 招人：招干活的人（ps：我也是打工仔）</strong><br><strong>3. 工作内容：私信，主要是服务端研发（更偏向于基础架构就是了，经验不限，能码代码，脑袋没被砸过，提一嘴，楼主脑袋好的很，从没被砸过）</strong></p><p><img data-src="https://cdn.makiru.top/images/202408101915833.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业后快乐吗</title>
      <link href="/blog/article/57956ed4.html"/>
      <url>/blog/article/57956ed4.html</url>
      
        <content type="html"><![CDATA[<p>算起来，也挺久没有写博客了，连怎么写都快忘记了（其实已经忘记了….）。毕业3多个月了，这期间发生的事也不少，作为一个初入社会的新手，也学到了一些，当然，也感受到了社会的压力和打工人的辛苦。今天，趁着休息的空闲，想稍微聊一些毕业后的事。</p><p><img data-src="https://cdn.makiru.top/images/202407122143929.jpg"></p><span id="more"></span><h3 id="生活上的事"><a href="#生活上的事" class="headerlink" title="生活上的事"></a>生活上的事</h3><p>简单说点吧，我是今年3月底正式毕业的，3月中旬就已经把房子找好了。说到找房子，不得不说，上海真的配的上魔都的名号，想要在公司附近找一个合适的房子，是真的难如登天。当然，如果有钱，外加找个一室户的，还是挺简单的，就是得舍得掏腰包就是了。而我嘛，因为毕业前就和家里人说好，毕业后可以一起租个两室户，省一笔房租，所以就费劲心思地想要找一个两室户，奈何两室户的房源，要么个人房东的价格太高，要么就是房子配置很差，环境嘈杂。迫于无奈，我只能找中介帮忙了，最后还是在附近找了一个一般的两室户，一家人算是住在一起了，生活上还是挺好的，没有什么不方便的。唯一让我不太舒服的点，就是我住的地方在马路旁边，晚上还是不太安静～</p><p>离开学校后，我发现，原来离开了那道围墙，世界就好像变了，像是一场牌局，更像是一场无休止的博弈。身入其中，你必须了解它的规则。有些人生来或许就很熟悉这类游戏的规则，如鱼得水，也有些人，可能像我，开始还是很不适应，但慢慢的，也会明白怎样才能活得没那么难受。说这么多，简单一句话就是，你虽然不再是学生了，但在这个社会的课堂上，我们每个新入场的人，都还是一个“学生”。作为“学生”，最重要的一点就是，保持好奇心，保持好胜心，对不会的事要深究，虽然这或许会挤掉一些平时的娱乐时间，但这却是这场博弈里必需的牺牲。</p><p>对于我个人而言，毕业后，生活上还算说得过去，毕竟是和家里人在一起，周六的时候也能和他们说说这个礼拜发生的事。人总要有个能说心里事的对象，不管这个对象是朋友还是家人，甚至是纸片人（哈哈，我可不会和纸片人说心里事）。在家人的介绍下，认识了一个女孩，她挺好的，就是估计和我一样，不太爱说话，或者对我不太感冒？总之，生活上我应该是快乐的？</p><h3 id="工作上的事"><a href="#工作上的事" class="headerlink" title="工作上的事"></a>工作上的事</h3><p>工作上，能说的事就没那么多了，毕竟谁也不想过多暴露自己的工作经历。其实毕业之后，我就立马入职了，整个流程简直就是刚踏出校门，立马下一步就踏入公司（(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)）。为啥呢？因为我房子找的早了那么半个月，没办法，得攒房租啊。入职后，同事们都挺好的，整体的工作体验上，挺好的。在公司里，我常常更觉得自己像是一个啥也不会的小学生，什么东西都需要学，但是时间有时候并不允许你去慢慢学，所以大多数情况下，基本都是靠着临时学的半吊子水平去硬着头皮，去处理大佬们安排的事，平时还是需要花不少非工作时间来消化这些，但有的时候，唉，真的，刚踏出学校，总想着出去玩，扼制住这种想法也是需要一定的毅力的。</p><p>你觉得我快乐吗？可能有人会说，你都不能出去玩了，还能快乐吗？其实非也，毕竟学到了很多啊，不管是与人沟通上，还是个人技能上，软实力和硬实力都能提升，何乐而不为？</p><h3 id="你快乐吗"><a href="#你快乐吗" class="headerlink" title="你快乐吗"></a>你快乐吗</h3><p>作为一个入职三月半的“新人”，你觉得我快乐吗？换作是你，你快乐吗？快乐又到底是什么？有明确的概念吗？这些都是人云亦云，对于我来说，痛苦或许是成长的必备品，而快乐却是成长的附属品。</p><h3 id="真的吗"><a href="#真的吗" class="headerlink" title="真的吗"></a>真的吗</h3><p>你觉得我上面说的都是真的吗？哈哈哈，看你怎么理解喽～</p><img data-src="https://cdn.makiru.top/images/202407122238014.jpg" style="zoom: 50%;" />]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业碎谈</title>
      <link href="/blog/article/1c7c5bb5.html"/>
      <url>/blog/article/1c7c5bb5.html</url>
      
        <content type="html"><![CDATA[<p>又有很长时间没有更新博客了……听说最近评论好像又炸了，算了，反正也只有我自个看(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)。这段时间，我也经历了蛮多的事情，比如说找工作啦，毕业啦，巴拉巴拉一大堆事。校园生活应该也快结束了，不出意外的话。额，不立flag了。最近整个人呢，心情还行，就是感觉生活没有那么有活力了，好像少了点什么。所以，今儿个写点东西记录下。（ps：因为是想到哪写到哪，所以思路很混乱，看官们勿介意）</p><p><img data-src="https://cdn.makiru.top/images/202312181658570.jpeg"></p><span id="more"></span><p>不知道各位现在所在的地方天气咋样，上海这几天的温度和过山车一样，直跌冰点，差点没给我冻的背过气去。今天上海依然在下着小雨，我老家现在正在下着大雪，估计又快一片白了。不知道上海什么时候会下雪，听说今天早上下了点小雪，不过我在赖床，没起得来，所以错过了上海的初雪（有可能）。真希望今年的圣诞可以下雪啊，白色圣诞，听起来就很不错，虽然我还是只可悲的单身🐶！！！不过还是提前祝大家能够有人陪伴，不管是家人还是恋人都是好的～</p><p>这段时间，我一边在忙着毕业的事情，比如说大论文的撰写和望不到头的修改，小论文的投稿和望不到头的等待。只能说光毕业一件事就已经足够心累了。大论文真的是让人崩溃，研究生两年半能研究个啥，不瞒各位，我研究生的学业生涯整体上来看算得上是五花八门，研究生还没入学之前就开始帮导师做横向（导师人蛮好，至少还有工资可以拿），做的是什么呢？纯后端开发，从设计到开发，单纯的技能训练功课。入学后，学业方面自然不用说，项目方面还是继续横向（那时候觉得还挺好的）。等把横向做完后或者说烂尾后，我们便又开始了下一个项目，这个项目直接贯穿了整个研究生生涯，因为它同样也是我的毕业设计，即大论文的主题。做到中途，感觉研究生好像没啥能学到的，完全只能靠自学，从那时起，我便开始学习各种框架、各种底层原理啥的，和各位大佬一起卷的越来越深，甚至不自知。</p><p>到了今年二三月份的时候，我已经研二下了，要开始找暑期的实习了。找实习的经过就不细说了，毕竟在上一篇记录里也有写到。这里就简单说下，我当时是面了蛮多公司的，有些是面的挺差的，有些是因为个人原因放弃面试了，最后嘛，也没中几个，下面这张图里的只是一些我觉得有必要记点东西的公司（因为一些问答感觉还是蛮有用的），当然没截全哈，下面还有不少(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)，菜如我，怎么可能就面这几个公司就中奖了呢？可能有人会说：哇，都是好公司啊，小厂都看不起嘛！当然不是啦，只是我没有记罢了，小公司我都记不清面了多少，唉，只能说还是我太菜了，找个实习都是如此的艰难……</p><img data-src="https://cdn.makiru.top/images/202312181924728.jpg" style="zoom: 33%;" /><p>作为一名“高贵”的研究生，总不能毕业即失业，所以纵然再心累，找工作还是有必要的。研三刚开学，我便把重心完全放在了各种面试上，虽然实习有转正，但谁也不会all in这种还没确定的事。当然啦，相比于实习，正式找工作的时候，我反而没有面很多家了，或许的确是因为仗着有实习转正吧。最后我还是走的实习转正，有多方面的原因吧，比如说，这份工作在内容上还行，能学不少东西；工作氛围嘛，挺活跃的，最主要的是别家公司面试好难┏ (^ω^)&#x3D;。这两天把三方也已经弄的差不多了，工作算是定下来了吧（前提是能顺利毕业，哈哈哈）。</p><p>这段时间，我在我们学校的论坛上看到了不少谈论大学生活或者研究生生活是多么多么的无聊，多么多么的卷，自己是多么多么的无力。不知道为什么，蛮理解他们的。但怎么说呢，和那些很🐂的人比，本来就很难的，大多数的人并不是生来就是天才，他们或多或少都用某些东西作为代价换来了现在的光芒。相比较之下，我觉得作为普通人，至少我认为我已经做的还可以了（没有尬吹我自己），不算太好但也算不上太差。论坛里的那些人，我不清楚造成他们这种想法的根因，毕竟能读到现在的地位，智商方面应该是没有问题的，吃苦耐劳应该也不差，或许可以像我一样，把心里的东西写出来，也许会好点吧。</p><p>不知道大家有没有看到过，很多人开导抑郁患者时，会被说“不知他人苦，莫劝他人善”这种类似意思的语句。怎么说呢，开导的主观想法或许是善意的出发点，但在客观上却可能起不到积极的作用。论坛里蛮多人在帖子的下面劝导这些整天想退学、想自鲨的学生，想法是好的，但做法是不是对的，我没有办法评断，毕竟我自个有时候也会擅自将别人的字面语句代入到我自己的理解中，然后去自以为是地做所谓的“劝导”。有时候看到自己以前的发言，感觉有些搞笑……额，好像扯远了。最近的日常生活确实蛮枯燥的，毕竟快毕业了，现在首要大事就是确保毕业的道路一帆风顺，为此我需要确保自己的大论文（💩）以及后续的答辩能够顺利完成。所以呢，这段时间我竟然连番剧都不怎么追了，等工作以后估摸着更不会有时间去看了。</p><p>最近比较感兴趣的事是看Vup直播，无聊的话也只能靠自己去挖掘新的玩意去解乏了。然后呢，由于天气忒冷了，去图书馆的频率基本快归零了，当然，这也是因为图书馆在装修一个不知道是啥的东西，油漆味、电焊味充斥着整个图书馆，闻到了会非常难受。昨天去图书馆，刚进门差点没给我整吐，也不清楚咋想的，味那么大，结果二三四楼都是密闭的，但走廊里学习的人竟然还有那么多，只能说学霸们不管在什么样的环境下，都能够适应。</p><p>最近游戏上，依旧还是卑微渠道服的fgo。ssr这段时间有抽到一些一直想要的，比如花嫁，单抽出奇迹；还有妖兰，双黄蛋，一个十连出了两个，直接二宝，当时别提多开心了。然后，瓦也打了一小会，因为我的游戏本竟然已经带不动这款游戏了，另外主要原因是我太晕3D了，难顶……</p><p><img data-src="https://cdn.makiru.top/images/202312182128678.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/202312182129658.jpeg"></p><p>对了，今天还发生了一件比较搞笑的事。前面不是说这几天我把三方基本搞好了嘛，今天刚从公司那边把三方拿回来，然后学校要求做个网上登记毕业去向之后才能去盖学校的章。网上登记里有一个税后工资登记，我算过后才发现原来自己的工资没想象中的那么高，税前还行，税后直接尴尬了。魔都不愧是魔都。差点没给我笑死(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)。</p><p>好了，今天就先写这么多吧，剩下的就等后面慢慢记流水帐吧～祝各位都能有个好工作，好心情，好生活。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假我在做什么</title>
      <link href="/blog/article/60fe0831.html"/>
      <url>/blog/article/60fe0831.html</url>
      
        <content type="html"><![CDATA[<p>已经很长时间没有更新博客了，今天想放松下（其实一大堆事没做完～），写点东西，讲讲这段时间我在做些什么。</p><p><img data-src="https://cdn.makiru.top/images/202307222018507.jpeg"></p><span id="more"></span><p>这段时间呢，因为忙着各种各样的事，导致一直抽不出时间，来写点想写的事（^ _ ^都是借口）。大概是4、5月份的时候，我在各种各样的实习面试中，忙的不可开交，结果还是0offer。忙活了这么长的时间，结果还是两手空空，那段时间心里确实不是很好受，在别人面前却也不得不说着“没事没事，再找找总会有的”。到了5月下旬的时候，我接到了一个offer，这里就不透露细节了，心里还是很开心的，至少努力过，也有了相应的收获。找实习的经历算得上是我目前人生中比较坎坷的一个回忆了（别误解，我的人生也不是一帆风顺～），但结果总归是好的嘛。</p><p>实习找到后，我在学校里又呆了一个礼拜，这一个礼拜也在忙着找房子，毕竟实习的地方离学校还是蛮远的，来回奔波有点吃不消（去踩点实习地点的时候，体验过一次），而且即使不怕吃苦，但晚上回来的时候也太晚了，洗澡什么的不太好，会影响其他同学的睡眠。总之，最后我还是打算在实习公司的附近找个便宜点的、单租的小房子。找房子的过程嘛，一开始我是约了自如的管家去看了三套房，都是合租的房子（主要是了解下房型和价格），然后我就在一些无中介租房软件上找房源，最终找了一个转租的，位置离公司稍稍有点远，6站地铁，单租，新装修（就是电费有那么点贵～）。整体上来说，找房子还是比较顺利的，也挺满意的（除了中间两次空调内机漏水～）。</p><p>房子找好后，我就直接入职实习了。每天就在公司里熟悉环境，慢慢开始上手，收获还是挺多的。实习整体上来说，有那么点累，其实也不是公司里的活有多累，主要是现在实习的同时，我还得同时兼顾学校里的事（因为每周二我还需要和导师开组会，至少也要有点东西说，才不会显得那么尴尬，对吧），身体、心理上都有点吃不消。话虽是这么说，但问题总归是需要人来解决的。慢慢熬吧(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)</p><p>哦，对了，前几天fgo，我又出货了，3个十连，出了一个弓呆和大象（二宝），第二天的心情（半夜抽的）很不戳。</p><p><img data-src="https://cdn.makiru.top/images/202307222208519.jpeg"></p><p>石头也不多了，骑呆就暂时不抽了，等八月份抽公主～到时候出货了再炫耀下。</p><p>这几天，上海是真的热，在公司还好，至少一直呆在空调里，一回到租的房子里，感觉身上着火了似的。这也是为什么空调对我来说，实在是太重要了，内机漏水的那几晚，我基本没睡着，热得要命，还好后面修了，也不知道能保多久，看运气吧。</p><p>昨天的上海，天就像漏了一样，雨下的超级大，马路上全都积满了水，我下班回去的时候，公路上倒是水都排干了，没想到到小区门口，直接震惊我一百年，水特别的深。小区门口站满了人，都不知道咋回去。我看了看周围，反正也没啥其他的路，而且我住的离小区门口也蛮近的，干脆光脚蹚水，一步一步走了回来。</p><img data-src="https://cdn.makiru.top/images/202307222215023.jpg" style="zoom:33%;" /><p>水有多深，大家伙可以看看上图，猜一猜。天太黑了，我一手提鞋，一手拿着手机手电筒，慢慢地蹚了回去。</p><p>这段时间，基本上我主要的精力还是花在了实习上，学校的相关事宜我都先搁置在一边了，打算9月初回学校，把论文等事情开始操弄起来，祈祷正常毕业。后面有空的话，给大家再介绍介绍工作日时我一天的经历。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天用BFS做了什么</title>
      <link href="/blog/article/5d78f5bd.html"/>
      <url>/blog/article/5d78f5bd.html</url>
      
        <content type="html"><![CDATA[<p>今天又是周日，每周最开心的一天，因为今天可以感受到那种难以忘怀的刺激感。每周日的上午，我习惯性地打一场leetcode的比赛，因为只有比赛时才让我有种在用脑子的感觉。虽然我现在还是个菜鸟，但是还是有那么一点点的提升的～</p><p>今天的比赛，怎么说呢，自己做的不是很好，甚至可以说是最近打的最差的一次了（虽然A了三题，但是依旧掉大分），总体上来说，只有T4挺难的，T3想复杂了，一个贪心就行了，我还非得用dfs来几次TLE。下次继续努力～</p><p><img data-src="https://cdn.makiru.top/images/202304021922048.jpeg"></p><span id="more"></span><p>今天主要是想记两道题目，一道是今天周赛，也就是339的T4，一道是昨晚夜周赛101的T4，两道题用的核心思路都是BFS（是不是很巧～）</p><h2 id="339的T4"><a href="#339的T4" class="headerlink" title="339的T4"></a>339的T4</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个数组arr，长度为n，下标从0开始，给定一个p（p在0到n-1之间），表示数组arr中除了p位置为1以外，其他都是0；给定一个banned数组，arr中下标在banned中的所有数不能为1；给定k，表示每次操作可以将一个长度为k的子数组翻转（指顺序上的翻转）；返回一个数组答案ans，其中ans[i]表示将1移动到i位置所需要的最少操作次数，无法翻转到的设置为-1.</p><p>注意：任何操作都不允许将1翻转到banned中的下标位置（<a href="https://leetcode.cn/problems/minimum-reverse-operations/">原题</a>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, p = 0, banned = [1,2], k = 4</span><br><span class="line">输出：[0,-1,-1,1]</span><br><span class="line">解释：k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 1 在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。</span><br><span class="line">我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。</span><br><span class="line">通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, p = 0, banned = [2,4], k = 3</span><br><span class="line">输出：[0,-1,-1,-1,-1]</span><br><span class="line">解释：这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。</span><br><span class="line">翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。</span><br><span class="line">由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。</span><br></pre></td></tr></table></figure><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>没有(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)，比赛时没做出来，还是菜</p><h3 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a>官方思路</h3><p>利用BFS，首先我们需要知道，位置i经过一次翻转，可以到哪些位置去（核心），由于存在一个k窗口，因此可以假设窗口的左端点为t，那么很容易知道i在这样的窗口下，翻转后的位置为：&#x3D;&#x3D;2t + k - 1 - i&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据对称原理：</span><br><span class="line">t + t + k - 1 = i + x</span><br><span class="line">因此:</span><br><span class="line">x = 2t + k - 1 - i</span><br></pre></td></tr></table></figure><p>那t是否存在范围呢，当然有，如果是无限大的数组，t最小为i - k + 1，t最大为i，但数组有范围，所以t的范围为[left, right]：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left = Math.max(0, i - k + 1);</span><br><span class="line">right = Math.min(n - k, i);</span><br></pre></td></tr></table></figure><p>从翻转后i所在的位置表达式中可以看出，窗口每向右移动一个，翻转后的位置就移动2个，因此翻转后的位置奇偶性是保持一致的，是奇数还是偶数取决于k - 1和i的关系。</p><p>因此，为了避免重复性将跳到过的位置加入队列，可以将0到n-1这些数，除了p和banned里的数以外，按照奇偶性放入两个TreeSet中，这样就可以实现翻转到过的下标就立马删除，并且可以在O(logn)的时间里找到第一个翻转的下标（利用TreeSet的ceiling(x)方法，表示找到第一个大于等于x的数，没有的话返回null）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] minReverseOperations(<span class="type">int</span> n, <span class="type">int</span> p, <span class="type">int</span>[] banned, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            ans[p] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : banned)&#123;</span><br><span class="line">            set.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt; odd = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//奇数</span></span><br><span class="line">        TreeSet&lt;Integer&gt; even = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();    <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != p &amp;&amp; !set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    even.add(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    odd.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.addLast(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(ans[root] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    ans[root] = step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, root - k + <span class="number">1</span>);   <span class="comment">//滑窗起点最左边</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(n - k, root);</span><br><span class="line">                <span class="keyword">if</span>(root % <span class="number">2</span> == k % <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">//奇数选</span></span><br><span class="line">                    Integer start;</span><br><span class="line">                    <span class="keyword">while</span> ((start = odd.ceiling(<span class="number">2</span> * left + k - <span class="number">1</span> - root)) != <span class="literal">null</span> &amp;&amp; start &lt;= <span class="number">2</span> * right + k - <span class="number">1</span> - root)&#123;</span><br><span class="line">                        queue.addLast(start);</span><br><span class="line">                        odd.remove(start);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//偶数选</span></span><br><span class="line">                    Integer start;</span><br><span class="line">                    <span class="keyword">while</span> ((start = even.ceiling(<span class="number">2</span> * left + k - <span class="number">1</span> - root)) != <span class="literal">null</span> &amp;&amp; start &lt;= <span class="number">2</span> * right + k - <span class="number">1</span> - root)&#123;</span><br><span class="line">                        queue.addLast(start);</span><br><span class="line">                        even.remove(start);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实，如果不用TreeSet的话，暴力解的话，就需要加个辅助数组，用来记哪些位置是已经翻转到过的，避免重复入队，并且在判断从i翻转一次的下标时，需要枚举左端点从left到right，并在该左端点时判断对应的翻转位置是否已经翻到过，这样的话就是O(n^2)的，会超时。</p></blockquote><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>其实，打比赛做到这道题的时候，还剩下半小时（别骂， 因为我太蠢了，在第一题花了蛮长时间～脑子生锈了，第三题想偏了），然后也没有啥思路，就直接原地坐牢到结束。</p><p>在数组上利用BFS实现跳跃，感觉这种用法我倒没咋用过，虽然不保证以后遇到变形题会做，但至少知道有这类题了，也算是不错的收获了。</p><h2 id="101的T4"><a href="#101的T4" class="headerlink" title="101的T4"></a>101的T4</h2><p>这场比赛我没打，因为昨晚有预感，打了得掉大分（即使不打，今天照样掉大分～）</p><h3 id="题目介绍（经典题目）"><a href="#题目介绍（经典题目）" class="headerlink" title="题目介绍（经典题目）"></a>题目介绍（经典题目）</h3><p>给定一个无向图，边用二维数组edges给出，没有自环、重复边，问最小环的长度</p><p><img data-src="https://cdn.makiru.top/images/202304022003943.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 </span><br></pre></td></tr></table></figure><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>一开始想用dfs去做，结果发现，有点做不出来(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)，然后就想BFS，直接枚举BFS的起点，然后得到包含起点的最小环的长度</p><h3 id="官方思路-1"><a href="#官方思路-1" class="headerlink" title="官方思路"></a>官方思路</h3><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>利用<strong>枚举起点+BFS</strong>，当针对于出队的点cur与它的父节点fa，我们看cur的邻居节点x，如果发现邻居节点x不是fa但已经访问过或者说入队过，这说明从起点到该邻居节点x有两条不同的路径，也就是形成环了，环的长度为dis[cur] + dis[x] + 1，这时可以选择直接返回，因为是BFS，所以包含起点的最小环不可能比当前的还要小。</p><p><font color=red>注意：这里说的形成环，并不能保证起点到x是一个环，但能保证x一定是环的一个点，比如说有两条路径：1-2-3-5和1-2-4-5，这里1-5就没有形成环，但是无所谓，因为是枚举起点，当起点为2时就可以缩小答案了</font></p><p>由于这里需要记录起点到其他点的距离，因此直接利用dis来标示节点是否被访问过或者说入队过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//主函数省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dis, -<span class="number">1</span>);</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, -<span class="number">1</span>&#125;);</span><br><span class="line">        dis[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] root = queue.removeFirst();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> root[<span class="number">0</span>], fa = root[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x : map.get(cur))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x == fa)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dis[x] != -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> dis[x] + dis[cur] + <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dis[x] = dis[cur] + <span class="number">1</span>;</span><br><span class="line">                        queue.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, cur&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>利用<strong>删除边+BFS</strong>，假设原始图里有边i-j，那么我们如果把这条边删掉，再利用BFS（因为边权为1，所以可以直接简单BFS）求i到j的最短路径，如果有最短路径，说明i-j是某个环里的一条边，环长度为最短路径 + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">//主函数省略，枚举start-end边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        Arrays.fill(visited, <span class="literal">false</span>);</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.addLast(start);</span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(cur == end)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x : map.get(cur))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur == start &amp;&amp; x == end)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[x])&#123;</span><br><span class="line">                        queue.addLast(x);</span><br><span class="line">                        visited[x] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h3><p>这道题感觉还不错，考的东西比较基础但很实用，BFS的用法在这道题里主要是用来求起点到其他点的最短路径。</p><h2 id="整体收获"><a href="#整体收获" class="headerlink" title="整体收获"></a>整体收获</h2><p>BFS还是蛮有用的，可以用到的地方很多，还有很多不同的变种。虽然这次周赛掉大分，但是还是收获了不少。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找实习的那点事儿</title>
      <link href="/blog/article/35434592.html"/>
      <url>/blog/article/35434592.html</url>
      
        <content type="html"><![CDATA[<p>春天到了，不知道武大的樱花现在开得如何了，蛮想回去看看，顺便尝尝桂园食堂的热干面……最近的自己，感觉有点小小的焦虑，为什么呢，其实也不是多么大的事，就是在为找实习的事忙的晕头转向的（也没那么夸张，单纯自己懒～）。</p><p>借此机会，稍稍记录下这时的我是怎样的状态吧，便于十几年后的自己，看看当时的我与社会进行初次较量是有多么的窘迫。</p><p><img data-src="https://cdn.makiru.top/images/202303092013913.jpg"></p><span id="more"></span><p>虽说疫情已过去整整一年多了，但是计算机相关的这一行业却并没有回到当年那样的光景。毕竟，从我身边的那些大佬们，为了找工作、找实习而捐出去的头发量中，就已一目了然。其实，我自己也没好到哪里去，仅仅只是因为我才刚刚在找实习的这条狭窄拥挤的路上起步，说实在话，挺为自己担忧的(&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;)。</p><p>先说说我目前的状况吧，好吧，其实也没什么特别的。到今天为止，我其实也就投了几个中小厂，有通知笔试的，也有完全没消息的。在找实习的这段时间里，感觉自己好像又回到了高中时代，背不完的八股，看不完的面经，填不满的脑子，改不完的简历。说点实在话，八股这玩意到底是谁发明的，跟工作有个锤子关系，背的都快恶心死了，却还总是边背边忘。看着自己空荡荡的简历，猛然发现原来自己学了这么多年，学了个寂寞，啥也没留下。</p><p>有时候，生活在你烦恼苦闷的时候，并不一定会给你打开一扇希望的窗，别问为啥，问就是哥总结经验得出来的。现在也只能不停的准备，看看能不能给自己找个一般的暑期实习咯，但愿能有个公司收留我。</p><p>虽然并不一定有希望的窗，但是嘛，人还是要想得开的，今天在微博上的热搜上看到了这样一条新闻：</p><blockquote><p>说唱女歌手转行卖烧烤年入百万</p></blockquote><p>有一句话让我印象很深，<strong>梦想和生活并不矛盾，无需在意他人的眼光</strong>。确实，生活过的至少也要像个人才行嘛，那梦想呢，好像我都忘记自己有啥子梦想了，这20多年，回头一看，好像自己没有啥所谓的梦想，好像只要能过得开心快乐，踏踏实实的做个普通人就够了。奈何做个普通人其实也是很难的，因为生活过的像个人有时候说不定真的挺有难度。一个春招季，其实并没有给我带来多大的震撼，因为我知道自己有几斤几两，多大能力就做多大事，这是老一辈人传下来的经验，又怎么会有错呢？我只是觉得，有时候，为自己能活的像个人一样，早做打算是个不错的主意，省的到了以后，和现在的我一样，发现从前的自己并没有为现在的我做什么打算。</p><p>说了这么多的废话，总结下来就一句话，生活不甜但也不苦，等到甜的时候说明苦你也尝过了。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开学前的一点唠叨</title>
      <link href="/blog/article/169d2c6e.html"/>
      <url>/blog/article/169d2c6e.html</url>
      
        <content type="html"><![CDATA[<p>马上就要开学了（虽然本人在昨天已经早早返校），趁着开学前，记点小事……本人目前已经研二了，还有一年的时间就要真正地从学校的舒适墙内踏入残酷的社会中。每天都在无尽的焦虑中度过，真的很累（总算能理解之前学长说的研二下是“痛苦”并快乐着的）。</p><p><img data-src="https://cdn.makiru.top/images/202302031720970.jpeg"></p><span id="more"></span><p>所谓的焦虑，一方面来自于毕业的压力，或许有人会问，你一个专硕，有啥子毕业压力，一开始我也是这么想的，但是后来我发现自己最初的想法还是太天真了（到底是谁和我说专硕毕业简单的！！！）。先说下我们学校电院专硕的硬性毕业要求吧：至少一篇专利或者一篇学术性论文，答辩和大论文通过。听起来还是蛮容易的，我也这么觉得……然后呢，在老板的帮助下，我借着一个纵向发了一篇专利，本以为只要把大论文搞搞就差不多了，结果，学院给我来了个答辩20%淘汰制，呵呵呵～此外，在最近的一次组会中，隐隐约约能感觉到老板是希望我们几个人每人至少都投一篇会议或者期刊（说是咱实验室都是这样的，传统）。心拔凉拔凉的。</p><p>最近的工作也遇到了阻碍，理论性证明（遗憾匹配，匹个鬼）。脑子里是一片浆糊，不晓得从哪下手，再这样下去，感觉模型都得改了（应该必须得改了，因为差点意思）。</p><p>这学期的实习还没着落，老板也不晓得放不放。今天唯一值得开心的事就是原本说今天是小雨，竟然出太阳了。过几天还得去修个电脑，电脑电池好像鼓包了。</p><p>哦，对了，以后还是别来学校太早，不然就会像我一样，想在学校找个买泡面的地方都没有。一问才知道，原来学校里目前只有二餐和玉兰苑开了，还有罗森（太远，不想去）。这学期还是加把劲吧，争取把手头的这个牛皮糖赶紧做完甩了。</p><p>一天又要过去了，我又成功地在实验室摸了一天的🐟（因为图书馆没开，不得已去的实验室～）。明天希望能够弄点想法出来，不然就不太好交差了。</p><p>动漫，游戏，都是毒药，而我却甘心沉沦在这些毒药中，不扯了，找点搞笑视频解解乏(&gt;^ω^&lt;)</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Engage Kiss《契约之吻》</title>
      <link href="/blog/article/9ef3338d.html"/>
      <url>/blog/article/9ef3338d.html</url>
      
        <content type="html"><![CDATA[<p>最近一段时间，博主正在为即将到来的找工作做准备，所以也是停更了一段时间。当下这个形势，想要找到一份比较不错的工作实在是太难了，而博主现在的专业水平也就是个半吊子而已，所以嘛，不准备准备，后面的路也就越来越难走了。</p><p><img data-src="https://cdn.makiru.top/images/202209192133606.jpeg"></p><span id="more"></span><p>然而，上海这段时间疫情封控竟然又开始了，导致我现在还是被封在寝室里哪也不能去，内心真的是很苦逼；不过嘛，博主至少也学了一个暑假左右，感觉找个小饭碗应该还是可以的（纯属自我感觉良好～）</p><p>封在寝室的我，虽然内心苦逼，但是嘴上还是得夸一句，学校这次对我们的待遇还是不错的，无论是食物，还是水果都十分到位，每天基本都会有水果，一日三餐的花样也是极其丰富（除了每天早上需要6.30起床做核酸有点难顶）</p><p>题外话说的有点多了，进入正题吧。今天我想讲的一部番叫做《Engage kiss》，中文番名叫做《契约之吻》。这部番开播之后，大家的反响千差万别，有的人说很好看，而有的人说编剧在乱改，不过就我看完第12集之后来说，整体上剧情有点点小难懂，因为番中的回忆部分有点乱，感觉放的位置有点怪怪的；就人物塑造上来说，由于我个人不太清楚原著中每个人物的性格特点，所以也不太好做评价，总之，萝卜青菜，各有各爱。</p><p>番剧的背景设定是在一座漂浮在海洋之上的城市中，这座城市依靠开采出来的奥格素进行运转，也正是因为这奥格素，使这座城市中频频出现一种名为恶魔现象（人类经过契约被恶魔附身，进而获得力量）。番中的男主是一位名叫修的少年，小时候的一场奥格素开采意外致使其失去了双亲以及自己最爱的妹妹环奈，但是修并不相信自己的妹妹已经死去，认为一定是恶魔带走了自己的妹妹，也正是因为这个原因，他与一位恶魔签订了契约，而这位恶魔也就是番剧的女主之一木更，成为了一名正式的驱魔者。</p><p>修与木更的契约是以修的记忆为代价，而触发媒介是两人的嘴唇相碰，归还记忆的方式是十指相扣。</p><p><img data-src="https://cdn.makiru.top/images/202209192150418.jpeg"></p><p>这拉丝，真的是服了</p><p>虽然是一名驱魔师，其实修每日的生活也是靠木更与他的前女友绫乃支撑着（俗称吃软饭，哈哈哈）。而木更与绫乃之间嘛，自然也就是水火不容的那种状况啦，两人在第一集就相互掐上了（最后嘛，也多亏木更成功拿到了修家的备份钥匙，才解决了这场内斗）。</p><p>kiss之后的木更真的是好看，我特别喜欢那套衣服的配色</p><p><img data-src="https://cdn.makiru.top/images/202209192158457.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/202209192200394.jpeg"></p><p>嘛，其实木更要身材有身材，又贤惠，又管家，这样的媳妇在现实中可不好找。</p><p>既然说到了绫乃和木更之间的掐架，就不得不提这部番中的动作场面还是很不错的。</p><p>虽说绫乃是修的前女友，但其实也不完全对，因为这只是单方面的罢了，随着契约的不断签订，修的记忆在一点点失去，自己和绫乃之间的那些往事也基本快忘光了，甚至连两人第一次约会时绫乃穿的衣服都没有丝毫印象了。</p><p><img data-src="https://cdn.makiru.top/images/202209192206796.jpeg"></p><p>最虐的其实是，绫乃一开始并不知道修的契约代价是他的记忆（更虐的还在后面）。绫乃一如既往的关心着修，为他做家务，交账单，时不时也会因为木更的恶作剧而嫉妒生气。</p><p>随着几人驱魔大业的不断推进，离真相也越来越近，而这时也来了一位修女，莎朗。这位修女和他们一样是驱魔者，属于某个庞大的组织，因为这座城市即将出现极强的恶魔而前来解决。莎朗与修也属于老相识，这两人曾经一起将木更放了出来，而莎朗的目的是想杀了木更，修也知道，于是在一个两人激情四射的夜晚，在莎朗身上不可言语的位置下了神经毒素（至于是哪里，你猜咯）</p><p><img data-src="https://cdn.makiru.top/images/202209192223224.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/202209192215053.jpeg"></p><p>也正是因为这个原因，莎朗与修一见面，就大打出手，但是嘛，懂的都懂，怎么可能下死手</p><p>随着剧情的推进，最终，众人将恶魔代理人（怂恿人类与恶魔签订契约）的嫌疑指向了迈尔斯，迈尔斯是一名普通的警察，同时在修的双亲消失后抚养了修一年的时间。正是因为这样的纠葛，修的内心痛苦万分，美好的过往如同谎言一般。</p><p><img data-src="https://cdn.makiru.top/images/202209192243810.jpeg"></p><p>其实，迈尔斯是恶魔的原因，真的是我没有猜到的一点，这也是整部番中让我感到难过的点之一。迈尔斯的女儿与修小时候也是好朋友，两人玩的很开心，后来，他女儿患上了重病，即将死去，这时，一位不知名的人过来告诉他，自己可以救他女儿，就这样，为了救女儿，他选择了一条本不该走的路。</p><p><img data-src="https://cdn.makiru.top/images/202209192224670.jpeg"></p><p>修选择用自己与迈尔斯所有相关的记忆与木更签订了契约，并且最终自己亲手了结了自己的养父，而迈尔斯最终也选择死在修的手上，算是偿还自己多年之前在那场意外中的债。</p><p>其实，真相往往离自己很近，只是自己看不见罢了。环奈确实活着，而最后的幕后黑手也是我万万没想到的，最后的幕后黑手名为阿斯摩太，她的掩饰身份正是修的母亲小百合。而环奈则是恶魔与人类的孩子，也是连接恶魔世界的大门，阿斯摩太想要用这孩子释放更多的恶魔进入这个世界。于是便趁那次奥格素考察，将所有人全部清除，最后也是迈尔斯（这时的他已经是恶魔了，在这里，也可以猜测和迈尔斯做契约的就是阿斯摩太本人）来这将修带走了。</p><p><img data-src="https://cdn.makiru.top/images/202209192252736.jpeg"></p><p>修的妹妹环奈也就一直被封印在这座矿场中，后面嘛，剧情就有点离谱了，妹妹疯狂追杀自己曾在梦中看到的与自己哥哥亲近的人（环奈与修靠梦连接），首当其冲的自然就是木更，于是乎，木更被打的半死不活（因为木更也不想对修的妹妹动手），最后嘛，在医院醒来后，木更将所有的记忆包括她自己的都给了修（这里也是我感动的一个点，因为修并不知道取消契约的方式——十指相扣，甚至，木更一直用来获取力量的并不是修的记忆，而是自己的记忆）。</p><p><img data-src="https://cdn.makiru.top/images/202209192244086.jpeg"></p><p>木更忘记自己是谁，而修也选择了去对抗自己的妹妹，至于结局嘛，不清楚，因为还没出嘛，其实对我个人而言，我更希望结局能够不要那么的明确，因为番中与修有瓜葛的女生有三位：前女友绫乃，莎朗，木更，也不能说哪位女主更好这种观点，各有各的好，所以我也不希望谁会消失。梦想总是美好的，但现实却一直是残酷的，结局应该没我想的那么美好。</p><p>不过嘛，木更和绫乃真的好可爱，可爱爆了，结尾再贴几张图吧。</p><p><img data-src="https://cdn.makiru.top/images/202209192249832.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/202209192250538.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/202209192251259.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
            <tag> 后宫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的暑假生活</title>
      <link href="/blog/article/31de863.html"/>
      <url>/blog/article/31de863.html</url>
      
        <content type="html"><![CDATA[<p>时间过的很快，转眼就已经进入暑假了，这或许是我最后一个可以自由支配时间的暑假了，嗯………，也不能这么说，更准确的说法是，对于一个成年人而言，暑假这个概念是仅存在于学生时代的。虽说是可以自由支配时间，但是，每周的生活依旧是日复一日的重复，仿佛一个已被写好运行脚本的程序，只会永不停歇的按照剧本去走。</p><p><img data-src="https://cdn.makiru.top/images/202207142011280.jpeg"></p><span id="more"></span><p>上海的暑假，这还是第一次，给我的唯一感觉就是一个字：热，用我今天看到的一句调侃来表达我每天中午来回宿舍时的感受，即使肋骨断了，也无法阻止我要找一个阴凉的地方再躺下。至于每天为啥中午我要来回宿舍呢，呵呵，因为这是这所鼎鼎有名的大学，上海顶尖学府，位于中国985前列的学校所能做出的一项“高明”的规定：中午12点到13点，图书馆不允许有学生在内，图书馆需要进行为时一小时的消毒～当然，下午17点到18点也是如此。</p><p>学生时代，最后一个可支配的暑假，该做点什么呢，虽然我希望能够选择想做的事，但是经过深思熟虑，我发现自己也不知道想要做什么。每星期周二上午10点，是我最想快点结束的一个时间点，因为这个时间我正在开着例常组会，也就是汇报自己在这周的工作。只要汇报完，就是一周中最为快乐的游戏时间，你没听错，每周的周二下午，我都在肝我的游戏。然后嘛，一周中剩下的几天，不是在看下周汇报知识点的路上，就是在看知识点的过程中。</p><p>虽然听起来，确实有点无聊（连我自己都这么觉得～），但是，既然作为一个研究生，就该做点研究生该做的事，我的一个做人准则就是，端什么碗，吃什么饭；穿什么衣服，进什么场合。也正是因为这样，我才会选择这个暑假呆在上海，希望能够把自己的研究课题往后推进一点，争取能够尽早出去实习（说点实在话，在没进社会之前，总是期待着能够早日进入社会，但是却又害怕进入社会遭受社会的毒打）。</p><p>过几天，打算去我爸那呆段时间，毕竟总是一个人呆在学校，还是怪无聊的～</p><p>这段时间，听小道消息说上海很快又会针对这次疫情的反复做出一定的措施，也不知道是什么样的措施，该不会又是封锁学校吧（虽然现在也没差，出个校门麻烦得很），也不晓得自己到底要不要回去。生活中真的到处都充斥着不一样的选择。</p><p>今天呆在图书馆的我，好像也只是单纯的刷了点lc，但是效果不是很好，很多没遇到过的技巧没想到我并不怪自己，但是曾经做过很多次的技巧我还是没有想起来，好像每次遇到这种题首先想到的都是固定的，效果不好的，较差的思路，哎，还是得反复地刷这些题。</p><p>这几天想给自己的博客加个友链，第一时间想加的就是<a href="https://pinlyu.com/">频率</a>，因为这个站点为我调整博客样式提供了很大的帮助，在此非常谢谢频率的博主～（偷偷的说一句，甚至我还在修改样式的过程中，稍稍学会了点css和js）。当然啦，CC大佬的<a href="https://blog.ccknbc.cc/">博客</a>也是为我的主页提供了很多的新奇思路，在此也表示真挚的感谢。</p><p>最近这段时间我在肝的游戏呢，叫做星露谷物语，一款比较休闲风的游戏，每天种种地，挖挖矿，钓钓鱼，享受着虚拟社畜的日常生活也是一种不错的体验～顺便给大家看看我的农场布局吧，感觉也还是比较一般，做的时候也没怎么细想（玩游戏开心为主！！！）</p><p><img data-src="https://cdn.makiru.top/images/202207142047092.jpeg"></p><p>明天又得全员做核酸，又要一大清早就热的发慌，蓝廋香菇～</p><p>真正的暑假生活就要开始了，我要好好准备下，努力熬过这个三伏天！哈哈哈，学习什么是另外一回事啦～</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测不准的阿波连同学</title>
      <link href="/blog/article/e5a460a3.html"/>
      <url>/blog/article/e5a460a3.html</url>
      
        <content type="html"><![CDATA[<p>好久没写了，今天在图书馆闲的无聊（其实bushi），写点东西消磨下时间。先说说最近我自身的一些状况吧，博主呢，目前还是一名在读的研一学生（准研二），因为这个暑假想把研究课题往后推一推，而且上海的长途大巴也不知道能不能走，于是乎就在学校里呆下来了。不得不说，上海的温度是真的高，每天晚上12.00我不开会儿空调我都睡不着。好像扯的有点远了，对了，给大家顺便看看我学校的图书馆吧，因为现在是晚上了，光线有点不太好（其实是我拍照贼垃圾）。</p><p><img data-src="https://cdn.makiru.top/images/202207011945812.jpeg"></p><span id="more"></span><p>其实呢，感觉最近的自己遇到了点麻烦，很多问题都想不通，导致最近这段时间一直没有怎么写博客，当然，绝对不是没素材可写哈，这段时间无聊的时候，我还是看了不少有意思的番剧的，就比如今天想写的这部番，其实是很早之前就看完了前11集，最后一集呢，是前两天看掉的，刚好，今天晚上，闲来无事，也不想这么早回寝室（因为寝室很热，外加有蚊子），所以就写点东西。</p><p>今天想介绍的番叫做《测不准的阿波连同学》，这部番看完后给我的感觉就是纯爱，萌死人不要命，超级搞笑之无敌搞笑。剧情其实也没多复杂，讲述的都是一些比较日常化的生活。男主名叫来堂同学，女主自然就是萌死人的阿波连玲奈，这两个人啊，我只能说是真的天造地设，无论是性格，还是脑回路都是绝配。</p><p><img data-src="https://cdn.makiru.top/images/202207012004532.jpg"></p><p>不知道是我的错觉还是什么其他的原因，我总是觉得玲奈的脸蛋有点肿（v*v），整部番里，基本都是靠来堂同学对玲奈各种神奇动作的神奇联想，有的时候我甚至都不知道这么联想的原因在哪里，但是嘛，有的还是比较好猜的，就比如说下面这个场景，不知道各位看官老爷们是否很熟悉？</p><p><img data-src="https://cdn.makiru.top/images/202207012011782.jpg"></p><p>这个发型，怎么样，这都快赶上高级托尼的手艺了吧，结果这是人家睡觉睡出来的，天理何在！当大家看到这个发型的时候，不知道想的是啥，反正我想的竟然和来堂同学神相似，这是要出道了吧～我印象里好像有很多反派是不是都是这个发型来着？</p><p>当然啦，来堂同学也不是一个纯直男，人家有时候也是能够让玲奈脸红的哟，最近看的最后一集，真的是甜到我了。星光之下，田野之上，来堂同学煮着泡面夜宵，两人吃饱之后，来堂同学深情地向玲奈表达了自己的情感（虽然原本是玲奈想说的，奈何没说出来），那一刻，感觉连天上的星星都在给两人制造氛围，咳咳咳，扯远了，又不是在写诗。</p><p><img data-src="https://cdn.makiru.top/images/202207012018257.jpg"></p><p>番中还有一个十分重要的人物，那就是大城选手，这位选手呢，是玲奈酱的好朋友，两人很早之前就认识了，大城因为过于内向，导致没有什么朋友，直到遇到了玲奈，两人便成为了极好的朋友。最后也是大城选手的误打误撞，让来堂同学在番中正式地讲出了自己的心声（我喜欢阿波连同学！！！）。</p><p>哦，对了，玲奈酱还有一个超级萌的点，那就是她的说话声是真的小，小到你即使把你电脑声音调到最大都听不见，哈哈哈，因为她就没打算让你听见嘛，自然是听不到啦。也正是因为这个原因，每次玲奈酱都会与来堂同学坐的很近很近，基本就是玲奈酱坐在来堂同学的腿上。慕了慕了～</p><p>番中还有一些有意思的人物，比如桃桃老师，被欢乐感能冲出鼻血的女人～两个臭屁小学生（小小年纪不学好，还早恋），以及玲奈酱的几位家人（千万记得看性别～）</p><p>再放几张玲奈酱的卡哇伊图片吧，有兴趣的小伙伴可以去看看，还是很适合无聊的时候看的：<a href="https://www.bilibili.com/bangumi/play/ep477122?from_spmid=666.25.episode.0">测不准的阿波连同学</a></p><p><img data-src="https://cdn.makiru.top/images/202207012038699.jpg"></p><p>女仆装，就问谁不爱～</p><p><img data-src="https://cdn.makiru.top/images/202207012039076.jpg"></p><p>番中少有的日常服装，也还是很不错的对吧</p><p>那么介绍就到这了，对了，这两天其实我还在玩星露谷哟，我已经娶了潘妮老婆啦，并且都已经把婴儿房盖出来咯，很快就要和潘妮有爱的结晶啦，哈哈哈！</p><p>除此之外呢，看完的番还有不少，等忙完这段时间，有空我就一一介绍给大家，白白啦～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异世界迷宫黑心企业</title>
      <link href="/blog/article/f9a64679.html"/>
      <url>/blog/article/f9a64679.html</url>
      
        <content type="html"><![CDATA[<p>好久没写文章了，这段时间上海挺闹腾的，博主整个人也是很没有精神，外加这段时间课程作业有点多（其实现在嘛，也蛮多的～）。尽管如此，番剧也是不能够不看的，说实话，这段时间好像看了不少番了，连凡人修仙传我都有在追哦。等下次有空再介绍另一个番吧（应该很快就有空）。哎～再发发牢骚会儿，这段时间，博主蛮无奈的，因为已经快研二了，结果到现在好像还是空白一样，浑身上下就没有点研究生的气质（那种我很崇拜的学术气质，高雅永不过时！）而且老实说，对未来是真的迷茫，实在不知道未来的自己能不能真正的适应这个社会（毕竟像我这样的人，，干啥啥不会，哈哈哈哈～）</p><p><img data-src="https://cdn.makiru.top/images/202204242023341.jpg"></p><span id="more"></span><p>看到这幅全家福，相信应该有不少人已经知道今天我想介绍的番是啥了吧，没错，就是《异世界迷宫黑心企业》。实际上，看这部番的初始动机是因为前几天中午吃着盒饭的时候，发现没啥番可以看了，于是就上b站找了找，就翻到这部番了。就这样，我花了三顿午饭的时间就把这部番看完了（下次该看什么呢？）</p><p>怎么说呢，这部番真的是做得很不错了，无论是剧情还是人物设定都很戳我，非常适合作为泡面番哟～</p><p>话不多说，我就简单点介绍下整部番的大致内容。相信大家都有想过做一个不用考虑金钱问题的全职家里蹲，番中的男主——二之宫锦司，就是一个已经实现了这个目标的人，某天，他正在自己的高层大别墅中，穿着内裤发表着自己的感想，瞬间，他就穿越来到一个亚人的世界。在这个世界，几乎所有的人都是在为矿业而努力工作着。</p><p>二之宫也是一样，刚来到这边时，他用自己随身带的ipad换了很多钱，结果等ipad没电之后，就因为被误会成欺骗而欠下巨额贷款。没有金钱支撑的他也只能参与到这份无休止的工作中。矿业工作都是有一家叫做莱扎赫的公司掌管，而二之宫的boss也就是一位叫做贝尔莎的人（记住她，很有来头）。因为忍受不了高强度的工作，二之宫在一个角落中发牢骚的时候，意外的发现通往迷宫地下三层的秘密入口。于是乎，他就拉上极其老实的鳄呗（真的就是活生生被拉上贼船的），来到地下三层后，两人收集到了很多的魔石，结果在回程的时候，意外的被一只巨龙逮到了，眼看鳄呗就要玩完，二之宫那我永远跟不上的大脑有了个想法。</p><p><img data-src="https://cdn.makiru.top/images/202204242042310.jpg"></p><p>二之宫选择和巨龙合作，他答应巨龙只要巨龙保护他俩，他就会给巨龙很多好吃的。就这样，团队的第二位成员就这样加入了，她就是巨龙——莉姆。</p><p><img data-src="https://cdn.makiru.top/images/202204242046567.jpg"></p><p>说到这，我是真的佩服莉姆的肚子（是真的能吃啊），但凡少吃点，二之宫也能存点钱了（哈哈哈哈）。</p><p>后面嘛，二之宫还用过魔法道具让所有人给他干活，让他所在部门的业绩一度领先在前，虽然后面被众人知道了，暴打一顿。上面的人看中二之宫的探索能力，于是就给他调到了探索部门，在正式入职前，他和鳄呗还前往培训，至于培训内容嘛，无非就是让人成为真正社畜的培训啦。两人通过利用混乱草躲过一劫。</p><p>在迷宫里，二之宫甚至用自己的那套蛊惑人心的手段成功策反蚂蚁女王的所有手下，看到这，我是真的笑喷，真的就是人在家中坐，祸从天上来。当然啦，因为有莉姆在，所以自然而然，蚂蚁女王也成为了团队中的一员（至于为啥，因为蚂蚁女王就是因为莉姆出了迷宫，迷宫中没有了莉姆，她就没有啥好怕的了，一句话，莉姆本来是这个迷宫的终极大boss，只是因为贪吃跑出了迷宫）。</p><p>培训完后，团队的下一位成员也就出场了，她是一名勇者，叫做席雅，非常能打（被称为无脑部队，笑死我）。</p><p><img data-src="https://cdn.makiru.top/images/202204242101301.jpg"></p><p>然后嘛，在一次偶然中，莉姆与二之宫又被穿越了。这次他俩来到了未来的这座城市，于是呢，又一位成员出场了。</p><p><img data-src="https://cdn.makiru.top/images/202204242104070.jpg"></p><p>就是这个紫毛，是不是超级卡哇伊的啊，她的身份嘛，就是贝尔莎的后代，因为这座城市就是因为贝尔莎得到迷宫遗迹的力量后，过度开采挥霍，造成毁灭的。而紫毛，额，兰加，则是因为身为其后代，身心都受到了一定的伤害。哦，还忘说了，她还是这座城市的巫女哟～这次将二之宫召唤过来，主要是想请求他帮助拯救这座城市。</p><p>至于拯救的方法嘛，就是想办法打败魔王！！老套路，我也想到了，不过嘛，我们的男主会是这么简单的人嘛，不是！于是二之宫瞬间倒戈，投向了魔王军（在这里他还遇到了之前自己在迷宫中结交的蚂蚁A，不过人家现在可也是大老板了，而且是个良心的老板）。投向魔王军后，二之宫想办法往上爬，途中干掉了三个傻憨憨，终于见到了魔王，原来魔王就是迷宫因为莉姆跑掉临时生成的另一个boss，迷宫中的玛雅（这个世界的力量）需要boss来控制循环，保持迷宫的稳定。尽管当时这个魔王被生成后，却立马就被二之宫小团队给搞掉了。。到现在，头都容易掉下来（被莉姆咬的）。魔王希望男主能回去阻止贝尔莎，就这样，二之宫再次回到那个亚人世界。</p><p><img data-src="https://cdn.makiru.top/images/202204242142357.jpg"></p><p>回来之后，他开始抓紧攻略迷宫，希望抢在贝尔莎之前得到遗迹的力量。在攻略途中，甚至还能掰弯贝尔莎的亲卫队队长（我是真的佩服）。</p><p>最后，二之宫还是凭借他那卑鄙的手段，抢先拿到了那个力量，不久在力量和二之宫不同寻常的大脑同时运行下，这座城市也就成为了二之宫的囊中之物。贝尔莎内心现在肯定是千万草泥马。当然啦，后面的剧情也真的是足够波折，没想到贝尔莎在席雅的帮助下（席雅是个极其正义的人，所以没有离弃莱扎赫），竟然还真的把二之宫逮捕了。本来我都以为二之宫是不是完了，没想到他提前准备的紧急手册，竟然这么牛逼。贝尔莎在二之宫被抓起的这段时间，提出要担任莱扎赫的董事，结果嘛，当是当上了，但二之宫却在团队的帮助下，当上了莱扎赫的董事长。。</p><p>就这样，所有的一切都稳定了下来，当然啦，我还有很多有意思的地方没有讲到，比如说在攻略迷宫的期间，众人还一起照顾过未来的那位魔王（小时候的魔王也是真的可爱）。比如最后众人以为二之宫会选择回到日本而给他办离别会。。一大堆有意思的地方，非常值得去看。</p><p><img data-src="https://cdn.makiru.top/images/202204242144126.jpg"></p><p>名场面之一，这个紫毛可是一个男孩子哟～</p><p>我真的是很佩服这个番的人物设计，咋能这么可爱呢？</p><p><img data-src="https://cdn.makiru.top/images/202204242150979.jpg"></p><p>那就介绍到这啦，有兴趣的小伙伴可以自行前往观看：<a href="https://www.agemys.com/detail/20210154">异世界迷宫黑心企业</a>，对了，为啥叫这个名字呢，因为二之宫团队建立的公司就叫做黑心企业（很符合人设）。</p><p>白白啦，下次再介绍点有意思的番～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泡面番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋叶原-爆裂～</title>
      <link href="/blog/article/38c2ce2d.html"/>
      <url>/blog/article/38c2ce2d.html</url>
      
        <content type="html"><![CDATA[<p>又是一年一度的秋叶原活动～这次嘛，感觉也是老样子（虽然这应该是我第一次打这个活动，至于为啥这么说，懂得都懂。。）</p><p>这次活动的形式，看的应该还是仓库的丰富程度吧，毕竟从者多的一次可以多爬点楼。</p><p><img data-src="https://cdn.makiru.top/images/202203312134379.png"></p><span id="more"></span><p>博主已经爬到33层了，还有好多层得慢慢爬（虽然都是趁上课慢慢打的，哈哈～）</p><p>当然啦，这次其实不是为了介绍这个活动而特地写这篇文章的。我的真实目的是记录下这段时间我的“欧皇时刻”（bushi），怎么说呢，其实有的时候是真的非，又有的时候欧的不得了（气人啊）。</p><p>这次秋叶原呢，fgo也是出了一个新的从者（狂阶）——伽拉忒亚，我昨天把自己存了一段时间的30个石头（本来是打算去抽贞德的）来了一次，结果还真让我抽中了，本来想的是给我把刑步姬或者新娘尼禄抽出来就很开心了（其实我真正想要的是新娘），结果竟然出了！！真的是意料之外的一次抽卡。</p><p><img data-src="https://cdn.makiru.top/images/202203312142966.png"></p><p>至于为啥我刚才说那30个石头是为了抽贞德攒的呢，因为之前90个石头抽贞德沉底了，虽然也出货了，只是不是我最想要的贞德啊！！！出了谁呢？也是一个挺不错的角色吧。</p><p><img data-src="https://cdn.makiru.top/images/202203312144214.png"></p><p>没错，就是志度内，还行吧，至少是我没有的他人格～</p><p>新娘尼禄呢，其实是因为我出了一张这个，所以还是想把新娘也抽一次，刚好这次秋叶原活动新娘也返场了。。</p><p><img data-src="https://cdn.makiru.top/images/202203312148144.png"></p><p>最后，给大家看一张我特地存起来的图，很有意思，绝对是超级卡哇伊的一张图（不看就可惜了）</p><p><img data-src="https://cdn.makiru.top/images/202203312151843.png"></p><p>是不是超级可爱呢，（虽然都是男孩子），这么可的男孩子，谁会不喜欢呢？</p><p>哎，不得不说，这游戏是真的肝（打完这个活动，感觉我又得歇息好久了～）</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买股票的那点事</title>
      <link href="/blog/article/7612ee64.html"/>
      <url>/blog/article/7612ee64.html</url>
      
        <content type="html"><![CDATA[<p>今天是封校的第几天了呢？我也不记得了，不过嘛，现在已经可以每日外出买饭了，还是不错的感觉（指屁股不用一直坐在凳子上的感觉～），今天想记录下的是一道蛮有“意思”的题，没错，就是买股票！！！当然，即使做会这道题也不能保证你的股票会卖的多好，哈哈哈！</p><p><img data-src="https://cdn.makiru.top/images/202203242200506.png"></p><span id="more"></span><h2 id="买股票1"><a href="#买股票1" class="headerlink" title="买股票1"></a>买股票1</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个数组prices，其中，prices[i]表示第i天股票的价格，只能选择在某一天买入一支股票，并在未来的某一天卖出这支股票，设计一个算法计算出能获得的最大利润（<font color=red>只能交易一次</font>）</p><p>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><img data-src="https://cdn.makiru.top/images/202203242324365.png" style="zoom:50%;" /><p>首先我们假设目前正在第i天，并且手上没有股票，既然只能买一次卖一次，那肯定是买的时候价格越低，卖的时候价格越高越好；所以我大致画了上面1，2，3三种情况。</p><p>(1) i+1天的价格比i天的价格高，这种时候，我们可以选择i天买入，i+1天卖出，这种情况下一定有的赚，但是是不是赚的最多还不确定。</p><p>(2) i+1天的价格比i天的价格低，这种时候，肯定不选择买入，因为即使后面有比i天高的价格存在，那为什么我们不选择在i+1天以更低的价格买入再在那天卖出呢？</p><p>(3) i+1天与i天价格相同，这种时候，两天买入都可</p><p><font color=red>注意：这里的买入，不是说是最后的结果中的买入，只是测试型的买入，比如用(1)举例说明，我们并不是说最后的结果中就是i天买入，可能后面还有比i天价格更低的存在，这里只是暂时将目前能得到的最大利润存起来以便后面比较更新。</font></p><p>至于下面三个图，就是针对(1)的扩展，11中i+2天的价格比i天高，所以也需要判断下获得利润是否能变多，12中同样，关键是13中，i+2天的价格比i天的价格还低，那么，我们就会暂时性选择去i+2天买入（目前的最大利润——i+1天卖出，i天买入，已经存好）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_price</span> <span class="operator">=</span> Integer.MAX_VALUE;  <span class="comment">//可以看作第i天的价格（买入的价格）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max_index</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//可以看作i+1天及后面的价格指针（卖出的价格指针以及更新买入价格的指针）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">while</span> (max_index &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[max_index] &lt; min_price)&#123;</span><br><span class="line">            min_price = prices[max_index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = Math.max(max, prices[max_index] - min_price);</span><br><span class="line">        &#125;</span><br><span class="line">        max_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买股票2"><a href="#买股票2" class="headerlink" title="买股票2"></a>买股票2</h2><h3 id="题目介绍-1"><a href="#题目介绍-1" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>和买股票1题目大致类似，只是添加了一个条件，可以交易多次，也就是每一天都可以决定买入还是卖出，但是手中最多只能有一支股票（<font color=red>交易次数不限</font>）。</p><p>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>其实大致思路和股票1是类似的，只是现在需要明白，<font color=red>只要i+1天的价格比i天价格高的话，我就选择i天买入i+1天卖出，而不会去看i+2天的价格是什么样子的</font>，因为即使i+2天的价格更高，我依旧可以在i+1天买入i+2天卖出；也就是说我会尽可能快的将手中的股票卖出，当然，买入的时候，还是需要价格越低越好（意思就是: i天的价格高于i+1天的价格，但是低于i+2天，那我会选择去i+1天买入，而不是i天）</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_price</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt;= min_price) &#123;</span><br><span class="line">            sum += (prices[i] - min_price);</span><br><span class="line">        &#125;</span><br><span class="line">        min_price = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买股票3"><a href="#买股票3" class="headerlink" title="买股票3"></a><font color=red>买股票3</font></h2><p>这道题也是这三题中我个人觉得比较难的一道，因为，有点难想～其实呢，在做第一道题的时候，我就已经想到了动态规划这个想法可能能用上，只是因为前两题思路都很直接，就没多想，结果到了这，呵呵，直接懵圈！！！</p><h3 id="题目介绍-2"><a href="#题目介绍-2" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。（<font color = red>最多只能交易2次</font>）</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><h3 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a>官方思路</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>首先，明确这道题的解法是动态规划；其次，动态规划需要有状态转移方程；最后，初始化的条件是什么？我们一样一样来说～</p><p>由于这里有三个不定变量（第几天，交易几次，手上有没有股票），所以我们选择定义一个三维的dp数组；其实呢，前两个变量倒好想，就是最后一个手上有没有股票这个不是很好想，为什么非得有这个呢？因为如果手上有股票那就不能再买入，手上没有股票同样也不能卖出。</p><p>分析到这，相信很多小伙伴会发现，最关键的地方还没有出现，没错，转移方程！</p><p>dp[i][j][k]表示啥意思，上面已经解释过了，这里不作过多解释；其中，j可以选择的值有：0，1，2；k可以选择的值有：0，1.</p><p>因此两者可以有6种组合：</p><ul><li>j &#x3D; 0，k &#x3D; 0，表示到今天结束为止，我没交易过（指没卖出去过），手上没有持股，所以其利润一定是0</li><li>j &#x3D; 0，k &#x3D; 1，表示到今天结束为止，我没交易过，但是手上有一支股票，表明我在今天或者今天之前某一天<font color=red>只买过一支股票</font>，但是没有卖出去，所以其利润有两个选择：今天才买的这支股票（dp[i-1][j][0] - prices[i]）；<font color=red>今天之前</font>就已经买了这支股票，今天没有任何操作而已（dp[i-1][j][1]）。<font color=red>注意：今天之前表示可能是昨天买的，也可能是昨天之前买的，但是不管怎样，利润的积累一定会积累到昨天的dp值上。</font></li><li>j &#x3D; 1， k &#x3D; 0，表示到今天结束为止，我交易过一次，并且手上没有股票，这说明可能到昨天结束的时候我手上还有股票，但是今天我给卖了，还有一种可能就是到昨天结束为止我就已经没有股票在手上了～所以利润也有两选择（dp[i-1][j-1][1] + prices[i]和dp[i-1][j][0]）。</li><li>j &#x3D; 1，k &#x3D; 1，这表示到今天结束为止，我交易过一次，并且手上还有一支股票（肯定是第二次买入的，只是买入时间不定），则利润同样有两种可能（dp[i-1][j][1]和dp[i-1][j][0] - prices[i]）。</li><li>j &#x3D; 2，k &#x3D; 0，表示到今天结束为止，我交易两次了（到达上限），并且手上没有持股，则有可能我昨天结束时还有股票在手上，只是今天给卖了，同样也有可能昨天结束的时候我手上就没有股票了，所以也有两种可能（dp[i-1][j-1][1] + prices[i]和dp[i-1][j][0]）</li><li>j &#x3D; 2，k &#x3D; 1，表示我交易过两次，并且手上还有一支股票（因为这里定义的是卖出为一次交易，所以还是合法的，但是如果事先定义的是买入为一次交易，则这里就是不合法的）手上的这支股票可能是今天购入，也可能是昨天或之前就已经购入，所以利润有两种可能（dp[i-1][j][0] - prices[i]和dp[i-1][j][1]）</li></ul><p><strong>整体上看来，其实就分为两种情况</strong></p><ul><li>k &#x3D; 1时： dp[i][j][k] &#x3D; max(dp[i-1][j][0] - prices[i]，dp[i-1][j][1])</li><li>k &#x3D; 0时（因为可能会用到j-1，所以需要分开考虑）：<ul><li>j &#x3D; 0时，则肯定赚不到钱，利润为0；</li><li>j !&#x3D; 0时，dp[i][j][0] &#x3D; max(dp[i-1][j][0]，dp[i-1][j-1][1] + prices[i])</li></ul></li></ul><p>既然，转移方程都写出来了，剩下的就是初始化的问题了，也就是i &#x3D; 0的情况下，这6种组合的值分别为多少：</p><ul><li>j &#x3D; 0，k &#x3D; 0，啥都没干自然是没钱</li><li>j &#x3D; 0，k &#x3D; 1，没卖出去过反而还买了一次，自然是亏本（-prices[0]）</li><li>j &#x3D; 1，k &#x3D; 0，卖出去过一次，手上没有股票，注意，这是第0天，那肯定是买了第0天的股票立马又卖出去了，所以呢，不亏不赚</li><li>j &#x3D; 1，k &#x3D; 1，卖出去过一次，手上还有一支股票（可以理解为第0天的），那就可以理解为买了第0天的股票，又立马卖出去了，然后又立马买回来了（第0天的），所以总体上还是亏本（-prices[0]）</li><li>j &#x3D; 2，k &#x3D; 0，卖出去过2次，手上没股票，按照上面的思路，自然是没赚钱没亏钱</li><li>j &#x3D; 2，k &#x3D; 1，卖出去过2次，手上还有一支股票（第0天的），亏钱（-prices[0]）</li></ul><p>初始情况也分析好了，那代码也就好写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="comment">//手上有股</span></span><br><span class="line">            dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>] - prices[i], dp[i-<span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//手上没有股</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i-<span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(dp[len-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[len-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]), dp[len-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明下最后的返回值，因为当最后一天手上还有股票的话，那一定是用之前赚的钱中的一部分去买的（可以这么理解，一开始本金为0，买入就是负的，卖出就是正的，累加起来就是最后的利润，利润是负就是亏钱，利润是正就是赚钱），所以最后一天手上有股票一定是比没股票赚的少，因此我们只需要从最后一天手上没股票的几种情况中找出最大值即可。</p><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>可以发现，思路1中的空间复杂度有点高（n^3），并且呢，上面说的6种组合，其实也可以理解成每天结束时的一个状态，当然肯定是需要重新分组的啦！</p><p>状态有以下5种：</p><ol><li>到目前为止啥也没做</li><li>到目前为止买过一次，但没卖出去过</li><li>到目前为止买过一次，卖过一次（表示目前手上肯定没股票）</li><li>到目前为止买过两次，卖出去过一次（表示手上目前肯定有股票）</li><li>到目前为止买过两次，卖出去两次（手上没有股票）</li></ol><p>所以呢，完全可以直接设置dp[i][j]的二维数组，进而优化空间，至于状态转移方程呢，和上面一样分析即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">    <span class="comment">//每天结束后只会有5个状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h4><p>思路2呢，空间复杂度总觉得还是有点高（n^2），我们发现啊，其实也就4个变量一直在变动，那为什么不直接设置4个变量做呢？</p><p>4个变量如下：</p><ol><li>buy1: 表示到目前为止买过一次，没卖过</li><li>sell1: 表示到目前为止买过一次，卖过一次</li><li>buy2: 表示到目前为止买过两次，卖过一次</li><li>sell2: 表示到目前为止买过两次，卖过两次</li></ol><p>这样就完美覆盖了上面的后四个状态，至于为啥第一个状态不用呢，因为啥也不操作自然利润也不会变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">    <span class="comment">//使用变量</span></span><br><span class="line">    <span class="comment">//将买入的价格记为正</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sell1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sell2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        buy1 = Math.min(buy1, prices[i]);</span><br><span class="line">        sell1 = Math.max(sell1, prices[i] - buy1);</span><br><span class="line">        buy2 = Math.min(buy2, prices[i] - sell1);</span><br><span class="line">        sell2 = Math.max(sell2, prices[i] - buy2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我上面的代码中，buy1和buy2表示的是买入价格（比如buy2，prices[i] - sell1是指买了i天的股票，用的钱呢在sell1中扣，sell1自然是卖过一次后手中的钱），所以需要注意是用max还是min，其实很好理解，买入自然越低价格越好，卖出自然价格越高越好。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里就结束了，虽然听说好像还有个买股票4，但是我还没做到那，等做到了再说吧，今天（2022-03-25）没错，昨晚太晚了，就没写完，上午又去做了次核酸，还不知道啥时候才可以完全解封～</p><p>番剧的话，还在追，劳烦各位lsp等等啦！^V^</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称二叉树的判断及二叉树的迭代遍历</title>
      <link href="/blog/article/20ff5111.html"/>
      <url>/blog/article/20ff5111.html</url>
      
        <content type="html"><![CDATA[<p>最近的我，感觉出了点问题（或许说我原本就是这么的菜。。）。为什么这么说呢？起因是这样的，今天呢，我终于开始刷leetcode的第101题了，不是有句话说得好嘛，万事开头难，对我而言，好像leetcode上的都是开头，怎么说呢，第101题标注的是一道简单题，题目的内容也就是这篇文章的标题——对称二叉树的判断。本来呢，这在人眼看来，也就是一件小case。只需要判断是不是对称的而已，不是很简单嘛，而且也标注的是简单题～可是呢，到我这，呵呵，硬是没想到正确的方向，一直在自己的“死胡同”里打转，待会就介绍下我的死胡同之旅（虽然也不算是死胡同）。</p><p>一碰到二叉树和图，我就有点小害怕，为啥呢，因为可以有很多变化～所以今天我就把二叉树的几种遍历（特指迭代）好好整理下。</p><p><img data-src="https://cdn.makiru.top/images/202203172116879.png"></p><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树的根节点 root ， 检查它是否轴对称。</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.makiru.top/images/202203172119497.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>我的思路很直接，相信一说，大家就懂了，但是呢，先说下，我的思路是错的。</p><p>我一开始想的是，既然和对称有关，那第一想到的就是回文数串，回文数串就是一个对称的经典实例。也正是这个想法，彻底地把我带进了深坑～</p><p>因此，我就想，既然都是对称，那对二叉树的某种遍历得到的序列是不是也是一个回文数串呢？而遍历的算法，先序与后序很明显是不符合要求的（对称），于是我兴高采烈地拿了几棵对称的二叉树用中序遍历进行实验，额，偏偏还都是回文数串，嗯，没错，，我信了，我竟然就这么相信：<strong>只要中序遍历得到的是一个回文数串，那一定是对称二叉树</strong>（错的❌）待会我会举出反例（其实是leetcode给出的。。）</p><p>思路既然都有了，我就开始写咯，于是，下面的这个代码就是最后的结果（期间，因为对null节点处理不当，导致错的原因很明显）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Inorder(root);</span><br><span class="line">    <span class="keyword">return</span> isPalindrome();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        path.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> || root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        Inorder(root.left);</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        Inorder(root.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判读回文</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> path.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.get(i) == path.get(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是咋样的呢？</p><p><img data-src="https://cdn.makiru.top/images/202203172130401.png" alt="image-20220317213037725"></p><p>当时的我，都惊了，为啥会有一个过不去呢？于是我去把这个给的用例的二叉树画了个图看了下，就一切都明了了。。</p><img data-src="https://cdn.makiru.top/images/202203172133025.png" alt="" style="zoom:50%;" /><p>我相信只要是个正常人，一眼就能看出，这不是一个对称的二叉树。。可是为什么代码会将其认定为是对称的呢，我按照代码的思路，对它进行了一次中序遍历，结果发现，竟然是一个回文的数串。</p><p>经过了很长的思考，我想明白了，原来我一开始依靠的那个想法是不对的：</p><blockquote><p>中序遍历得到的序列如果是对称的话，二叉树也是对称的（❌）</p><p>二叉树是对称的话，其中序遍历得到的序列一定是对称的（✅）</p></blockquote><p>就这样，我被这道简单题弄的蛮难受的～</p><h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><p>相信很多人都明白镜像的道理，将一棵二叉树和其在镜中的二叉树相比较会发现，镜中的某个节点的左子树与镜外的对应节点的右子树是对称的，同样的，镜里的节点的右子树与镜外的对应节点的左子树是对称的，因此，如果使用递归来写，其实，只需要知道这个思路，还是很好写的，这也是为什么这道题会被标注为简单题的原因吧～</p><p>思路如下：</p><p>对于两棵树而言，镜像对称需要满足：</p><ul><li>根节点的值相等</li><li>每棵树的左子树都与另一棵树的右子树互为镜像对称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; check(left.left, right.right) &amp;&amp; check(left.right, right.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解法呢，是递归的写法，那如果是迭代呢，众所周知，如果想把递归改成迭代，栈或者具有栈功能的其他数据结构是不可缺少的，当然，有时候会因为某些原因（比如访问顺序），而用队列来代替栈的使用，因此这道题也是如此。</p><p>思路上其实是没什么区别的，我们需要一个队列来存储节点。首先我们将树的根节点入队两次，然后再依次出队两个节点x，y（开始时自然是根节点），判断节点的值是否相等。</p><ul><li>相等：<font color=red>分别将x的左节点（其实是左子树），y的右节点，x的右节点，y的左节点依次入队</font></li><li>不等：直接返回false</li></ul><p>注意：红色部分的入队顺序是有讲究的，我们需要保证出队时连续两个节点在原二叉树中是对称的位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode root1, TreeNode root2)</span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root1);</span><br><span class="line">    queue.offer(root2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        root1 = queue.poll();</span><br><span class="line">        root2 = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span> || root1.val != root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.offer(root1.left);</span><br><span class="line">        queue.offer(root2.right);</span><br><span class="line">        queue.offer(root1.right);</span><br><span class="line">        queue.offer(root2.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：由于LinkedList实现了Queue的某些方法，因此可以直接使用LinkedList；其次，使用queue的offer与poll方法可以避免某些异常的抛出。</p><h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><p>二叉树的遍历方式有很多种，今天我为以后的自己整理四种出来：先序，中序，后序，层次。</p><p>其中，如果要我说的话，先序与后序相比较而言，简单点～</p><p>一般来说，不是后序很难嘛，为啥这里会说简单呢，因为如果是严格地按照后序来推，确实蛮难，但是，后序与先序之间的遍历是有关系的，至于是什么关系，待会再说～</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>处理顺序：中    左    右</p><p>遍历方法：将根节点入栈；出栈；访问，并将出栈的节点的右节点，左节点（因为要先访问左子树再访问右子树，加上栈的性质）依次入栈；以此类推下去即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.addFirst(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.removeFirst();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>处理顺序：左     右     中</p><p>遍历方法：可以发现，处理顺序与先序的顺序是有关系的，只需要将先序的左右颠倒再整体颠倒就是后序的顺序。</p><p>中  左  右  &#x3D;&gt;  中   右   左  &#x3D;&gt;  左   右   中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.addFirst(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.removeFirst();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.left);   <span class="comment">//颠倒入栈顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>处理顺序：左    中    右</p><p>遍历方法：因为中序遍历最先处理的节点是左子树上的最左节点，而不是根节点，因此，我们必须首先找到这个节点，利用栈将途径的节点存储下来，便于待会的回溯；找到后，访问该节点，再访问该节点的右子树（或许有人会问，为啥不访问该节点的左子树，呵呵，因为，这个节点已经是最左节点，不会存在左子树），如果没有右子树，那么就会出栈一个元素（也就是刚才那个元素的父亲节点，至于为什么会访问这个父亲节点呢，因为它的左子树已经访问完全啦），继续访问，再访问其右子树，以此类推下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//找到最左子节点</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.removeFirst();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>处理顺序：按层来进行处理</p><p>遍历方法：一开始我以为层次遍历是最麻烦的，我甚至在方法的参数中加上了层数的信息，最后发现，呵呵呵，好像不是很难。层次遍历，字面意思，遍历完一层再去遍历下一层。因此，将根节点入队后（这里我用的是队列，其实是Deque的队列属性），再出队一个元素，访问（第一层），再将该节点的左节点，右节点依次入队；出队一个元素，访问（第二层），再将该节点的左右节点依次入队；再出队一个元素，访问（第二层最后一个元素，结束）。以此类推。</p><p>其实呢，仔细观察会发现，每次访问完一层后，下一层的所有元素都会被入队（<font color=red>注意，队列是先进先出</font>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">LevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.addFirst(root);   <span class="comment">//主要是用来记录每一层从左到右的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.removeLast();   <span class="comment">//注意，这里使用的是removeLast而不是removeFirst</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//将该节点的左节点与右节点放入</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.addFirst(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我在做这道题的时候，想把二叉树的几种迭代遍历方法都写一遍，加深印象（毕竟一般情况下，都是直接用的递归），为以后的自己留点笔记吧～</p><p>番剧啥的，等等吧，最近已经被这疫情堵在寝室里，搞得人有点堵得慌～白白啦！</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>morris遍历算法</title>
      <link href="/blog/article/bee80928.html"/>
      <url>/blog/article/bee80928.html</url>
      
        <content type="html"><![CDATA[<p>博主又开始水文章了，至于为啥我这么积极的写呢？因为在封校期间，博主是很懒的，啥也不想干～昨晚终于将leetcode刷到了第99题！别问我为啥不直接刷到100题，为啥喽？因为我想纪念下刷题数量过百这个大事情～（虽然对各位大佬来说，这都是小case啦，洒洒水啦～）</p><p>今天想讲下我在第99题中看到的一种新的算法思路，之前在这类题上还没想过可以这么做。。</p><p><img data-src="https://cdn.makiru.top/images/202203141615605.jpg"></p><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你二叉搜索树的根节点root，该树中的恰好两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.makiru.top/images/202203151441173.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><h4 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h4><p>其实，这道题，在思路上还是很直接的，因为，我们应该都知道，对于二叉搜索树来说，如果对其进行中序遍历，得到的应该是一个升序的序列，所以，只需要我们对破坏过的BST进行中序遍历，就会发现得到的序列中存在不正确的地方。</p><p>但是，需要注意，我们假设不正确的地方被记为x与y（有前后顺序），那么原本的大小关系应该是x &lt; y， 但是得到的序列中为x &gt;&#x3D; y，这样的地方在序列中可能存在一个或者两个（原因很简单，[1，2，3，4]，如果只是调换相邻的两个数，就是一个，如果调换的不是相邻的就是两个）。</p><p>了解这些后，其实大体上，这道题就可以开始做了，我们最初的想法就是把这样的x与y都找到，在将第一个出现的x与最后一个y调换就可以了。至于怎么找到，其实方法也很简单，直接对BST进行中序遍历，并记录当前节点的pre node，访问当前节点的时候，将其与pre node的值比较，如果不正确，就直接记录下当前节点的pre node（x），并且把当前节点记为y，这样的话，x就不用再改变，只需要根据不正确的数量来判断是否需要修改y（<font color=red>其实，也就是在后续的遍历中，如果再次遇到不正确的情况时，只需要更新y，也就是记录最后一个不正确的node</font>）。</p><p>这种方法，在时间复杂度上是O(N)，N为节点数量，空间复杂度为O(h)，h为BST的树高（因为中序遍历无论是递归还是迭代都是需要栈空间的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TreeNode x, y, pre;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  Inorder(root);</span><br><span class="line">  <span class="comment">//更换</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> y.val;</span><br><span class="line">  y.val = x.val;</span><br><span class="line">  x.val = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Inorder(root.left);</span><br><span class="line">  <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">    y = root;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">null</span>)&#123;</span><br><span class="line">      x = pre;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  pre = root;</span><br><span class="line">  Inorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这道题还有一个另外的限制，就是需要将空间复杂度降低为O(1)，常量空间。因此这里就需要引出一个比较厉害的遍历算法，众所周知，对于二叉树的遍历，一般情况下都是需要利用到栈的空间，这也就造成遍历二叉树“不可避免”的空间需求～</p><p>但是，存在这么一种方法，它在遍历二叉树的时候，只需要常量级别的空间即可。没错，这就是morris遍历算法，接下来我将使用这种方法介绍如何解决这道题目。</p><h4 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h4><p>morris算法的关键在于，如何更好的去利用节点的空指针（<font color=red>左右孩子如果为空，则有空闲的指针可以使用</font>），对于遍历二叉树，大家需要有一个观念上的正确，首先，遍历时我们需要使用到每个节点的指针，进而可以找到其孩子节点，这是关键，但是遍历的时候总是存在一个问题，那就是一旦遍历到叶子节点，就会发生回溯的过程，也正是这个过程造成我们需要使用栈的原因。</p><p>因此我们可以想，既然一到叶子节点就会回溯，那我们只需要让叶子节点消失不就好了？当然，这里不只是叶子节点，对于中序遍历而言，当我们遍历完左子树后，尤其是左子树的最右节点，我们就需要访问根节点，因此对于所有的有左子树的根节点而言，如果能<font color=red>将访问根节点前一个节点的右指针（一定是空的，不然会继续去遍历该节点的右子树）指向根节点</font>，那么，当左子树访问完全后，便可以直接通过这个新增的指针访问根节点，而<font color=red>不必进行回溯操作</font>。</p><p>从上面的一些简单分析来看，相信大家已经能猜到morris算法的一个大概思路是啥。</p><p><strong>morris遍历的实现原则：</strong></p><blockquote><p>记当前节点为cur：</p><ol><li>如果cur无左孩子，cur向右移动（cur &#x3D; cur.right）</li><li>如果cur有左孩子，找到cur左子树上最右的节点，记为MostRight<ol><li>如果MostRight的right指针指向空，让其指向cur，cur向左移动（cur &#x3D; cur.left）</li><li>如果MostRight的right指针指向cur，让其指向空，cur向右移动（cur &#x3D; cur.right）</li></ol></li></ol></blockquote><p><strong>举例说明：</strong></p><p><img data-src="https://cdn.makiru.top/images/202203151822163.jpeg"></p><p>上面这张图呢，是我根据遍历原则对图中二叉树中根节点左子树遍历的一个过程，大家可以好好了解下，当然，对于这道题来说，我们需要解决的是找到有问题的两个节点，其实，寻找方法和第一种常规思路是类似的，还是需要在遍历的过程中对当前节点与pre node进行比较判断。</p><p><strong>算法分析：</strong></p><p>由于需要找到当前节点的左子树中的最右节点，因此对于二叉树中的每一个节点，我们都需要访问两次，因此时间复杂度为O(2N)，空间复杂度为O(1)。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, x = <span class="literal">null</span>, y = <span class="literal">null</span>, temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = root.left;</span><br><span class="line">            <span class="comment">//temp.right != root 是用来判断root的左孩子是否遍历完全</span></span><br><span class="line">            <span class="keyword">while</span> (temp.right != <span class="literal">null</span> &amp;&amp; temp.right != root)&#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                temp.right = root;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//表示root的左子树已经访问完全</span></span><br><span class="line">                <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">                    x = root;</span><br><span class="line">                    <span class="keyword">if</span>(y == <span class="literal">null</span>)&#123;</span><br><span class="line">                        y = pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//断圈</span></span><br><span class="line">                temp.right = <span class="literal">null</span>;</span><br><span class="line">                pre = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//直接访问右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">                x = root;</span><br><span class="line">                <span class="keyword">if</span>(y == <span class="literal">null</span>)&#123;</span><br><span class="line">                    y = pre;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x,y节点值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> x.val;</span><br><span class="line">    x.val = y.val;</span><br><span class="line">    y.val = temp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我这次想要记录的全部啦，虽然算不上什么特别好的叙述，但是呢，足够以后的我能回忆起这个遍历算法。最近在我们学校的社区里竟然还看到了区间极值之类的算法，虽然我也看不懂，但是听起来就很牛逼～</p><p>白白啦，下次动漫走起（虽然这几天也没看啥番～）^v^</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平凡世界造就世界最强</title>
      <link href="/blog/article/73ab8285.html"/>
      <url>/blog/article/73ab8285.html</url>
      
        <content type="html"><![CDATA[<p>今天把这部之前在油管上看到的番剧总算是看完了，整体上看来还是很不错的，弄的我都想去看看原小说了（哈哈哈），主要呢，剧情上还可以，不会有啥突兀的感觉。故事背景嘛，自然是很热门的异世界穿越啦，而且是很不一样的穿越～各位有兴趣的小伙伴可以简单的看看介绍然后直接去看番剧哟～</p><p><img data-src="https://cdn.makiru.top/images/202203122330458.jpg"></p><span id="more"></span><p>是不是很可爱啊？没错，我就不装了，这是我女儿！！！</p><p>哎，不扯了，我就简单点介绍下大概剧情吧，因为我这个人看完就不咋记得具体的细节了，只知道很有意思就对了。故事开篇，男主南云始和他所在的班级包括老师都被异世界的人给召唤过去了，每个人都有自己的专属职业，像男主就是一个练成师。这个异世界呢，是一个有神存在的世界，只是这个神并不关心世界上的生命，只是将其当成玩乐的棋子，从前有一部分人发现这个真相后，奋起反抗，结果大多数都被不知情的普通人给杀害，只剩一小部分躲进了一些隐秘的地方，也就是本番中很重要的大迷宫。男主后面主要的事就是不断的攻略各个大迷宫，顺带收收后宫，而且还是那种“别看哥，对哥特别的人只有一个”的那种（哈哈哈，超级“专情”哟）。</p><p>在一次探索迷宫时，因为一个红毛手贱，误触了一个机关，结果全员被传送到了极深的迷宫底层，在这里，大伙遇到了一个实力强横的怪物，大家拼命抵抗，但终究不是对手，于是选择撤退，结果南云始为了掩护一个同学，撤退的慢了点，本来其实嘛，是可以安全离开的，结果，在全班同学的支援下，竟然有一发攻击直接怼着始过去，毫不意外的，始被打进了深渊底层（没错，就是红毛干的～）</p><p>等男主醒来后，发现这里全是超级厉害的怪物，在拼死生存下，还是丢了一只手臂。在极强的求生意识下，男主不断地往迷宫深处进发，进发途中，男主遇到了自己的第一个伙伴（也是男主承认的恋人）月</p><p><img data-src="https://cdn.makiru.top/images/202203122346305.jpg"></p><p>月是一个旧时代的王族的公主，好像是吸血鬼族。</p><p>两人之间在迷宫中相互帮助，感情也是越发的浓厚，于是乎，就自然成了恋人啦</p><p><img data-src="https://cdn.makiru.top/images/202203122349925.jpg"></p><p>在两人的合力下，这第一座迷宫被攻略，男主也获得了神代魔法（解释下，也就是之前说的那一小部分活下来的人所传承的魔法）。两人前往第二座大迷宫，在前往的路上，两人在一只遗憾兔子的央求下，救了她的部落。</p><p><img data-src="https://cdn.makiru.top/images/202203122351314.jpg"></p><p>就这样，男主的小队中，又多了一个伙伴，自然，这只兔子，也是很喜欢男主的啦，男主还会趁兔子睡着后撸兔耳朵～</p><p>后面男主等人在完成工会请求的任务时，遇到了第三个伙伴——一只黑龙，也就是所谓的龙人族，不得不说，这只黑龙是真的变态，纯粹的抖S。番中这只黑龙被男主用一根超级粗的大铁棒直插后庭～一个不小心开发了黑龙的抖S属性（后面竟然还练就了受到的伤害越高，各方面属性也升的越高。。。）</p><p><img data-src="https://cdn.makiru.top/images/202203122356157.jpg"></p><p>就这样，男主小队的人也差不多齐了，哦，对了，忘说了，还有我女儿，她叫妙，被人贩子给拐走了，被男主一队给救了，哎。我女儿是真的可爱！</p><p>后面呢，男主的同班同学中，有一位也是很喜欢男主的，因为自己承诺过要保护男主，却并未履行诺言，心中一直愧疚，这次，得知男主未死，就也和男主小队一起前往下一个大迷宫继续攻略啦。</p><p>整体故事就是差不多这样啦，很多细节我也没讲，比如我女儿后面被送回家的情节，男主救爱子老师的经典场景啦，至于为啥经典，去看看就知道了（他是个禽兽～）</p><p>其实第二季也已经在开播了，我也正在看，情节嘛，和第一季类似，男主依旧是在攻略大迷宫获得神代魔法的途中，男主自己也在不经意间继承了以往那些叛逆者的责任——弑神，也在不断的成长中，其实男主的变化还是很大的很大的，一开始的男主是唯唯诺诺的；掉进深渊后，男主是冷漠的，更像是一只魔兽；和伙伴在一起后，男主变得更像是一个人了。</p><p>就这样啦，有兴趣的小伙伴可自行去观看哟，很不错的番，适合边吃饭边看（我就是边吃饭边看的，因为这段时间封校，宿舍不让出，只能在寝室靠这些度过吃饭的时间）～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泡面番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被封校的那些事儿</title>
      <link href="/blog/article/828b16f2.html"/>
      <url>/blog/article/828b16f2.html</url>
      
        <content type="html"><![CDATA[<p>不得不说，被关在宿舍里的生活是真的好难受，虽然吃的会给你送上门，但是这，，一直在寝室坐着是真的枯燥（别说学习，，博主讨厌学习～</p><p>今天是学校封校的第三天还是第四天来着，我已经不太记得了，因为被关在寝室已经快关傻了，哈哈哈哈&gt;&lt;</p><p><img data-src="https://cdn.makiru.top/images/202203111441899.png"></p><span id="more"></span><p>你还别说，呆在寝室里的感觉和呆在图书馆的感觉真的很不一样，毕竟，我吃午饭和吃晚饭的时候可以看番了啊！只是总觉得自己目前的状态有点不太好，为啥说不太好呢？因为没法安心的去看书，也不知道为啥，明明只要拿出书看就行了，很奇怪～</p><p>最致命的一点就是我已经好多天没洗澡了，没错，你没听错，是没洗澡，也幸亏这几天寝室不算太热，运动也不多，身上也没怎么流汗，就是有点小小的痒～今晚无论如何都得洗一下了（说是洗，也只是擦擦罢了），也不清楚这封锁什么时候能结束，是真的要把人逼疯了。或许有人会说，一直呆在寝室，吃的有人送上门，有什么不好呢？这么说的人，那是因为你没体验过真正的”封闭式”教育。当然啦，学习还是不能少的，我们依旧还是正常的网上授课，只是这效率啥的我就不多说了，大家心里知道就行。</p><p>刚刚看了下微博，呵呵，原来今天我们国家的网络又被攻击了，这个年代真的是什么事都有，说实在的，就算哪天外星人站在我的面前或许我都不会感到吃惊了，和平难道不好吗，，（或许是我想的太简单了吧，毕竟人的心是最复杂的，人是最复杂的动物，没有之一）</p><p>扯远了，吃的方面呢，还勉勉强强吧，早餐挺早的，只是我们起不来而已，所以一直都是吃的凉的（博主是个懒虫～）至于有什么呢，额，一个鸡蛋，一杯豆浆，一个包子，一个馒头，一个奶黄包？好像是叫这个。。还行吧，至少我平时早餐吃不了这么多。午餐和晚餐呢？也还行吧，不算难吃不算好吃，够我填饱肚子了。</p><img data-src="https://cdn.makiru.top/images/202203111457775.jpg" style="zoom: 67%;" /><p>就是饭有点少了（哈哈哈，博主有时候是个饭桶）</p><p>哎，也不知道什么时候才能解封，一直坐在寝室是真的很累，但愿疫情早日过去吧～</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kd树与KNN方面的小小认识</title>
      <link href="/blog/article/7fab9ad3.html"/>
      <url>/blog/article/7fab9ad3.html</url>
      
        <content type="html"><![CDATA[<p>今天呢，有点小特殊，为什么这么说呢，因为这是我第一次在寝室里写这种博文。或许有人会问，为什么这就算特殊呢？哈哈哈，因为博主是一个好动的人，几乎不咋呆寝室，这次是因为紧急情况（宿舍楼被封了，，疫情真讨厌～）</p><p>这次想说的是我正在读的一本书（统计学习方法）中的一个小点—kd树在knn中的应用。其实呢，这在机器学习这个领域内算是入门级别的知识，我就单纯记点我的想法（望大佬勿喷）</p><p><img data-src="https://cdn.makiru.top/images/202203091547231.jpg"></p><span id="more"></span><h3 id="kd树的介绍"><a href="#kd树的介绍" class="headerlink" title="kd树的介绍"></a>kd树的介绍</h3><p>首先，kd树可以理解成是一种二叉树，只不过这种二叉树比较特殊而已，至于特殊在哪，还请往下看～</p><p>给出一组数据，可以更好地解释kd树的构成，数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=&#123;(2,3),(5,4),(9,6),(4,7),(8,1),(7,2)&#125;</span><br></pre></td></tr></table></figure><p>这是一个二维的数据，现在我将使用这些数据演示下kd树的构建过程，这样的话，我觉得可能会更容易理解，在往下看之前，我就先默认大家都清楚平衡二叉树的概念啦</p><p>构建kd树一定要注意维度的概念，就拿T数据举例来说，这个数据中包含了dim &#x3D; 0与dim &#x3D; 1（因为是二维的嘛）</p><p>构建过程：</p><ul><li>dim &#x3D; 0: 将T中的数据按照第0维的数字先排个序，排完序之后为：T &#x3D; {(2,3),(4,7),(5,4),(7,2),(8,1),(9,6)}，接下来呢，取中位数（7，2）作为kd树的根节点，注意：<font color=red>这里是向下取整</font>，中位数左边的呢，作为根节点的左子树节点，右边的自然就是右子树啦</li><li>先看左子树，T_left &#x3D; {(2,3),(4,7),(5,4)}，按照同样的原理，只不过这次看的不是第0维，而是<font color=red>第1维</font>，将T_left按照第1维数字的大小进行排序，即T_left &#x3D; {(2,3),(5,4),(4,7)}，取中位数（4，7）作为左子树的根节点，其左右分别作为该节点的左右子树</li><li>继续看左子树，T_left’ &#x3D; {(2,3)}，这时看的维度又需要变回第0维，相信聪明的小伙伴，已经看出，维度的变化在于树的深度与给定数据的维度之间的某种关系：深度 % 维度</li><li>右子树的构建也是如此，只是需要注意，<font color=red>树每一层看的维度都是一样的</font></li></ul><img data-src="https://cdn.makiru.top/images/202203091626878.png" alt="" style="zoom:50%;" /><p>也许细心的同学已经发现，在建树的过程中，维度依据的变化是不是并不太合理呢？确实是这样的，因为如果只是按照顺序来选择特征维度（可以把每个维度理解成一种特征类型或者特征标签），是不是并不能保证划分数据或者实例点很简单呢？因此，后面有人想出了一个方法，既然想要更容易区分，那这不正好符合方差的定义嘛，没错，在每一次选择节点的时候，依据维度的选择不再是简单的按照顺序来判断，而是先判断下<font color=red>当前数据集中哪一个维度的数字方差更大，越大表示越容易区分</font>.</p><h3 id="KNN算法的简单介绍"><a href="#KNN算法的简单介绍" class="headerlink" title="KNN算法的简单介绍"></a>KNN算法的简单介绍</h3><p>KNN算法，全称为k近邻算法，它主要是用来做分类预测的，所依据的无非是多数决策的手段，简单点来说，就是指判断一个数据点的时候，先找到它的k个最近的邻居，看看这k个邻居中哪种类别占多数，那这个数据点就会被划分到那一类。</p><p>既然要找k个最近的邻居，就要牵扯到距离的定义，一般情况下，我们常用的就是欧式距离等等，具体有哪些距离，可以看看下面<br>$$<br>L_p(x_i,x_j) &#x3D; (\sum_{l&#x3D;1}^n |x_i^{(l)} - x_j^{(l)}|^p)^{\frac{1}{p}}<br>$$<br>（1）p &#x3D; 2时，该距离便是欧式距离</p><p>（2）p &#x3D; 1时，该距离为曼哈顿距离</p><p>（3）p &#x3D; 无穷时，该距离为切比雪夫距离<br>$$<br>L_p(x_i,x_j) &#x3D; max_i(|x_i - x_j|)<br>$$<br>怎么说呢，老实说，KNN算法在理解上是很简单的，只是它需要快速地找到与target最近的邻居，因此如果只是单纯地去寻找是不可接受的（复杂度过高），这时就需要使用kd树出场啦，怎么使用呢，我们依旧以上面的那棵kd树来举例说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target = (2, 4.5)</span><br><span class="line"></span><br><span class="line">kd tree: 上图</span><br></pre></td></tr></table></figure><p>第一步，和平衡二叉树是很类似的去查找，只不过这里需要将维度也考虑进去，比如说，从树的根节点开始，由于这一层的维度是0，所以将target[0]与根节点的第0维数据比较，大于则去右子树查找，反之，左子树查找</p><p>第二步，找到叶节点(4, 7)，此时将该节点看成是最近点，计算其与目标值的距离，依次回溯之前的查找路径，也就是(5, 4)，判断其与target的距离是否小于最短距离，如果是，则将该点重新看成最近点，再检查该节点（叶节点的父节点）的另外一个子节点，如果该节点在以target为圆心，最短距离为半径的圆内，那么表示该子节点离target更近，因此需要递归地去查找这个子树（和之前一样，直到找到叶节点），如果不在，就直接去判断父节点的父节点（依次回溯），<font color=red>注意：无论父节点是否比当前最近点离target近，都需要去判断父节点的另一子节点是否在圆内</font></p><p>第三步，直到回溯到根节点，当前的最近点就是target的最近邻</p><p>比较关键的地方在于，需要判断当前节点的父节点的另一子节点是否需要去search，这里涉及到递归的含义。当然，这里只是找到一个最近邻而已，我们需要找到k个近邻，因此至少需要查找k次，每一次的复杂度在log(n)，k次就是klog(n)，n为节点的个数</p><h3 id="构建kd树的实现"><a href="#构建kd树的实现" class="headerlink" title="构建kd树的实现"></a>构建kd树的实现</h3><p>先上代码吧，有点小傻，别笑，我写完后，看了下网上的思路，都要么是利用了方差，要么就是想的比我简洁点，待会说下简洁的地方在哪</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 节点类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=-<span class="number">1</span>, dim=<span class="number">0</span>, lchild=<span class="literal">None</span>, rchild=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.lchild = lchild</span><br><span class="line">        self.rchild = rchild</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tree</span>(<span class="params">self, nodes, i, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nodes[<span class="number">0</span>]):</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    nodes_temp = <span class="built_in">sorted</span>(nodes[left:right], key=<span class="keyword">lambda</span> x: x[i])</span><br><span class="line">    nodes[left:right] = nodes_temp</span><br><span class="line">    index = <span class="built_in">int</span>((right + left) / <span class="number">2</span>)</span><br><span class="line">    root = Node(nodes[index], i)</span><br><span class="line">    root.lchild = self.create_tree(nodes, i + <span class="number">1</span>, left, index)</span><br><span class="line">    root.rchild = self.create_tree(nodes, i + <span class="number">1</span>, index + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>其实呢，这也可以看成是一个简单的构建二叉树的过程，只不过是需要加上数据的选择罢了，以往的构建二叉树，只需要将给定的数据按照二叉树的结构放进去就可以，现在需要考虑到数据之间的“大小关系”，可以看到，代码中的参数包括了left与right，这就是为了判断当前需要判断数据的列表是从哪里到哪里使用的，以及为了计算中位数的下标使用的（后面的是主要），结果看了网上的代码，我彻底呆了～</p><p>为啥呢，因为python中如果只想用某个数组的一部分，可以直接这样：nodes[:medium_index]之类的，至于求中位数嘛，我傻了，可以直接用len(nodes) &#x2F; 2来获取，哈哈哈哈～</p><h3 id="KNN最近邻算法实现"><a href="#KNN最近邻算法实现" class="headerlink" title="KNN最近邻算法实现"></a>KNN最近邻算法实现</h3><p>老样子，先上代码，不一定对，感觉像是对的（虽然没啥信心）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dis</span>(<span class="params">self, a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 采用欧式距离</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        dis += (a[i] - b[i]) * (a[i] - b[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(dis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近邻</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, target, root, path</span>):</span><br><span class="line">    <span class="keyword">global</span> visited</span><br><span class="line">    <span class="keyword">global</span> nearest_point</span><br><span class="line">    <span class="keyword">global</span> min_dis</span><br><span class="line">    <span class="comment"># 顺序查找直到叶节点</span></span><br><span class="line">    <span class="keyword">while</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path.append(root)</span><br><span class="line">        <span class="keyword">if</span> target[root.dim] &lt; root.val[root.dim]:</span><br><span class="line">            root = root.lchild</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.rchild</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(path) != <span class="number">0</span>:</span><br><span class="line">        point = path.pop()</span><br><span class="line">        dis = self.get_dis(point.val, target)</span><br><span class="line">        visited.append(point)</span><br><span class="line">        <span class="keyword">if</span> dis &lt; min_dis:</span><br><span class="line">            nearest_point = point</span><br><span class="line">            min_dis = dis</span><br><span class="line">        <span class="comment"># 回退到根节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> point.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.get_dis(target, point.lchild.val) &lt; min_dis <span class="keyword">and</span> point.lchild <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            self.search(target, point.lchild, path)</span><br><span class="line">        <span class="keyword">if</span> point.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.get_dis(target, point.rchild.val) &lt; min_dis <span class="keyword">and</span> point.rchild <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            self.search(target, point.rchild, path)</span><br><span class="line">    <span class="keyword">return</span> nearest_point.val</span><br></pre></td></tr></table></figure><p>也没什么好说的，原理就摆在那，除了我不太会搞递归，是真的不太会，脑子总是转不过来（^V^)</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>就这样啦，《统计学习方法》这本书还是挺不错的，推荐大家去看看，挺适合没啥基础的同学去看看，哦，对了，下部番快好啦，很快就可以推给大家啦！！！好好期待吧～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈真的蛮好用的呢～</title>
      <link href="/blog/article/e1ba697.html"/>
      <url>/blog/article/e1ba697.html</url>
      
        <content type="html"><![CDATA[<p>又是一天枯燥无味的课，上午是憨批的学术英语，晚上是听不进去的并行计算，下午也就把目前正在记录的这道题稍微看了看，至于为啥要写点东西记下来呢？因为这种算法思路我好像并不常有，就比如上次那个删除重复值的思路（双指针那个），我同样也不怎么能想得到，所以呢，就笔头勤点，写下来可以经常看看，老话说得好，熟练于心嘛～</p><p>现在已经是晚上23点以后了，别问我为啥到现在还没睡，原因很简单，因为我现在还不想睡，我的手机正在forest上种树呢，所以即使我现在到床上去也只能在手机上看天气之类的应用（推荐forest，下次给大家伙看看我的森林，可以摆脱手机控～），所以呢，就随便写写，反正也只是未来的自己看看……..</p><p><img data-src="https://cdn.makiru.top/images/202202232333011.png"></p><span id="more"></span><p>终于硬是扛到了0点以后了，好了，不写了，明天上午等我爬起来之后再继续写吧，，其实也就是适当地拿leetcode上的一道题来讲一下单调栈的使用，以及它究竟可以用来做些什么。从名字上来看，这是一个栈，并且栈中的元素应该都是单调放入的。</p><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>示例：</p><p><img data-src="https://cdn.makiru.top/images/202202240003320.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实呢，这道题拿到手后，我第一想到的就是：我去，这道题咋这么眼熟，之前好像也在哪看过这歌柱状图，想了好长时间才想起，原来是之前做的那道接雨水的题。。。</p><p>然后呢，我连暴力解法都没想起来，这就是越做题越倒退嘛？？</p><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>自己想一想，暴力解法也不是很难，思路比较直接，既然是要寻找面积最大的矩形，那就以每根柱子为开始，向两边延伸（延伸：指以当前柱子高度往左右画条水平线，直到左右都有柱子高度没有达到水平线结束）</p><p>简单点来说，就是对每个柱子往左往右找到第一个小于自己高度的柱子，以举例来说，heights[4] &#x3D; 2，往左比其小的第一个是heights[1]，往右则是没有比其小的；</p><p>代码我就不写了，因为很简单，至于找第一个最小的要么直接遍历要么二分法查找都是可以的。</p><h4 id="单调栈—两次遍历"><a href="#单调栈—两次遍历" class="headerlink" title="单调栈—两次遍历"></a>单调栈—两次遍历</h4><p>单调栈的含义已经在前面说过了，这里不作解释；至于这道题为什么能牵扯到单调栈，可以思考下面这句话：</p><blockquote><p>如果柱子从左到右是单调增高的，那么对任何一个柱子而言，其左边第一个比其小的就是它的左侧邻居；那么如果有一个数据结构，能够保存这些柱子（不是单调增高的）中那些逐渐变高的柱子index的话，针对当前处理的柱子，想要找到它左侧第一个小于它的柱子就会很简单（因为保存的数据中只要最后一个index的高度小于当前柱子高度，那它就是答案，否则依次往前找到比当前柱子高度小的即可）。</p></blockquote><p><font color=red>注意：这里的单调是严格单调，下面还会有方法里的不是严格单调</font></p><p>至于标题中的两次遍历，想必大家也都明白为啥是两次（额，其实就是找到左边边界与右边边界）</p><p>还是以示例来解释下操作流程（2，1，5，6，2，3）：</p><ul><li>首先我们需要两个结构来保存每根柱子的左边界与右边界，简单记为left与right（这里记录的是下标索引，也可以直接记录高度）</li><li>处理第一根柱子，高度为2，它左边没有柱子，因此为了计算面积方便统一，我们给其左边界赋值为-1（<font color=red>哨兵</font>），并将第一根柱子的下标索引0放入我们用来保存递增index的结构—<font color=red>单调栈</font>，目前栈内为【0】，left为【-1】</li><li>处理第二根柱子，高度为1，这时单调栈的作用就可以看见了，我们用当前柱子高度1与栈顶的柱子高度（2）比较，发现栈顶柱子比当前柱子高，那栈顶的肯定不是当前柱子的左边界（用最笨的话解释左边界：[1，2，5，3，4]，3的左边界是2），既然不是，就把栈顶的柱子丢了，看下一个栈顶是不是左边界，结果发现，丢完后，栈空了，这就表明当前柱子没有左边界，和第一根柱子一样，我们给其left[1]赋值为-1，并将当前柱子下标1入栈，目前栈内为【1】，left为【-1，-1】</li><li>处理第三根柱子，高度为5，栈顶柱子高度为1，由于当前柱子高度大于栈顶的，所以栈顶的就是当前柱子的左边界，将栈顶的下标值赋予当前柱子left之后，将当前柱子下标入栈，目前栈内为【1，2】，left为【-1，-1，1】</li><li>以此类推可以得到：left为【-1，-1，1，2，1，4】</li><li>按照同样的方法，从右往左遍历一次，可以得到：right为【6，6，4，4，6，1】，注意：这里的6也是<font color=red>哨兵</font></li><li>计算结束后，就是统计最大矩形面积，这时，只需要计算以每根柱子往左右延伸的最大面积即可，举个简单的例子，第三根柱子高度为5，它的左边界为1，右边界为4，因此，面积就是（4 - 1 - 1） * 5 &#x3D; 10，以此类推即可获得最大矩形面积</li></ul><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//初始化哨兵</span></span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.peek() == -<span class="number">1</span>)&#123;</span><br><span class="line">            left[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从右往左遍历</span></span><br><span class="line">    stack.clear();</span><br><span class="line">    stack.push(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.peek() == len)&#123;</span><br><span class="line">            right[i] = len;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.peek() != len &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="单调栈—遍历一次"><a href="#单调栈—遍历一次" class="headerlink" title="单调栈—遍历一次"></a>单调栈—遍历一次</h4><p>上面的思路会遍历两次，那是不是可以只遍历一次呢，答案是可以的，其实很明显，上面遍历两次是因为我们需要获得left与right，那是不是只要在获得left的同时，获得right不就好了吗，确实是这样，下面遍历一次的思路，需要了解下面这段话：</p><blockquote><p>假设我们正在处理heights[i]，这时通过判断（heights[i]小于等于栈顶的高度），所以按照上面那种方法思路，是不是需要将栈顶的pop出来，没错吧～那对于栈顶的值来说，可不可以认为当前的heights[i]就是其右边界呢？首先需要明确，当前的i与栈顶值之间是不存在一个j（栈顶值&lt;j&lt;i），使得heights[j]小于等于栈顶的高度的，因为如果存在，那么在处理heights[j]时，栈顶的那个值早已经被pop了，所以可以理解成，i是栈顶值右侧第一个在高度上小于等于它的值（注意是小于等于）</p></blockquote><p>还是举个简单的例子吧，[2，3，1，5，5，5，6，2]</p><p>当我们处理第一个5的时候，栈内是【2】，我们可以顺利得到这个5的左边界为2，对于栈顶的2我们暂时没法得到其“右边界”，因为它还没有到被弹出去的时候（<font color=red>记住这里</font>），第一个5处理完后将其入栈，栈内为【2，3】，处理第二个5时，我们发现栈顶的高度和其是相等的，因此，是需要被弹出的（<font color=red>因为这里是严格单调的，即栈内不存在相等的值</font>），既然栈顶的值要被弹出了，所以按照上述的分析我们可以得到栈顶值的“右边界”就应该是第二个5，不知道你们有没有发现，这里对于栈顶的5而言，它所获得的“右边界”是不对的，因为其真实的右边界应该是最末尾的那个2。</p><p>所以呢，这里对于第一个5，我们没有获得真实的右边界，这样会影响答案吗？实际上，自己想一想，究竟什么时候会获得不真实的右边界呢？只有当当前处理的值与栈顶值是相等的时候才会赋予栈顶值不真实的右边界，既然这样，那针对当前的值而言，只要后面会出现一个小于它的值（也就是当前的值需要被pop的时候），它就可以获得真实的右边界，而当前值与最初栈顶与其相等的那个值真实意义上能获得的最大矩形面积是相等的。</p><p>举例来说，当第二个5处理完入栈后，栈内为【2，4】，第三个5依旧与栈顶值相等，所以对于栈顶的值，也就是第二个5而言，依然会获得不真实的右边界（第三个5），第三个5处理完后，入栈，栈内为【2，5】，当处理6的时候，正常处理，栈内为【2，5，6】，处理最后一个2时，栈顶值的高度为6，所以需要被pop，那6的右边界就是当前处理的2，pop后，栈顶变为5，其高度值也为5（第三个），依旧需要被pop，所以第三个5的右边界就是最后一个2（真实的右边界），总之，三个5，只有最后一个5会获得真实右边界，不过这三个5所能获得的最大矩形面积是相等的，所以并不影响最终的答案。</p><p><font color=red>也就是说，这里的左边界一定是真实的，右边界不一定真实，不过不影响最后结果</font></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="type">int</span>[] new_height = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">        new_height[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; new_height[stack.peek()] &gt;= new_height[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            right[temp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        left[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        ans = Math.max(ans, new_height[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码中有步操作：将原数组中的值移到了新数组中，也就是在原数组前后各加了个0，意义如下：</p><p>前面的0: 保证数组中所有的值都是大于等于它的，其实在上述代码中，可以没有前面这个0，这里加个0是因为其实可以没必要将left与right的值保存起来再来计算，为什么呢，<font color=red>不知道你有没有发现，每次需要弹出的时候，对于弹出的那个值而言，它的左边界与“右边界”（不真实，无影响）都是知道的了，那么为什么不可以直接计算它的最大面积呢？</font>而加的这个前置0就是为了当栈内只有一个真实有效的值的时候，并且它需要被弹出，这时可以直接计算它的最大面积，因为即使弹出后，栈顶依旧有值而不是栈空，这时或许有人会问，那会不会前置0也被弹出呢？会，只有当遇到0的时候，不过没关系，因为这时对于栈顶的0而言，计算出来的值一定是0，不影响结果，不过还是需要判断下栈空，因为0弹出后stack.peek()是会报错的。</p><p>后面的0: 保证最后栈内所有有效值都会被弹出，以获得其右边界</p><p>不知道大家有没有注意到，我们的栈内是不允许有重复值的，也就是严格单调的，但其实呢，单纯单调的话也是可以计算的，只是这时获得的左边界不一定是真实的而已，与上面是一样的原因，也不会影响最终结果。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] new_height = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        new_height[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; new_height[stack.peek()] &gt; new_height[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            ans = Math.max(ans, new_height[temp] * (i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就没有将边界值保存起来，而是每次只要栈顶值会弹出时，直接计算栈顶的最大面积，因此，我们必须保证所有的值都会出栈，所以才会在原数组后面加个0（0一定小于任何有效值）；除此之外，while循环中的判断条件将&gt;&#x3D;改为了&gt;，表示，栈内是可以保存连续重复值的。</p><p><font color=red>哨兵值的使用，会使程序很大程度上简洁，比如说，如果上面的代码中，没有哨兵值（前后的0），那么我们在计算ans之前必须判断栈是否为空，必须手动将最后栈内的所有值弹出并计算最大面积。因此，哨兵值的使用很重要～</font></p><p><font color=red>除此之外，计算对象的选择，也是很重要的，像我上面两种方式，一个计算对象是当前的heights[i]，一个是heights[stack.peek()]，前者必须将所有的left与right计算完才能计算，后者只需要在栈顶被弹出的时候就可以计算</font></p><p>其实呢，我们也可以在保持左边界一定真实的情况下，计算栈顶最大面积，只不过这种情况下需要判断栈空而已。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>在java中，能用Deque的时候尽量别用stack，因为你会这样：</p><p><img data-src="https://cdn.makiru.top/images/202202241134238.png"></p><p>用时长的就是stack，短的就是deque，优劣一眼就可以看出来～</p><p>写点有点多了，很多都是废话，只是给笨笨的博主当备忘录而已～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针解决去重问题</title>
      <link href="/blog/article/454a25b2.html"/>
      <url>/blog/article/454a25b2.html</url>
      
        <content type="html"><![CDATA[<p>想必现在的这个时候，很多人在难过，也有很多人在开心吧，至于为什么呢，因为今天又是一年一度的激动人心的考研查分日，依稀记得当时的自己查分的时候好像有点过于淡定了～不晓得大家上完岸后有什么打算，就我本人而言，虽然目前就读的这所学校在我国还是很有名的，地段也好（上海），有些排名甚至能进个前三，但是不知道为啥，总感觉我在这是浪费时间。就比如现在，本人正坐在学校的图书馆，刷了一小会题后，发现自己是真的垃圾，于是乎，转过来写点另类的垃圾。。。读研还是蛮苦的，不是累，是心里承担的太重了（话有点多了，开始正题^-^）</p><p><img data-src="https://cdn.makiru.top/images/202202211647556.jpeg"></p><span id="more"></span><p>今天想记录下的题目类型是有关于去重的问题，其实呢，去重的思路有很多，使用场景也不少，比如说有链表的去重啦，数组的去重啦，很多很多，或许有人会说，这不简单嘛，由于set自身就具有去重的属性，那我直接把要去重的都丢到set中不就好了，确实，这也是一种方法，今天我想讲的是利用双指针来进行去重～</p><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现<font color=red>两次</font> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于这道题来说，需要注意，如果nums的大小是小于等于2的话，其实是可以直接返回的；我们只需要注意当nums.length&gt;2的情况。</p><p>需要注意到的特性：</p><p>如果nums中的第三个数等于第一个数，就表示第三个数是不被需要的，因为该数的个数已经为2了。因此可以设置两个指针slow与fast，指向第三个数（<font color=red>因为可以根据nums[fast] &#x3D;&#x3D; nums[slow-2]，这里可以看出，slow指向的其实是已经处理完的序列的后一位数字</font>）。</p><p>以示例来说明算法过程：</p><ul><li>slow与fast均指向nums[2] &#x3D; 1，判断nums[fast] &#x3D;&#x3D; nums[slow - 2]，即1 &#x3D;&#x3D; 0（否），所以slow所指的数是需要留下的，因此，slow与fast同时后移；</li><li>slow与fast均指向nums[3] &#x3D; 1，nums[fast] !&#x3D; nums[slow - 2]，所以继续后移；</li><li>slow与fast均指向nums[4] &#x3D; 1， nums[fast] &#x3D; nums[slow - 2] &#x3D; 1，所以slow所指的数字不需要被留下，因此，slow不需要移动，fast往后移动；</li><li>slow指向nums[4] &#x3D; 1，fast指向nums[5] &#x3D; 1，继续将fast往后移，直到fast所指的值不等于nums[slow - 2] &#x3D; 1；</li><li>fast指向nums[6] &#x3D; 2，nums[fast] !&#x3D; nums[slow - 2]，所以将fast所指的数复制到slow所指的值，并两者同时后移（0,0,1,1,2,1,2,3,3）；</li><li>fast指向nums[7] &#x3D; 3，slow指向nums[5] &#x3D; 1，nums[slow - 2] &#x3D; 1 !&#x3D; nums[fast]，所以继续复制（0,0,1,1,2,3,2,3,3），fast与slow同时后移；</li><li>fast指向nums[8] &#x3D; 3，slow指向nums[6] &#x3D; 2，nums[slow - 2] &#x3D; 2 !&#x3D; nums[fast]，所以继续复制（0,0,1,1,2,3,3,3,3），fast与slow同时后移；</li><li>fast &#x3D;&#x3D; nums.length，所以遍历结束，slow所指的值为处理完序列的下一个数字，因此就是有效序列的长度，返回即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow - <span class="number">2</span>] != nums[fast])&#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本题相关拓展"><a href="#本题相关拓展" class="headerlink" title="本题相关拓展"></a>本题相关拓展</h3><p>这道题是将重复的数字可以保留两个，其实这种双指针的方法可以拓展保留k个，只需要将代码中的2变为k，即可；这种思路在去重中其实还是比较常见，奈何博主记性不好，总是在做到类似题时想不起来这种方法。其实在链表中也是可以使用的哟，只是需要适当修改下。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>好啦，我还是太懒了，写这么点东西，硬是拖到了现在（2022&#x2F;02&#x2F;21 20.07，外面也已经黑了）。。手机真的没啥玩的，QQ里没啥朋友聊，微信也只是看看课程群（不知道为啥，现在我竟然还会对课程群中的新消息有所期待～看来我是太无聊了。。）</p><p>无聊的我，待会也得回寝室去了，，今天又是无所事事的一天，我的研究生生涯又浪费了一天，24小时，1440分钟，86400秒，唉～</p><p>番剧嘛，最近已经在追了，还没完结，完结后再推荐给大家（额，，其实是写给以后的自己看的，看看那时的自己到底有多傻～），白白啦～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白兔糖</title>
      <link href="/blog/article/beb7b739.html"/>
      <url>/blog/article/beb7b739.html</url>
      
        <content type="html"><![CDATA[<p>这部番是我过年期间看完的，花了两天，别弄错了哟，是整整两天，虽然后面好像还有4集sp，但是想留着等特别难受的时候再去看，至于为什么选择特别难受的时候呢，因为这部番很适合这种时候，，哈哈哈，就是那种特温馨，特治愈的那种，小主人公可是特别可爱的哟～</p><p>说起这部番，其实也是别人推荐我看的，好像还是很久之前我就已经把它收藏进我的追番列表中了，至于是谁推荐的，额，废话有点多，给你们瞧瞧超级治愈的小主角</p><p><img data-src="https://cdn.makiru.top/images/202202121036332.png"></p><span id="more"></span><p>故事的具体情节呢，还请各位看官自己去看咯～ 剧情十分有意思，记得看哟。</p><p><a href="https://www.bilibili.com/video/BV1nx411C73s/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.4">直达链接</a></p><p>我就讲点大概吧，故事开始，男主角大吉参加他爷爷的葬礼，其间看到一个小女孩，也就是我们的小主角—凛，凛当时的表情其实很值得我们去猜想，至于我为什么这么说呢，各位看官可以看看这幅图，大概就会明白我说的话了，对了，当时的凛还仅仅只有6岁哦。</p><p><img data-src="https://cdn.makiru.top/images/202202121108382.png"></p><p>不知道各位看到这幅图有什么感受，我就说说我自己的吧，懵懂无知但又有很重很重的忧伤，同时伴随着对未来的一种无奈与困惑，哈哈哈，是不是以为我在写作文？？但这确实是我当时心里的一点小感受，我依然清晰的记得当时看到这个场面的时候，心里就突然咯噔了一下，这个场面是当时大吉看到这个女孩，女孩与其对视的场面。</p><p>这个女孩凛的身份究竟是什么呢？其实她是大吉爷爷的私生女，至于凛的母亲是谁呢，留个悬念吧，各位看官自己去看～等葬礼结束后，大吉一家人开始为凛的抚养问题伤起了脑筋，至于结果嘛，肯定是大吉承担起了照顾抚养凛的责任啦～</p><p>两人在一起住的过程中，发生了很多趣事，比如大吉给凛去买衣服的时候，就被狠狠地震惊了，因为他从来没想到原来抚养一个孩子需要买这么多奇奇怪怪的东西，还有大吉送凛去幼儿所的时候，急急忙忙的样子和凛的样子就很有趣～</p><p><img data-src="https://cdn.makiru.top/images/202202121123493.png"></p><p><img data-src="https://cdn.makiru.top/images/202202121123707.png"></p><p>由于大吉每天的工作都会要求工作到很晚，因此去接凛的时候总是会是幼儿所中最后一个，经过和工作中一位前辈的谈论中，大吉选择了换到一个不会工作很晚的工作中，这也是故事中一个比较小感动的地方。当然，也不能说大吉在与凛的日常生活中，没有感受到快乐，那是不可能的啦，和这么一位小天使在一起，怎么会不开心呢？大吉甚至还找到了一位自己很喜欢的人哟～她就是凛同学的母亲，也是一位单身母亲。</p><p><img data-src="https://cdn.makiru.top/images/202202121132657.png"></p><p>至于两人最后有没有走到一起，那就得去看原著咯～继续说大吉与凛之间的趣事，当时凛觉得自己没有同学可爱，想让大吉给自己扎个辫子，结果，你能想象大吉扎出来的样子嘛～别说，确实，扎完之后变得更可爱了，哈哈哈哈！</p><p><img data-src="https://cdn.makiru.top/images/202202121137559.png"></p><p>是不是超级可爱～</p><p>还有凛感冒生病时，大吉的照顾啦，对了对了，这个必须得说，那就是凛晚上睡觉时总喜欢挨着大吉睡，就像这样：</p><p><img data-src="https://cdn.makiru.top/images/202202121141289.png"></p><p>结果，某一天，奇怪的事发生了，凛居然睡的离大吉很远很远，原来是凛尿床了，尤其是凛非说那是汗时的表情，真是要多可爱有多可爱。</p><p><img data-src="https://cdn.makiru.top/images/202202121143820.png"></p><p>有一天晚上，凛大半夜还偷偷起床换衣服，额，不用想，肯定是尿床了，凛的脸在生气时嘟起来的时候超级可爱，不知道大家咋觉得？</p><p>当然，除了这些情节，比如说凛换牙的时候，也是很可爱的，大吉从那个单身母亲那知道还得买个牙盒用来纪念乳牙，不得不说，大吉在从一个整日只知道工作的大叔慢慢地转变成了一个父亲的形象。</p><p><img data-src="https://cdn.makiru.top/images/202202121149052.png"></p><p>番名白兔糖，确实，这颗糖真的好甜好甜，凛在番中还承担了每日的早饭哟，她还让大吉给自己买了把小菜刀，做起菜来一点都不含糊。番中还有个地方其实蛮值得深思的，就是大吉问凛愿不愿意把她的姓氏改成和自己一样的，但凛说不改，大吉就是大吉～至于原因嘛，其实在漫画中好像也有（挺让人意外的啦）有兴趣的小伙伴可以自己去看～</p><p>不得不说，这部番呢，承包了我春节在家的所有笑点，真的是超级好看，不信的可以自己去瞅瞅～拜拜啦，下部番也已经在路上了，不急不急，我还得先把我的研一下学期的工作给整整，至少得为毕业做好准备不是嘛，但是，放心，番剧绝对不会少，因为我是个坚定的追番瓜娃子～</p><p>结束，再给大家瞅几张超级可爱的图～</p><p><img data-src="https://cdn.makiru.top/images/202202121157151.png"></p><p><img data-src="https://cdn.makiru.top/images/202202121157216.png"></p><p>哎，有个好女儿确实是小棉袄～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月光下的异世界之旅</title>
      <link href="/blog/article/a18f622a.html"/>
      <url>/blog/article/a18f622a.html</url>
      
        <content type="html"><![CDATA[<p>这部番呢，还是很早之前看的了，而且，这篇文章也是我过完年之后才写的，别看发布时间，那是假的（因为是那天我把这部番看完后顺手创建的文档～）。</p><p>如果说，让我用一句话来概括这部番，那就是：我很想知道后续～整部番看下来，很过瘾，虽然也有些地方比较牵强，不过哦，看起来爽不就完事了嘛～</p><img data-src="https://cdn.makiru.top/images/202202112113901.jpeg"  /><span id="more"></span><p>既然是很久之前看完的番啦，望大家体谅下，可能有的地方，我自己都不太记得了，不过还是推荐大家去看，因为这部番既搞笑又热血。好了好了，不说废话了，番剧开始，主人公（也就上图中的那个男的—<strong>深澄真</strong>）一回家就直接被召唤穿越了，是不是很离谱，一般的穿越不是被车撞死就是被魔法阵召唤，真（男主角啦）直接回个家就被穿越了，穿越来到女神的神殿，结果竟然因为真的样貌很丑直接给踢到了世界尽头的荒野，其中一个叫月读神的神，很为真打抱不平，赐予他极强的加护祝福。于是乎，真就这样在这个世界寻找着与自己父母有关的记忆（因为真的父母是异世界人啦，好奇的小伙伴可以去看看番）。</p><p>途中呢，先是遇到了一条龙，名为蜃，因敌不过真，并且被真记忆中的各种与武士相关的事物所吸引，而成为真的第一个伙伴。</p><p><img data-src="https://cdn.makiru.top/images/202202112124873.jpeg"></p><p>接下来，真遇到了他的第二个伙伴，额，也不能说是遇到，是被真吸引过来的，因为第二个伙伴实在是太喜欢真的味道啦～她就是一只大蜘蛛，其能力与蜃是几乎差不多的，最终呢，趁真晕倒成为其第二个伙伴（额，其实篇中的所有伙伴均为仆人的含义～）</p><p><img data-src="https://cdn.makiru.top/images/202202112128692.jpeg"></p><p>是不是很可爱～</p><p>其中，蜃被赐予深澄巴，蜘蛛被赐予深澄澪，当然，千万别忘了还有个迷你巴哟～</p><p><img data-src="https://cdn.makiru.top/images/202202112140898.jpeg"></p><p>后面嘛，真又收了一位从者，是一位骷髅，以前是一位人族，因其求知欲以及所知知识极其丰富，被真看中，这里有个小插曲，就是巴与澪和真都是八二分的关系，也就是说真是八，从者是二，双方构成支配关系，而到了死灵骷髅的时候，一开始他只能被当作是食粮，，在戴上了13枚充满魔力的吸魔戒指，外加澪的魔力灌注，才勉强与真构成八二分的支配关系，赐名深澄识（是不是很逗～）</p><p>肯定的啦，中间我省略了一大段内容，比如说迷你巴为救兽人，被几个人族冒险者引发的事故而消灭等等，以及我们的主角真与两位从者（特指巴澪）之间的爱恨情仇等等，以及三人去人类的世界中游历的故事，都是很有意思的内容，有兴趣的可以去看看哟！</p><p>以上呢，大概就是这部番目前的内容啦，等下次有空，我再去刷一遍，不知道为啥，我特别想看真发飙的时候，很刺激～下部番剧其实我也看完了，趁着春节那段时间，我在家很是舒服的看完了那部番，等明天我就写，别急，番剧有的是～</p><blockquote><p>闲聊几句，目前的我已经在学校的宿舍里了，哦哦，你们还不晓得现在是啥时间吧，2022-2-11-21:55，很晚了哟（才不是～），再过几天就要开学啦，博主也要开始拼了，不然毕业论文还不知道该做啥，哈哈哈～拜拜啦～</p></blockquote><p><img data-src="https://cdn.makiru.top/images/202202112157163.jpeg"></p><p>（别误会，我只是想让你们看看我女儿～）</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Dyld: Library not loaded Reason: image not found报错</title>
      <link href="/blog/article/5169bb7d.html"/>
      <url>/blog/article/5169bb7d.html</url>
      
        <content type="html"><![CDATA[<p>不知道有没有使用mac的小伙伴遇到过这种问题，自己一开始起的账户名不是很喜欢，于是想要换一个，结果按照网上教程换完之后，账户名是变了，但是相应的好多之前配置的环境都报错了。如果有，哈哈哈哈，和我一样～</p><p><img data-src="https://cdn.makiru.top/images/202201042047762.png"></p><span id="more"></span><p>如果你也遇到了这个问题，不烦往下看看，说不定就解决了呢？</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我的问题是这样的，在昨天使用ssh连接我的azure的时候，发现总是会报一个我很眼熟的错，没错，就是很眼熟，错误如下：</p><p><img data-src="https://cdn.makiru.top/images/202201042053488.png"></p><p>这个错是我复现出来的，因为我已经解决了</p><p>你会发现它报了一个dyld，库没有加载？其实大多数只要是报了这个错，八成是和你的python路径有关联，像我上图中的&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssh中一定是用到了与python有关的依赖，但是呢，目前，python找不到了，自然就会报错。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>首先，如果你要确定自己的python还能正常使用，试验方法应该不用我教了吧，直接敲个python或者python3回车看看就行了，如果不行，那说明你的python环境需要重新配置，mac的话直接在~目录下，修改.bash_profile或者.zshrc等文件就可以了。</p><p>其次，看清楚referenced from后面的是哪个，必须先搞清楚目前是哪个想要获取python的帮助但是没有获取到，像我这里就是&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssh，搞清楚后，自然要看看这个ssh有哪些依赖是需要的，敲入下面这行命令（其他的自行修改）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -L /usr/local/bin/ssh</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://cdn.makiru.top/images/202201042108993.png"></p><p>我们会看到第三个依赖就是刚才报错的那条，因此，这条一定是有问题的，最直接的想法就是将这条给他改成正确的不就好了嘛？至于正确的是啥，请继续往下看。</p><p>我们需要知道自己的python在哪，一般情况下，如果是自己安装的，默认位置会在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Frameworks/Python.framework/Versions/3.5/bin/python3.5</span><br></pre></td></tr></table></figure><p>至于其中的3.5可能对每个人都有所改变</p><p>如果不能确定，可以使用以下命令进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python</span><br><span class="line"><span class="built_in">which</span> python3</span><br><span class="line"><span class="built_in">which</span> python2</span><br></pre></td></tr></table></figure><p>像博主这里呢，因为我是过于特立独行，将python3安装在了我用户目录下的library下了，而不是根目录下（流泪～）</p><p>于是乎，博主输入python，进入python3的命令行界面，敲入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure><p>回车后你就会看到一大堆和python有关的信息，你要找的是这种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.7/lib/python3.7</span><br></pre></td></tr></table></figure><p>简单点说就是带Frameworks的，会有很多这种，选择一个，然后呢，将它改成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.7/Python3</span><br></pre></td></tr></table></figure><p>注意结尾的Python3，写成和Python3.framework中的一样，别写错了</p><p>退出python后，敲入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo install_name_tool -change /usr/bin/python3 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.7/Python3 /usr/local/bin/ssh</span><br></pre></td></tr></table></figure><p><font color=red>注意修改，别傻乎乎的全照抄</font></p><p>回车后，按道理应该就可以了，不放心的可以再敲下刚才那个otool指令看下就好了。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>到这里就结束啦，下部番剧就快要看完啦，不过博主最近忙着各种期末考，可能还得等段时间才能继续更新番剧的推荐啦，但是呢，还是会不定时的更一些实践类的文章的～拜拜啦～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又是一年的福袋～</title>
      <link href="/blog/article/346c92e8.html"/>
      <url>/blog/article/346c92e8.html</url>
      
        <content type="html"><![CDATA[<p>又是一年一度的新年福袋活动，不知道大家有没有抽出自己想要的角色呢？反正博主我感觉年年都是脸黑。日日夜夜期盼着新年福袋能给我一个属于我自己的弓凛老婆，哎～这已经是第二年了。在此本脸黑博主愿各位看官都能获得自己的心仪老婆（弓凛是我的～）</p><p><img data-src="https://cdn.makiru.top/images/202112311226073.png"></p><span id="more"></span><p>简单介绍下这次活动吧，其实和往年没啥太大区别，就是抽卡只能用付费的石头才行，也就是说只能氪金抽（本博主痛心氪了那么亿点点），差不多一次10连抽（11次）是100块左右吧</p><p>池子方面呢，不少看板娘都出来了，比如像下面这个池子：</p><p><img data-src="https://cdn.makiru.top/images/202112311230388.png"></p><p>我的最爱都在这个池子里，可惜偏偏歪了（不过也是我没有的，也还行）</p><p>经过我多次的心理抉择，我最终还是把我的小金库搬了出来，来了一次，可结果呢？？是我想不到的结果～</p><p>只能说，我只能继续等明年了</p><p><img data-src="https://cdn.makiru.top/images/202112312011820.png"></p><p>我是真的服了这个叫啥豹的从者，每次一到活动抽卡的时候，他就出来捣乱，硬是一次给你出个4到5张，，气死人</p><p>不过嘛，总司也是蛮香的，就是剑阶的我已经有个麻雀了，，哎，对了，还顺带出了个忠贞，枪阶嘛，我也有最可爱的龙娘了，所以说，这次福袋，我是脸黑到家的人了。</p><p>还是祝大家都能抽到自己想要的角色吧，明天就是2021年最后一天啦，提前祝大家新年快乐啦～</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美好的平安夜</title>
      <link href="/blog/article/a1ef62fb.html"/>
      <url>/blog/article/a1ef62fb.html</url>
      
        <content type="html"><![CDATA[<p>今天呢，是一年一度的平安夜，当然也是考研的前一天晚上啦，相信现在有不少同学正在努力奋斗吧～加油啦，博主祝大家都能成功实现自己的梦想！</p><p>至于博主，在这个平安夜，在干嘛呢，那当然是边复习准备期末考试，边享受感慨人生的美好啦</p><p><img data-src="https://cdn.makiru.top/images/202112242208576.png"></p><span id="more"></span><p>在这美好的一个夜晚，至少要找两个妹子来陪我啦（妥妥的一个lsp），于是呢，就有了上面这张图的出场，是不是很羡慕啊，我可是一个有着后宫佳丽无数的男人。（不得不说，有时候人在陌生的地方，真的会感觉到所谓的寂寞～）</p><p>博主，现在呢，本来应该是在继续看我的傻逼物联网课的ppt的，但是呢，心里一想，今晚不应该好好写点文学垃圾纪念下的嘛，于是，果断放下手中的美少女漫画，，额，不是，是物联网ppt，转而来写这篇文学垃圾，就权当今年的平安夜我也是好好的过了。</p><p>既然是值得纪念的日子，那食物啥的不可缺少啊，一眼望去，靠，寝室里又只剩下虾米棒和维生素了。。。说时迟那时快，赶紧拿出手机，打开我的水果网，火速下单（赶在了最后一刻，，因为快要截单了）</p><p>心情很是不错，戴上耳机，听着小歌，看着窗外的雨，此时此刻，真想吟诗一首～虽然我不会。说起来，明天的圣诞节，不知道又会有多少人在默默的哭泣呢，博主也是其中一员，原因自然不一样，博主是因为明天还得早起去准备做点大事～秘密</p><p>说着说着，我的水果就到了，买了点啥呢？</p><img data-src="https://cdn.makiru.top/images/202112242218973.png" alt="" style="zoom: 33%;" /><p>当当当当！猕猴桃加菠萝蜜～心情超级好</p><p>于是乎，快乐的吃瓜时间就到了，边吃边看下次给你们介绍的番，心情就是不一样。看啥就是非常的好看，就比如这个：</p><p><img data-src="https://cdn.makiru.top/images/202112242222208.png"></p><p>是不是挺好看的啊，至于里面装了啥嘛，我的最优化大论文，还差一页封面，想去弄个彩印的，更好看点～</p><p>美好的平安夜，值得纪念，一年又就这样过去啦，祝愿每一个人都能开心快乐（虽然不现实，但还请努力，至少明天谁也不会知道是怎样的）</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效数字—状态机</title>
      <link href="/blog/article/5ed0faa5.html"/>
      <url>/blog/article/5ed0faa5.html</url>
      
        <content type="html"><![CDATA[<p>不得不说，上海这几天的天气是真的有毒，时不时超级冷，还时不时下几滴雨，烦得很。最近临近期末，还有好多大作业啦，项目啦，小作业啦，各种实验啦，烦得不要不要的，整的我连看番的时间都快没了(⁎⁍̴̛ᴗ⁍̴̛⁎)～</p><p>今天呢，本科母校竟然又因为这种奇葩原因久居热搜，真的是服了网友们的“奇思妙想”，这迫击炮逮谁轰谁啊？又是烦心事 》**《</p><p>不说烦心事了，说点开心的，额，，今天刚打完一天工，又有小钱可以拿了，算嘛？不算的话，今天把部分作业搞完了？错！今天我又一次在不知觉中将自己的闹钟给关了（绝对定了的）！！这才是大事（本来是7.25的闹钟，8.30开工，结果，一觉睡醒8.30了，呵呵～）</p><p><img data-src="https://cdn.makiru.top/images/202112161715143.png"></p><span id="more"></span><p>今天呢，要讲的是昨天做的一道题，蛮有意思的，竟然和我本科学的编译原理扯上关系了，害我还去看了会本科知识（因为我本科编译原理学的贼差）</p><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p></li><li><p>下述格式之一：</p><ol><li><p>至少一位数字，后面跟着一个点 ‘.’</p></li><li><p>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</p></li><li><p>一个点 ‘.’ ，后面跟着至少一位数字</p></li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（’+’ 或 ‘-‘）</li><li>至少一位数字</li></ol><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>其实我的思路比较直接，相信我一说大家也都能懂</p><p>这道题无非就是给定有效数字的模式，需要我们自己去比对，因此我们可以按照以下几个步骤对给定的字符串s作出判断</p><ul><li><p>首先判断s中是否包含非法字符，合法字符包括：0-9，+-号，小数点，E与e，其余的字符都可被认定为非法字符</p></li><li><p>接着判断s中是否包含E或者e，如果E或e的数量超过1，直接false，否则，借助E或e，将s划分，如果划分后，只有一个字符串，则只可能是E或e在结尾，返回false</p></li><li><p>划分后，判断前一个字符串是否为小数或者整数，判断后一个字符串是否为整数，如果都是，则true，反之，false</p></li><li><p>如果没有E或者e，则直接判断s是否为整数或者小数</p></li></ul><p>相信明眼人已经看清重点在哪了，没错，关键在于如何判断一个字符串是否为整数或者小数呢？</p><h4 id="整数判断："><a href="#整数判断：" class="headerlink" title="整数判断："></a>整数判断：</h4><p>首先判断开头是否为+或-，是的话，直接从第二位判断，不是的话直接从第一位判断，判断方式很直接，只要每一位字符都是0-9就可以。当然开始需要对s的length做出判断，如果长度为0肯定就直接false啦，如果只有一个+或-号自然也是false，代码如下，其中map是一个key为0-9，value为0的哈希表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">isInteger</span><span class="params">(String s, Map&lt;Character,Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">1</span> &amp;&amp; (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((s.charAt(i) == <span class="string">&#x27;+&#x27;</span> || s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小数判断："><a href="#小数判断：" class="headerlink" title="小数判断："></a>小数判断：</h4><p>小数判断相对而言较为麻烦点，因为存在可能性会稍微有点多，相信大家对小数都很熟悉，我们以小数点为界，将字符串分为两部分，一般而言，只要前后两部分都是整数就是一个小数，不过这里需要做出一些额外的判断</p><ul><li><p>小数点个数大于1直接false</p></li><li><p>分割后如果没有字符串，直接false（表示原本就一个小数点）</p></li><li><p>分割后如果只有一个字符串，表示小数点只能在结尾，这时，只需要判断分割后的那个字符串是否为整数即可（原因是split时，如果分割符在开头，则第一个分割出来的字符串是空串””）</p></li><li><p>如果是正常的两个字符串，也有多种情况：</p><ul><li><p>第一个字符串：</p><ul><li><p>第一个字符串是空串</p></li><li><p>第一个字符串是整数</p></li><li><p>第一个字符串是+或-</p></li></ul></li><li><p>第二个字符串：</p><ul><li>第二个字符串是整数，并且第一个字符不是+或-号</li></ul></li></ul></li><li><p>满足上述情况的两个字符串即可返回true，其余直接false</p></li></ul><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">isFloat</span><span class="params">(String s, Map&lt;Character,Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] temp = s.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(temp.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> isInteger(temp[<span class="number">0</span>],map);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((isInteger(temp[<span class="number">0</span>],map) || temp[<span class="number">0</span>].length() == <span class="number">0</span> || (temp[<span class="number">0</span>].length() == <span class="number">1</span> &amp;&amp; (temp[<span class="number">0</span>].charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span> || temp[<span class="number">0</span>].charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>))) &amp;&amp; (isInteger(temp[<span class="number">1</span>],map) &amp;&amp; temp[<span class="number">1</span>].charAt(<span class="number">0</span>) != <span class="string">&#x27;+&#x27;</span> &amp;&amp; temp[<span class="number">1</span>].charAt(<span class="number">0</span>) != <span class="string">&#x27;-&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好思路"><a href="#好思路" class="headerlink" title="好思路"></a>好思路</h3><p>利用有限状态自动机来进行解题，这是一种比较好的思路，具体的实现如下：</p><p>首先，我们需要根据题目的含义，将有效数字的所有可能性，以状态转换图的形式画出来，便于得到后续的状态转换表：</p><p><img data-src="https://cdn.makiru.top/images/202112170028249.jpg"></p><p>我相信各位大佬的理解能力应该都很强，关于这个图我就不细讲了，毕竟确实很容易理解（就是自己来画，蛮难的，编译原理没学好～）</p><p>额，要真的需要解释下的话，其实也没啥解释的，不就是一开始是个空的串，可以加入0-9数字，也可以一开始加入+或-号，其实就是构造一个有效数字的路径图</p><p>根据状态转换图可以得出下表：</p><table><thead><tr><th>state</th><th>blank</th><th>+&#x2F;-</th><th>0-9</th><th>.</th><th>e&#x2F;E</th><th>other</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>6</td><td>2</td><td>-1</td><td>-1</td></tr><tr><td>1</td><td>-1</td><td>-1</td><td>6</td><td>2</td><td>-1</td><td>-1</td></tr><tr><td>2</td><td>-1</td><td>-1</td><td>3</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>3</td><td>-1</td><td>-1</td><td>3</td><td>-1</td><td>4</td><td>-1</td></tr><tr><td>4</td><td>-1</td><td>7</td><td>5</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>5</td><td>-1</td><td>-1</td><td>5</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>6</td><td>-1</td><td>-1</td><td>6</td><td>3</td><td>4</td><td>-1</td></tr><tr><td>7</td><td>-1</td><td>-1</td><td>5</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>8</td><td>8</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></tbody></table><p>其中，状态8是用来处理字符串s结尾多余的的空格，因此所有终止态都必须跟上一个状态8，部分值为-1表示遇到一些不合法的字符（就是前面说的那些），直接返回false</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">make</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c &lt;= <span class="number">57</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finals</span> <span class="operator">=</span> <span class="number">0b101101000</span>;</span><br><span class="line">        <span class="type">int</span>[][] transfer = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123;-<span class="number">1</span>,-<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123;-<span class="number">1</span>,-<span class="number">1</span>, <span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123; <span class="number">8</span>,-<span class="number">1</span>, <span class="number">3</span>,-<span class="number">1</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                                       &#123;-<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123; <span class="number">8</span>,-<span class="number">1</span>, <span class="number">5</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123; <span class="number">8</span>,-<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                                       &#123;-<span class="number">1</span>,-<span class="number">1</span>, <span class="number">5</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                                       &#123; <span class="number">8</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; ss.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> make(ss[i]);</span><br><span class="line">            <span class="keyword">if</span> (id &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            state = transfer[state][id];</span><br><span class="line">            <span class="keyword">if</span> (state &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (finals &amp; (<span class="number">1</span> &lt;&lt; state)) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>注意：final的取值是有意义的，在上面的状态转换图中，我们可以得知：状态3，5，6，8可以作为正常的终止态，因此可以通过位操作来判断最终的状态是否在这几个选择中。具体上来说：final的值与1左移3位，1左移5位，1左移6位，1左移8位得到的是3，5，6，8；而其他的状态值与操作后都是0</font></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上便是这道题的全部内容啦！给我留下印象最深的就是有限状态机在算法中竟然还可以这么使用，学到了～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哀酱是我老婆～</title>
      <link href="/blog/article/bc3847dc.html"/>
      <url>/blog/article/bc3847dc.html</url>
      
        <content type="html"><![CDATA[<p>这段时间呢，博主凭借自己超级能挤时间的本领，将手边大多数事做完后，顺便趁着双十二买了个b站年度大会员（心疼死我了，108大洋呢，不过嘛，405天是真的香）。将事情都搞完后（其实也没搞完），就开始了电影之旅，因为这段时间，不知道为啥，感觉状态不是很好，就想着放松放松，突然想到2021年的柯南剧场版我好像还没看，于是乎去b站看了下，结果还没收录，也不晓得哪天才能收录。</p><p>我相信大家也都猜到了是啥电影了对吧～没错！就是《绯色的子弹》，听说当时上映后被好多人喷（咱是文明人，不随便吐槽别人辛苦做出的作品）</p><p>开头放张我哀的可爱糖：</p><p><img data-src="https://cdn.makiru.top/images/202112141108818.jpeg"></p><span id="more"></span><p>先声明下，哀酱是我的，别和我抢～</p><p>其实呢，除了《绯色的子弹》以外，我还看了部柯南的剧场版，叫做《江户川柯南失踪事件～史上最糟糕的两天～》，感觉嘛，比前者还要有意思点，毕竟我哀的出场次数更高（哈哈哈哈）</p><p>其实看完《绯色的子弹》后，我是一种很不爽的感觉，因为在这部剧场版中，哀酱完全就是被当作一个工具人。剧情方面呢，老套路，最后还是靠各种牛批的特效带起整部电影（尤其是赤井秀一的那一发子弹，我是真的服了）。既然说到剧情了，那就简单的让我回忆一下喽，电影开局，讲述了东京啥体育会上，邀请赞助商们体验乘坐日本首辆时速达到1000，额，单位不记得了，当然，我们的名侦探小队也通过各种撒娇，猜题，帮忙，拿到了乘坐资格，可在这时，通过柯大神的推理，发现，动车上说不定会有绑架枪杀事件，于是乎，借助经典假面超人秀把小队里的几个小屁孩给忽悠走了。也正是这个猜测，导致动车的体验乘坐被中止了，但是呢，等到发车的时候，动车山毫不意外的多了几个人——柯大神，世良，那个扇子发型的主持人（简称小扇），还有我们被绑架的大老板（主持这场体育会的老板），原来这个老板以前是FBI的前老大，抓了小扇的父亲，并处以死刑，尽管小扇说自己父亲是冤枉的。这是跑来替父亲报仇来啦，就在小扇即将枪杀老板的时候，另外三人加最牛批的大佬赤井秀一合演了一出戏，至于是啥戏，大家可以自己去看看，反正结局嘛，就是依靠赤井秀一的那发追上时速1000的动车，在磁悬浮近似真空的通道中，无任何摩擦加阻力的击中了小扇的肩膀。你以为故事到这结束了？？NoNoNo，毕竟事情的真相还没揭穿呢，原来小扇还有个同伙，这个同伙就是和她同台的那位工程师（简称小憨），于是乎，小憨见情况不对，拔腿就跑，试图直接让动车高速撞毁，最后呢，还是被柯大神与我们的工具人哀酱解决了。</p><p>哎，只是想说，哀酱在这部番中是真的卡哇伊，可惜了新衣服，只能当大电灯泡外加工具人</p><p><img data-src="https://cdn.makiru.top/images/202112141138021.jpeg"></p><p>对这部电影中，比较令我很感兴趣的就是玛丽在这部电影中的戏还是蛮多的，不得不说，玛丽还是一如既往的cool，果然老妈还是比儿子强啊，剧中，世良与赤井秀一的打斗场景，非常精彩，妹妹还是打不过自己的哥哥，但是呢，老妈一出手，立刻就把儿子制服（连赤井秀一都被吓到了～）</p><p><img data-src="https://cdn.makiru.top/images/202112141145523.jpeg"></p><p>是不是很cool，啊！！！wsl</p><p>第二部电影呢？额，情节还是比较有意思，大体上讲的就是柯南装失忆，打入恐怖分子内部，那家伙的，装的是真的惟妙惟肖。恐怖分子企图用饼干炸弹将外国总统的妻子与儿女杀害，最后被柯南与哀酱，当然还有小兰啦，一起合力解决。比较有意思的场景有：哀酱与小兰沐浴的时候，小兰问哀酱有没有喜欢的人啦，还有小兰一个横踢就把匪徒的枪给踢没啦（只因匪徒说新一是个二愣子～），巴拉巴拉，还有好多好多，非常推荐去看</p><p><img data-src="https://cdn.makiru.top/images/202112141150583.jpeg"></p><p>就这小眼神，我问有谁不喜欢！！！天啦，太可爱了点吧</p><p>对了，这部电影的结尾，还给了一个小小的福利，就是柯南向哀酱道谢后，哀酱竟然意外的脸红了！！！</p><p><img data-src="https://cdn.makiru.top/images/202112141153180.jpeg"></p><p>虽然不明显，但是确确实实的是脸红了～</p><p>太可爱了，不说了，过几天我打算直接追整部柯南了，1000多集，也不算多嘛，毕竟我可是追过，龙珠啦，火影啦，海贼王啦，的男人，当然，剧场版也不会落下的。</p><p>最后强调一句，哀酱是我老婆～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侦探 </tag>
            
            <tag> 悬疑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因为太怕痛就全点防御力了</title>
      <link href="/blog/article/44480b7f.html"/>
      <url>/blog/article/44480b7f.html</url>
      
        <content type="html"><![CDATA[<p>等待已久的泡面番它又来啦！！其实呢，这部番还是我前天晚上才看完的哟，最近也刚好把一些之前没看完的番也看完了，这下素材就很多了，只不过有部分番没有截一些我个人认为比较有意思的图，可能得后期再补一次。今天要讲的番叫做《因为太怕痛就全点防御力了》。不知道各位看官看完这个题目会不会觉得有点蒙，反正我是有点。</p><img data-src="https://cdn.makiru.top/images/2021120911.jpeg"><span id="more"></span><p>在讲这部番之前，先贴张我最近才抽空看的柯南剧场版《绯色的子弹》中我最爱的一个场景，没错，就是哀酱吃醋的经典场面，啊！！！wsl，哀酱是真的可爱～</p><p>好吧，不扯了，开讲，首先呢，介绍这部番的大概剧情吧，记住，这部番中有一个很重要的点，拿出你们的小本本记下：女主是策划的老板～</p><p>番剧开始，我们的女主叫做枫，她有个好闺蜜叫做沙理，我只能说我很羡慕这样的友情。。沙理向我们的女主枫推荐了一款游戏（只要是游戏，八成都是虚拟游戏，也就是刀剑中的经典游戏啦），但是呢，沙理因为要准备考试，只能枫一个人先玩啦，就这样，枫独自在自己的开挂之路上越走越远。游戏入场，枫还只是一个初级的新手，一开始，自然是人物的属性设置，就如标题所言，枫因为怕痛就把所有的属性点全部用在了提升防御力上，这也导致入场后枫的行走速度就和乌龟一样（此刻可以哈哈大笑一声），忘说了，枫选择的是盾兵。</p><p>入场后，女主便问了一个卡哇伊的小姐姐哪里可以打怪，记住这个小姐姐哟，枫来到森林，遇到了很多小怪（不得不说这里的小怪是真的可爱），可是呢，因为枫防御力过高，导致小怪们都无法伤害到她，枫打败这些小兵们之后，她的防御力就开始蹭蹭往上长，还获得了一些特殊技能，比如耐毒，甚至还获得了一枚戒指（有特殊用处）。按照以往番的套路，打完小怪后，自然是去打大boss啦，于是枫用着新手级的装备，硬是打出了顶级高手的气势。枫第一次打的大boss是一只毒龙，我是真的替boss感到惋惜，硬是放毒放了那么久，结果还偏偏将枫的耐毒直接提升到顶级，哎，可怜的毒龙～最后嘛，结果不言而喻，也通过这次经历，枫获得了毒龙技能（就是放毒），还获得了一套特别cool的衣服和一个大盾，说起这个盾，是真的秀，感觉就是开挂神器，盾上有几个卡槽，可以放多个技能，还可以使出恶食的特殊技能，没错，就是可以直接把怪物吸收的那种—简称挂界神器。</p><p>之后嘛，沙理也顺利通过考试，进入游戏，和枫一起玩啦，刚进来，沙理也被女主的防御属性吓了一跳。之后，枫想再做一个盾，于是两人便去寻找素材，也就是钓鱼，这家伙的，女主光环真不是盖的，随便找找就能找到隐藏宝藏啊，她俩在湖底发现了一个隐藏的关卡，沙理也借此获得了新装备一套。</p><p>就这样，两人走上了开挂不回头的道路，找完素材，枫又获得了一个白色的大盾，之后嘛，便是不停的打boss，不停的增加新的奇怪的技能，比如说，在一次游戏官方活动中，需要收集羊毛，枫因为和羊玩了太久，于是乎，就获得了这样的技能：</p><img data-src="https://cdn.makiru.top/images/20211208110021.jpg"><p>没错，浑身长羊毛的技能！！！</p><p>当然还有更离谱的啦，在一次和长得和怨灵一样的怪物中，女主神奇的获得了变身的技能，甚至还引发了围观群众这样的看法。</p><img data-src="https://cdn.makiru.top/images/20211208110247.jpg"><p>不得不说，这变身着实就是开挂对吧，在后面的活动中，枫硬是凭借这玩意完败其他选手</p><img data-src="https://cdn.makiru.top/images/20211208110349.jpg"><p>这确实是开始向着不做人的道路上不断前进的节奏啊～</p><p>到了第三层之后（没错，和刀剑的设定很像，也是很多层就对了），这一层呢，是机械之城，到处都是机械，枫自然而然因为自己的女主角光环获得了不得了的技能，说起获得过程嘛，真的是离奇，女主刚进这一层，就遇到了一个类似乞丐的NPC，和她说起了这座城的由来，还给了女主一枚硬币；然后呢又遇到了一对母女，女儿患病，需要玩家完成各种任务才能治好，这个部分的场景贼有意思，有兴趣的看官可以起看看，大概就是枫完全没有动武，直接坐着糖浆在天上飞，就完成了任务，而母亲说着什么“啊！辛苦了，这位勇士”巴拉巴拉的，贼搞笑，对了，枫的那个变身怪物的技能也是在替这个女孩找药水的过程中中进入的教堂中获得的，其中的一个任务就是要用到之前说的那枚戒指（你就说，这得是多么小的概率啊），哎，果然是策划的老板～在后面的一次寻找金币的活动中，女主意外地跌落山崖，以女主的体质，必然又是升级挂的操作啦，没错，她又找到了一个隐藏的关卡，里面的是这座机械之城的前任城主，不过好像是被类似附身了，枫将乞丐给的硬币塞进了城主的体内，城主清醒了一小会，给了枫一个更大的硬币，并插进了枫的体内，就这样，枫的又一开挂技能获得（变身机甲战士），借助机甲的力量，将黑化的城主秒了。</p><img data-src="https://cdn.makiru.top/images/20211208111851.jpg"><p>后面嘛，枫因为第四次官方活动—公会对抗赛，组建了一个小公会（大枫树），我是真的佩服女主的起名思路，就比如说她那只乌龟，叫做糖浆，又可爱又实用，说到乌龟，是真的拉风，这只乌龟竟然可以在天上飞！！！还是变大版的那种，可以带人飞！额，说偏了，公会的人员嘛，都是女主在打怪升级中认识的，除了上面那张图中的六个人外，自然还有沙理和枫啦，那么依次从左到右介绍下人员配置吧，第一位是我们的知识库，她亦或是他（我是分不清啦）有一个类似魔方的东西，这玩意可厉害了，就和百库全书一样，啥都知道；第二位是一位剑士，我只想说，她的身材在这个番里绝对是排的上号的（哈哈，lsp的属性不自觉就暴露出来了）。第三位是我们的工匠，啥都能做的那种，女主的白盾也就是她做的；第四位就是和女主认识较早的另一个大盾兵，在一次与大怪物打斗中，意外获得这套装备，甚至还赋予了当HP为0时，有50%的不死概率（又是一个奇葩技能）；第五和六位则是一对姐妹，两人和枫一样，直接把所有的属性点都点在了攻击上，也是极其的卡哇伊就对啦～</p><p>到了最后一场官方活动—公会对抗赛中，规则很复杂（反正我是没听懂，不过就是不停的夺别人家的宝珠就对了），只要获得前十的排名，就能获得丰厚的奖品。各个公会中，比较厉害的有炎之帝国，圣剑公会，当然还有我们的大枫树，起初，大枫树排到了第七还是第几来着，不过呢，有女主这么开挂的存在，打赢不还是洒洒水啦。在后面与炎之帝国与圣剑公会的对抗中，枫使出了自己的两大变身——机甲和怪物，硬是把对方吓傻了，逆天的操作。</p><p>故事到这其实就差不多结束了，第四场公会活动结束后，大家还在一起愉快的聚了个餐。有部分有意思的情节因为篇幅原因，没有细讲，比如说，其实炎之帝国的领袖是一个爱哭鼻子的小女孩，在被枫打败后直接气哭了</p><img data-src="https://cdn.makiru.top/images/20211208114305.jpg"><p>整体来说，这部番是真的很推荐各位去看看，太有意思了，很期待它的第二季（听说也快了）。</p><p>至于下一部番呢，应该还得等等，因为有部分图片，博主在看的过程中，因为过度入迷（至于入迷的原因嘛，lsp应该都懂），没来得及截图，毕竟得把最精彩的部分以图片的形式展示给各位和我有共同爱好的lsp们啊（bushi）</p><p>那么，拜拜啦，下次继续我们的番剧之旅～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搞笑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间问题</title>
      <link href="/blog/article/13291e9a.html"/>
      <url>/blog/article/13291e9a.html</url>
      
        <content type="html"><![CDATA[<p>又是美好的周六，今天的上海天气是真的好，刚好老爸来学校玩了半天不到，我也趁着这个机会在学校里瞎逛了会。学校里呢，这几天也在办一些活动，比如像冬季长跑啦，以前玩的那种脚并着走路啦，巴拉巴拉的许多。</p><p>但该干活的时候，还是得干活的，毕竟我可是留了不少ddl在赶的男人～像啥计算机网络的第二次作业啦，最优化的第十二周作业啦，最优的的论文啦，项目进展啦，学术英语第一次作业啦，等等等等，一大堆。。。。不过嘛，在下午的连忙赶工中，目前只剩下几样啦，可以明天或者有空再慢慢搞了，又恢复到了可以写写流水账的时候啦。</p><img data-src="https://cdn.makiru.top/images/image-20211204192915093.png"  /><span id="more"></span><p>今天想把关于区间类的问题做个小小的总结，因为这类问题其实想起来还是很容易出各种变化的题型的～</p><p>今天主要想讲两种类型的区间问题：</p><ol><li>区间合并</li><li>区间插入</li></ol><p>至于区间重叠判断，，应该是最简单的了吧～就不用多讲了</p><p>在讲这两种问题前，我先简单介绍下这几天，，也不对，是最近学到的一种结构类型吧，名字叫做<font color=red>“bitset”</font></p><p>关于bitset的解释，我还是选择使用示例来讲，看下面这幅图就大概懂这个类型的用法了：</p><img data-src="https://cdn.makiru.top/images/header1.png" style="zoom:50%;" /><p>这幅图是我在代码中用到的，首先解释下里面的这些2，3，等值代表什么意思，这些值其实是你原本数组或者其他结构里面的索引，存到bitset里，并且这些值的位置都是被赋予了true。如果还是不太懂，更简单点，就是说2,3,4,5……..36这些值对应的都是true，其他的都是false</p><p>关于bitset有三个方法比较常用，一个是nextSetBit()，一个是nextClearBit()，一个是set方法，举例说明这三方法的含义：</p><p>nextSetBit(13)：返回的是16，因为16是比13大，并且设置为true的（这里可以包括13）</p><p>nextClearBit(16)：返回的是21，因为21比16大，并且设置为false（同样可以包括16）</p><p>bitSet.set(0, 3, true): 会在bitset里加入0,1,2</p><p>说到这里，想必大家也明白我为什么要先讲这个结构了吧～没错，这个类型在区间问题上是很方便的，因为完全可以把这个bitset看成是坐标轴来使用。</p><p>好了，正式开始两种区间问题的简单介绍～</p><h2 id="问题类型1-区间合并"><a href="#问题类型1-区间合并" class="headerlink" title="问题类型1: 区间合并"></a>问题类型1: 区间合并</h2><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>以数组intervals表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><p>首先，我们需要做什么，给出一个结果集，用来装区间段，然后就是依次遍历题目给定的多个区间，当然，首先得确保这些区间都是按照区间左端点由低到高的顺序排列的，至于为什么，待会就知道了，具体步骤如下：</p><ol><li><p>当结果集是空 or 目前遍历到的区间的左端点大于结果集最后一个区间的右端点时，直接将该区间加入结果集</p></li><li><p>当遇到目前区间的左端点小于等于结果集最后一个区间的右端点时，表示两者重叠（为啥？画个图你就知道了，这里也就是为啥必须得先排好序才行的原因），既然重叠，那必然是需要合并的啦，至于咋合并，用脚趾头想都能想出来吧，肯定是把结果集中最后一个区间的右端点改下不就好啦，改成啥呢，<font color=red>那得看结果集最后一个区间的右端点与当前区间的右端点谁大了</font>，谁大换谁</p><img data-src="https://cdn.makiru.top/images/image-20211204205234265.png" style="zoom:50%;" /></li></ol><p>上图中的蓝色代表当前区间，黑色表示结果集最后一个区间，从图中就可以看出为什么要在确定合并后区间的右端点时比较大小的原因了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">    Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 遍历区间</span></span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval: intervals) &#123;</span><br><span class="line">        <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，说明不重叠。</span></span><br><span class="line">        <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">            res[++idx] = interval;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反之说明重叠，则将当前区间合并至结果数组的最后区间</span></span><br><span class="line">            res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>注意：由于一开始并不知道合并后有多少个区间，因此至少需要原本区间的数量大小，返回时可以直接使用copyOf方法拷贝我们创建的数组中的一部分</font></p><h2 id="问题类型2-区间插入"><a href="#问题类型2-区间插入" class="headerlink" title="问题类型2: 区间插入"></a>问题类型2: 区间插入</h2><h3 id="问题介绍-1"><a href="#问题介绍-1" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><h3 id="问题思路-1"><a href="#问题思路-1" class="headerlink" title="问题思路"></a>问题思路</h3><p>从题目上来看，其实这道题相比于前一道题还要简单点，为什么呢，因为题目中给出了区间列表是排好序的，我们只需要将给的新区间放到结果集中，整个过程可以分为三步：</p><ol><li><p>当<font color=red>目前区间的右端点小于新区间的左端点</font>时，直接放入结果集，直到目前区间的右端点大于等于新区间左端点为止。</p></li><li><p>当前区间的右端点大于等于新区间的左端点，表明重叠，这时需要去看新区间的右端点，看看新区间一共将区间列表中的区间覆盖了多少，看看下面的图就懂我这句话的意思了。</p><img data-src="https://cdn.makiru.top/images/image-20211204235243879.png" alt="" style="zoom: 50%;" /></li></ol><p>​看看上面的图，新区间的右端点8一直扩张到8-10区间，因此，当第一步到区间3-5停止后，<font color=red>只要当前区间的左端点小于等于新区间的右端点（表明重叠）</font>，就将新区间的左右端点进行更换（扩张新区间），至于更换规则，看图说话，左端点选择新区间左端点与当前区间的左端点较小值，右端点选择新区间右端点与当前区间右端点较大值。</p><p>​更换过程：4-8 &#x3D;&gt; 3-8 &#x3D;&gt; 3-8 &#x3D;&gt; 3-10</p><ol start="3"><li>当目前区间到达12-13时，当前区间的左端点已经大于新区间右端点，表明不再重叠，直接加入结果集</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历区间列表：</span></span><br><span class="line">        <span class="comment">// 首先将新区间左边且相离的区间加入结果集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            res[idx++] = intervals[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接着判断当前区间是否与新区间重叠，重叠的话就进行合并，直到遍历到当前区间在新区间的右边且相离，</span></span><br><span class="line">        <span class="comment">// 将最终合并后的新区间加入结果集</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = Math.min(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[idx++] = newInterval;</span><br><span class="line">        <span class="comment">// 最后将新区间右边且相离的区间加入结果集</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">            res[idx++] = intervals[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="关于bitset的使用"><a href="#关于bitset的使用" class="headerlink" title="关于bitset的使用"></a>关于bitset的使用</h2><p>说了这么多，都没有用到bitset，肯定有人会说那开头讲这个是为了什么呢？？？别急，讲了的肯定都有用</p><h3 id="区间合并的使用"><a href="#区间合并的使用" class="headerlink" title="区间合并的使用"></a>区间合并的使用</h3><p>实际上思路是很简单的，只需要将题目中给的区间列表依次用set的方法放入bitset中，完全放入后，再遍历bitset（当然是用nextSetBit和nextClearBit的方法啦～），使用nextSetBit的方法获取区间的左端点，nextClearBit的方法获取区间的右端点（<font color=red>有几个需要注意的点，在代码后面会解释</font>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> interval[<span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        bitSet.set(interval[<span class="number">0</span>] * <span class="number">2</span>, temp, <span class="literal">true</span>);</span><br><span class="line">        max = temp &gt;= max ? temp : max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; max) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> bitSet.nextSetBit(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bitSet.nextClearBit(start);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] item = &#123;start / <span class="number">2</span>, (end - <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">        intervals[count++] = item;</span><br><span class="line"></span><br><span class="line">        index = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[count][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        ret[i] = intervals[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点:  <font color=red>说好的是将区间放入bitset里，为什么代码里写的是将区间左端点乘2，右端点乘2加1放入bitset呢？</font>原因很简单，我画个图你就明白了</p><p><img data-src="https://cdn.makiru.top/images/image-20211205000849667.png"></p><p>假设有两个区间1-3和4-6，如果直接放入bitset，结果就是1,2,3,4,5,6全部都是true，然后合并区间时，会发现在bitset里无法区分这两个本来分离的区间，因此需要借助乘2来增加间距</p><p><img data-src="https://cdn.makiru.top/images/image-20211205001132631.png"></p><p>结果就是如上图所示，最后放入bitset里的结果就是2,3,4,5,6,8,9,10,11,12，因此可以很清楚的利用nextSetBit(0) 获得2，nextClearBit(2)获得7，再对其进行之前为加间距做的操作的逆操作即可，同理，8-12也是一样</p><h3 id="区间插入的使用"><a href="#区间插入的使用" class="headerlink" title="区间插入的使用"></a>区间插入的使用</h3><p>关于这种类型的使用，其实原理上与上面的是差不多的，也都是将所有的区间依次放入bitset，包括新区间，最后再进行区间合并与分离</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] interval : intervals)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">2</span>*interval[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        bitSet.set(<span class="number">2</span>*interval[<span class="number">0</span>],temp,<span class="literal">true</span>);</span><br><span class="line">        max = max &gt; temp ? max : temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitSet.set(<span class="number">2</span>*newInterval[<span class="number">0</span>],<span class="number">2</span>*newInterval[<span class="number">1</span>]+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    max = max &gt; <span class="number">2</span>*newInterval[<span class="number">1</span>]+<span class="number">1</span> ? max : <span class="number">2</span>*newInterval[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; max)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> bitSet.nextSetBit(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bitSet.nextClearBit(start);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] item = &#123;start/<span class="number">2</span>,(end-<span class="number">1</span>)/<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ret.add(item);</span><br><span class="line">        count++;</span><br><span class="line">        index = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[count][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        ans[i] = ret.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点与上面的是一样的，注意区间间距的分离</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是关于区间问题的大体介绍了，按我的想法来看，只要是区间类的问题，都可以无脑使用bitset的方法来写，十有八九能AC（瞎猜的，别介意～）</p><p>至于这几天的番嘛，就快了，就快了～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符匹配—动态规划</title>
      <link href="/blog/article/5869fdc.html"/>
      <url>/blog/article/5869fdc.html</url>
      
        <content type="html"><![CDATA[<p>今天要记的题目是关于动态规划的两道题，没错，两道题，因为很类似，所以就放一起记了</p><p>相信很多人应该都有类似的感觉（卧槽，原来是这样的嘛？这递推公式也不怎么难嘛—做题前；额，，额，这递推公式咋想啊～—做题时）。动态规划，主要的在于当你拿到一道题时，要能想到使用动态规划（很多情况，我都是直接硬怼，递归走起，结果不是超时就是错误），其次是能够将问题的细节想明白，将流程中的一小步拿出来单独去看，最后，将这一小步写成递推公式</p><img data-src="https://cdn.makiru.top/images/image-20211115211944186.png" alt="" style="zoom: 33%;" /><span id="more"></span><h2 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;?&#x27; 可以匹配任何单个字符。</span><br><span class="line">&#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先看题，无非是字符串之间的匹配，只是加入了两种符号而已～</p><p><strong>注意</strong>：为解释方便，都默认目前模式串的匹配位置为p[j]，即第j+1个字符（从1开始），主串的匹配位置为s[i]，在这两个位置前的均已匹配成功</p><p>最直接的想法：分情况讨论（p[j]的分类）</p><ul><li>p[j]为a-z间的字符的时候，直接匹配即可，如果p[j] !&#x3D; s[i]，直接false，反之j++，i++</li><li>p[j]为’?’符号的时候，表示可以匹配任何单个字符，因此，不用看，直接i++，j++</li><li>p[j]为’*’符号的时候，表示<font color=red>可以匹配任何字符串</font>（注意：这里是与下一道题不同的地方），到这里，就属于比较麻烦的情况了，因为我们不知道这个符号代替的到底是什么？空串？单字符？还是多字符？都有可能，因此继续分情况讨论<ul><li>如果是空串，就看p[j+1]与s[i]的关系</li><li>如果是单字符呢，就直接看p[j+1]与s[i+1]的关系</li><li>最麻烦的是多字符，这个时候，仔细想下，多字符？也就是说除了当前s[i]这个字符外，p[j]还会匹配s[i]后面的字符，所以就继续看p[j]与s[i+1]的关系</li></ul></li></ul><p>这就是最直接的思路，也就是递归的思路，不过这个思路中，存在大量的重复计算，导致无法AC，实际上，加上一个用来记忆判断过的下标组合就可以AC，这里就不贴代码了，因为这不是我想要记录的部分(&gt;^ω^&lt;)</p><p>递归加记忆化可以通过的题，动态规划怎么可能不行呢？肯定是可以的，常规操作，构建dp数组，dp[i] [j]表示的是指p的前j个字符与s的前i个字符的匹配与否（注意：dp[2] [3]意思是p[2]与s[1]前面的匹配情况，包括p[2]和s[1]）</p><p>数组定义好后，需要将一些边界关系设置好，比如，dp[0] [0] &#x3D; true，dp[?] [0] &#x3D; false (? &gt; 0)，dp[0] [?]则需要人为判断下，因为只有当p的前?个字符都是’*’才可以为true</p><p>边界关系设置好后，就是递推公式的推导，这也是最烦的地方，一步步来看：</p><ul><li>当p[j]为a-z字符时，dp[i+1] [j+1] &#x3D; dp[i] [j] &amp;&amp; (p[j] &#x3D;&#x3D; s[i]) （这很容易懂吧～，就是说，是字符的话，就看p[j]和s[i]前面的匹配与否与p[j]，s[i]是否相等共同决定）</li><li>当p[j]为’?’时，dp[i+1] [j+1] &#x3D; dp[i] [j]</li><li>当p[j]为’*’时，也是比较麻烦，分情况讨论：<ul><li>‘*’表示多字符时，dp[i+1] [j+1] &#x3D; dp[i] [j+1].   可以看出来，<font color=red>这里的想法和递归刚好是相反的，递归的时候，多字符我们是向后看的，但是这里，我们是往前看的，也就是说这个多字符包含的是前面的字符加上当前字符</font></li><li>‘*’表示单字符时，dp[i+1] [j+1] &#x3D; dp[i] [j].</li><li>‘*’表示空串时，dp[i+1] [j+1] &#x3D; dp[i+1] [j]</li></ul></li></ul><p>实际上，对’*’的分类可以更简单点，两种：使用与未使用，使用了的话，dp[i+1] [j+1] &#x3D; dp[i] [j+1]；没使用的话，dp[i+1] [j+1] &#x3D; dp[i+1] [j]</p><p>可能到这，还是有点懵，没事，再简单点来说，首先明确一点，<font color=red>动态规划是根据前面的状态来考虑后面的状态</font>，因此，不用去想p[j]后面的匹配情况。假设我们使用了*号，那么我们是不是无法确定目前的s[i]是代表的多字符的最后一个？因此，需要查看s[i-1]的情况，也就是dp数组中的dp[i] [j+1]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1==<span class="number">0</span> &amp;&amp; len2==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)) &amp;&amp; dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h2><h3 id="题目介绍-1"><a href="#题目介绍-1" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p>老实说，就是第三个示例让我很迷糊～导致这道题我一直没做，直到把上面那道题做完了后才回去看的这道题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题肯定也是有很多思路的啦，比如递归啥的，，只是这里就只讲下动态规划的思路，便于我自己记忆（没错！！我自己～）</p><p>与上面那道题的不同在于，这里的’*’号不是可以代替任意字符串的，它必须有个前缀字符，并且其作用是将前缀字符重复任意次，简单点来说，a *就是指可以表示空串，aa，aaa等</p><p>那么，这会造成什么不一样的呢？其实区别也不是太大，往下看就知道了～</p><p>首先构建dp数组，定义与上面那道题一样</p><p>接着，边界有点变化，dp[0] [?]的判断不太一样，这里，如果希望是true，那么p必须类似于a * a* a*这种，而且？必须是 *号下标才可以，那这该怎么弄呢？别忘了，我们这是动态规划，是有前面的状态的，没错，dp[0] [i] 与dp[0] [i-2]是有关系的（当然，仅在p[i-1]为 * 号的时候）</p><p>最后就是递推公式，大体上与上道题类似，只是些许不同</p><ul><li>当p[j] 为a-z字符时，dp[i+1] [j+1] &#x3D; dp[i] [j] &amp;&amp; (p[j] &#x3D;&#x3D; s[i])</li><li>当p[j] 为 ‘.’时，dp[i+1] [j+1] &#x3D; dp[i] [j]</li><li>当p[j] 为 ‘*’时，分类讨论：<ul><li>使用了 *号：dp[i+1] [j+1] &#x3D; dp[i] [j+1].  (理由与上道题是相同的，当前s中的字符不一定是 *号代表的最后一个字符，我们不向后看)</li><li>没使用 *号：dp[i+1] [j+1] &#x3D; dp[i+1] [j-1]  <font color=red>注意</font></li></ul></li></ul><p>标注的注意的地方，也就是与上道题不同所在，因为这里的 *号始终是与前面那个字符是绑定的，因此不用的话前面那个字符也被删掉，所以减了2</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1==<span class="number">0</span> &amp;&amp; len2==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(p.charAt(j-<span class="number">2</span>)==s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">2</span>)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                      dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">1</span>] || dp[i][j-<span class="number">2</span>];   <span class="comment">//匹配多字符  匹配一个字符  匹配空字符</span></span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = (p.charAt(j-<span class="number">1</span>)==s.charAt(i-<span class="number">1</span>)) &amp;&amp; dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里，关于这两道动态规划的题就结束了，不过很大可能，下次遇到，我还是，，呵呵，你懂的</p><p>至于番剧嘛，在追了在追了，对了，不得不吹下斗破的三年之约是真的好看（可能有人会说，好看，我看你只是馋女王的身子～）么的错！！好看的都是我老婆～</p><img data-src="https://cdn.makiru.top/images/20211114105939.jpg" /><img data-src="https://cdn.makiru.top/images/20211114105915.jpg" /><p>我就问，这腰谁不喜欢～～～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再也不搞什么超分了～</title>
      <link href="/blog/article/2968c150.html"/>
      <url>/blog/article/2968c150.html</url>
      
        <content type="html"><![CDATA[<p>今天这篇文章呢，主要是想讲讲这几天的难受的事～尤其是正在做的超分的傻逼实验</p><span id="more"></span><p>首先让大家酸一下～</p><p><img data-src="https://cdn.makiru.top/images/node1.png"></p><p>上面这张图呢，是我们实验室一台服务器的配置，咋样，牛逼吧，3090TI哟，本来想的是拿它来跑这个模型，应该是小菜一碟，可是后面发生的事简直让我抓狂</p><p>这还不够？？好，彻底酸吧</p><p><img data-src="https://cdn.makiru.top/images/pc.png"></p><p>嘻嘻嘻，实验室配的电脑，还不错吧～</p><p>好吧，酸也酸过了，说正事，这次本来是要复现一篇paper(Meta-SR- A Magnification-Arbitrary Network for Super-Resolution)里的模型—Meta-SR，看完paper后，感觉还行，结果到我自己来做的时候，简直要命，我是直接跪在开始的环境配置上（可能）</p><p>这个环境，按照作者的要求应该是torch0.4.0，python3.5，好吧，我去配，配之前，我看了下服务器的cuda版本，好吧，11.5，服了，0.4.0版本的torch简直就是古董了，于是乎，我又给服务器装了个cuda9.0，最终是把torch0.4.0啥的都配好了，一运行。。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: cublas runtime error : the GPU program failed to execute at /pytorch/aten/src/THC/THCBlas.cu:249</span><br></pre></td></tr></table></figure><p>这个错，我真的是看烦了，他喵的就一直报这个错，去网上搜了下，说是torch版本与cuda版本不符？？？我一脸黑线～</p><p>于是又跑去看了下cuda版本，没错啊，于是乎，再去搜，卧槽，难不成是RTX30系列的不支持cuda9，因为我看到了有人说RTX30系列不支持cuda10，只支持cuda11。。。没辙了～</p><p>好烦，，用cpu倒是可以跑，难不成用cpu跑？？那不得跑到猴年马月。。。</p><p>烦死了，再也不搞超分了。。。。。各种bug，还用这么老的版本，用新版本还得修改dataloader，改还一直报各种错，烦烦烦</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合总和2—回溯</title>
      <link href="/blog/article/6fe8e850.html"/>
      <url>/blog/article/6fe8e850.html</url>
      
        <content type="html"><![CDATA[<p>今天的这道题依旧是回溯的经典模版，仅用来提醒以后的自己，回溯并不是十分的可怕～</p><p><img data-src="https://cdn.makiru.top/images/image-20211107195630128.png"></p><span id="more"></span><p>顺带闲聊下，今天的上海，天气还是老样子，晴着晴着就开始下雨了，整的我又只能在图书馆里的FamilyMart里弄点吃的了（偷偷吐槽下，是真的不好吃～）</p><p>又是无聊的一天，今天的我是不是比昨天又厉害了点呢？好像也没干啥事，上午的我将自然辩证法的考点写了点，准备开背。。。中午呢，老样子，看番（嘻嘻嘻嘻），下午就开始刷了一道题（就是被这台mac整的，环境咋这么难配）。不知道大家今天又有什么开心难过烦恼的事呢？都可以说给我听的哟～</p><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：解集不能包含重复的组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道题和我博客上的上一道题其实上是很相似的（这也是为啥我可以独自做出来的原因～），从方法上来看，都是经典的回溯，技巧上呢，肯定是包括了上次那道题的防重复设置啦，除此之外，由于这道题中的选择项不可以是无限量的，也就是说列表是会变化的</p><p>因此，可以设置一个标志数组，用来判断某个选择项是否已经被使用过（无论是使用，还是撤销，都必须记得还原标记）</p><p>因为每个选择项只能用一次的原因，上面说的那种防重复设置就会有所缺陷，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line"></span><br><span class="line">首先对选择列表排个序：1,2,2,2,5</span><br><span class="line">(1)往已选列表中添加1，sum = 1，i = 0  [1]</span><br><span class="line">(2)往已选列表中添加2，sum = 3，i = 1  [1,2]</span><br><span class="line">(3)往已选列表中添加2，sum = 5，i = 2  [1,2,2]  符合条件，加入结果</span><br><span class="line">(4)撤销，i = 1 [1,2]</span><br><span class="line">(5)往已选列表中添加2，sum = 5，i = 3  [1,2,2]  重复</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中，第5步中添加的2下标是3，在此之前并未被使用过，因此如果按照之前的防重复设置，不会被排除，所以需要重新设计一下</p><p>可以看出，上面的例子中重复数字是在撤销后再次选择时发生的，当然，可能也会在回溯到顶点的时候出现这种情况，比如说：[1,1,2,5,6,7,10]，target &#x3D; 8，开始以1往下走，会得到[1,2,5]，当1结束后，也就是已选列表空的时候，会以第二个1为顶点，继续往下走，这样又会得到一次[1,2,5]</p><p>因此，既然是两者都是在撤销之后，继续添加下一个数的时候出现这种情况，那么，只要跳过与当前撤销值相等的选项不就可以了嘛</p><p>注意：<font color=red>什么时候会撤销呢？只有当回溯返回后，才会撤销，也就是说要么当前已选列表符合条件，撤销末尾两个值（两个值的原因很简单，因为撤销末尾值后，如果还想符合条件，肯定是加入一个和撤销值一样的数，那样直接重复），要么就是目前的已选列表不管怎么选都不可能再符合条件，撤销末尾的值（一般是撤销两个，因为将选择列表排序后，如果一开始的末尾数不行，加上下一个数肯定不行）</font></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Boolean[] tag = <span class="keyword">new</span> <span class="title class_">Boolean</span>[candidates.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tag.length;i++)&#123;</span><br><span class="line">        tag[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtrack(candidates,target,<span class="number">0</span>,ans,ret,<span class="number">0</span>,tag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, List&lt;Integer&gt; ans, List&lt;List&lt;Integer&gt;&gt; ret, <span class="type">int</span> begin, Boolean[] tag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans);</span><br><span class="line">        ret.add(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[i] == <span class="literal">true</span>)&#123;</span><br><span class="line">            ans.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            tag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            tag[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(candidates,target,sum,ans,ret,i,tag);</span><br><span class="line">        ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tag[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; candidates.length-<span class="number">1</span> &amp;&amp; candidates[i+<span class="number">1</span>] == candidates[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有一个地方没怎么写好，大家可以自己去改下，就是当目前的已选列表符合条件后，返回后撤销的时候，一定会撤销两个值（可以这么设计，在代码开头，再加个判断，如果sum&gt;target，直接return，然后呢，将for循环中的sum&gt;target改为sum&gt;&#x3D;target，并放在回溯的后面即可）</p><blockquote><p>老实说，回溯可以这么来想，凡是回溯这行代码之前的，总是会被执行，回溯之后的代码，只有return后才会被执行（可能是符合条件，也可能是再也不可能符合条件）</p></blockquote><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>又到8:30了，时间真的好快，快的我都追不上了～</p><p>转眼间，我的研究生生活好像过了不少了啊，，可是未来还是如雾般难以捉摸，（开心好难～）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合总和—回溯和剪枝</title>
      <link href="/blog/article/21b89b0d.html"/>
      <url>/blog/article/21b89b0d.html</url>
      
        <content type="html"><![CDATA[<p>今天刷的这道题其实上是不难的，只是想拿出来说明一下其中可以在以后做题中运用的地方，也就是这道题的闪光点</p><p>至于为啥今天博主太阳从西边起来，竟然刷起了题（别问，问就是在图书馆看了半个小时的番，心里有愧～）</p><p><img data-src="https://cdn.makiru.top/images/image-20211105200752075.png"></p><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>今天我做的题意外的竟然和上次的解数独是一种方法，没错，就是回溯（偷偷瞅了一眼，下一题好像还是回溯）</p><p>回溯这种方法说到底还是一种暴力解题的思路（只是名字好听了点罢了，还有就是用了树的思路）</p><ol><li><p>题目内容：</p><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p><p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p></li><li><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题一眼看过去，首先应该得画出这张图出来（以上面的第二个例子来讲）：</p><img data-src="https://cdn.makiru.top/images/image-20211105201615581.jpeg" alt="" style="zoom: 16%;" /><p>也就是一棵多叉树的结构，因为需要找到所有合适的组合，并且选择列表是不会变化的（这句话在后面的剪枝中会被改变），所以利用这棵树就可以找到所有合适的组合</p><p>当然，肯定会有人问，那这棵树不就会无限向下延伸的嘛？话虽是这么说没错，不过可以利用剪枝啊，首先往下剪枝，只要当前路径上的sum大于target，就不往下走了不就好了；既然前面是往下剪枝，那肯定有其他剪枝啦，没错，可以想想看，同一层上，如果我们把选择列表从小到大排个序，比如说，还是以上图举例，我们当前路径上是2，3，3，sum是8也就等于target，那就可以将该路径放入结果中，再回溯，将末尾的3删掉，加入下一个选择5，想想看，这步操作有必要吗，<font color=red>我们前面的3刚好加上去是target，那么比3大的5加上去肯定比target大，所以可以直接将3删掉后，break掉，返回再将末尾的3（倒数第二个）删掉，路径变为2，也就是放回到了图中的第一棵树的根节点处，计算2下面的5分支</font></p><p>再想一个问题（该题的精髓之一），我们第一棵树下会找到一个路径2，3，3，进入第二棵树后，会找到3，2，3；3，3，2，这就重复了，因此得想办法去重，一开始我的思路很直接：要么Hashset，要么排序判断结果中有没有该路径。结果，AC是AC了，只是复杂度太高了（过多的排序）</p><p>仔细分析上图，重复的原因是在哪里，很容易看出来，因为在第二棵树中，我们以3开头，往下找，只要路径中出现了2，就可能会重复，为什么呢，<font color=red>因为路径包含2且符合条件的在第一棵树中都已经找出来了</font>,所以可以设计在后面的树中找寻时，直接跳过前面找过的树的根节点，比如说，第二棵树，我们将选择列表中的2直接去掉即可，第三棵树直接将2，3去掉即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>具体的代码，其中的去重部分在回溯函数中的begin控制上，表示回溯到路径为空时，下一步在选择列表中选择的第一个数的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">    backtrack(candidates,target,<span class="number">0</span>,ans,ret,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, List&lt;Integer&gt; ans, List&lt;List&lt;Integer&gt;&gt; ret, <span class="type">int</span> begin)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans);</span><br><span class="line">        ret.add(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">//适当剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        ans.add(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backtrack(candidates,target,sum,ans,ret,i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="comment">//后面的不用尝试了</span></span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销</span></span><br><span class="line">        ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是博主做这道题的一些小想法啦，希望能帮助一些和我以前一样对回溯总是想不懂的同学啦，至于开头说的在图书馆里看的那部番呢，不是我主追的那部，图书馆这部呢，是我之前看断掉的一部番（因为各种不可抗力原因啦），也很有趣的，叫做《<strong>带着智能手机闯荡异世界</strong>》</p><p>有兴趣的小伙伴也可以去看看（很有意思的～）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>女神宿舍的宿管君</title>
      <link href="/blog/article/d210c93b.html"/>
      <url>/blog/article/d210c93b.html</url>
      
        <content type="html"><![CDATA[<p>鸽了太久的番剧，它终于又回来啦～</p><img data-src="https://cdn.makiru.top/images/20211028100002.jpg" style="zoom: 25%;" /><span id="more"></span><p>今天要讲的番呢，18岁以下的请绕道（大家懂得。。。）</p><p>番名就叫做《女神宿舍的宿管君》，一看题目，相信那些老二次元的宅男就一定能闻到福利番的气味了，没错，这真的就是一部专门给各位lsp的福利。我相信没有一个lsp能够抵抗住这部番的吸引。</p><p>其实呢，刚开始看这部番的时候，我还以为自己走错了网站，，因为番剧的开篇就是各种名场面，比如：</p><img data-src="https://cdn.makiru.top/images/20211006104418.jpg" style="zoom:50%;" /><p>关于这种场面在这部番里，嗯～是很常见的，lsp一定会满意的（我真的不知道这部番的制作人是一个怎样的人）</p><p>废话不多说，就简单介绍下这部番的大概内容吧（其实我也还没看完，还有几集，得慢慢看）。我们的男主<strong>南云孝士</strong>是一个幸运儿，他的家因为失火而导致无家可归，在路上流浪的时候，就遇到了我们的实验人<strong>和知米涅儿</strong>（因为这位女神呢，经常爱做危险实验），于是就被领回了一个叫做女神宿舍的地方，在这个宿舍里住着的都是被外界称为有问题的人。米涅儿让孝士先去洗个澡，结果就出现了上面这幅图的场景（这只是一小部分哟，还有其他特写）。</p><p>后面嘛，男主就在这个女神宿舍当起了宿管，负责众人的日常起居，再介绍下这几个有问题的女神吧：</p><p>白毛<strong>八月朔日赛勒涅</strong>是是一名面摊少女，似乎有嗜睡症的样子。能使用月面科技修复任何东西，前提是要成为本人的仆从，并让其亲吻。总是处于饥饿状态，所以对于任何好吃的食物没有任何抵抗能力。</p><p>黄毛<strong>芙蕾</strong>是一名cosplayer，善于制作cosplay的衣物，喜欢找南云孝士当试穿衣服的对象。弗蕾在街上看到喜欢的身材，就会不分男女，忍不住向对方扑上去量尺寸，或是强迫他人穿上自己制作的衣物，因此在学校有“人肉换装狂”的外号。房间的特征是门口外面堆满一大堆书籍。个性跟米涅儿差不多，属于大而化之被看到裸体也不会害羞的类型。</p><p>红毛<strong>战咲基丽耶</strong>是一名大二生，家里开武馆，有哥哥和弟弟，为家中唯一的女生。升上大学后，看了人生第一本少女漫画，便喜欢上少女漫画。会幻想自己是书中的女主角，之后会非常害羞，并毫无自觉地破坏宿舍的墙壁和地板，恢复正常之后知道自己又弄坏物品时，会慎重道歉并赔偿。精通格斗技，喜欢找南云孝士当练拳对象，因为南云孝士让她想起以前在家里和弟弟玩耍的时光，但每次孝士都差点被她用格斗技勒死。</p><img data-src="https://cdn.makiru.top/images/2021102895834.jpg"><p>粉红毛<strong>早乙女亚典娜</strong>是一名有着恐男症的大一生，在看到好色画面或者被陌生男性触碰时会狂喷鼻血；原先居住在其他宿舍，但在该宿舍撞见其他宿舍人员与男友发生性行为时而爆喷鼻血。之后搬到女神宿舍这间只有女生的宿舍。一开始反对南云孝士成为管理员，并搬离女神寮，但在孝士因自己离开的因素而主动请辞管理员，并离开女神宿舍后，对他放心不下，最后同意南云孝士成为该宿舍管理员。在孝士来到宿舍之后，因看不惯学姐们裸露随意的生活方式，因此当起了宿舍风纪，并要求宿舍的学姐们禁止裸体。非常喜欢被孝士叫成姐姐，疑似为重度弟控。</p><img data-src="https://cdn.makiru.top/images/2021102895904.jpg"><p>上面这位呢，是男主的青梅竹马<strong>香炉野斯提雅</strong>，对南云孝士有好感，得知南云孝士家里失火的时候非常担心，但在孝士面前总会<a href="https://zh.wikipedia.org/wiki/%E5%82%B2%E5%AC%8C">傲娇</a>并为难他，经常做出心口不一的行为，之后会后悔没有讲出心里话。很怕热，对温度非常敏感，会喜欢上南云孝士也是因为南云孝士在幼稚园期间跑去摸冰块摸到冻伤，就为了要和自己牵手一起玩游戏。因在乎南云孝士的工作而前往女神宿舍，并在检验宿舍状况之后，毅然决然成为管理员一职并和早乙女亚典娜共住一室，同时也批判早乙女亚典娜和战咲基丽耶对南云孝士的感情。</p><p>以上就是这部番里出现的几位主角，至于剧情呢，就不全讲了，就讲这些主角去海边的一个有趣的场景吧。斯提雅在海里，被鱼袭击的名场面，或许大家可以猜猜她被袭击了哪里（真的是极其逗）</p><p>有兴趣的小伙伴可以去看看这部番，番剧的链接：<a href="https://www.agefans.cc/detail/20210158">https://www.agefans.cc/detail/20210158</a></p><p>下一部番呢，已经也在预热中，一起期待吧～</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后宫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法-解数独</title>
      <link href="/blog/article/be8e6db9.html"/>
      <url>/blog/article/be8e6db9.html</url>
      
        <content type="html"><![CDATA[<p>今天天气如此之好，怎么能不来刷道leetcode的题呢？额，，解数独？？？什么鬼，虽然第一眼望去，肯定是回溯没错啦，可是我不会用回溯啊，虽然在此之前已经做过好几道回溯的题，可一旦自己写起来还是不太会。。</p><img data-src="https://cdn.makiru.top/images/image-20211028195753895.png" style="zoom:67%;" /><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个待解的数独，求解</p><p>举例：</p><img data-src="https://cdn.makiru.top/images/image-20211028195924788.png" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/image-20211028195952080.png" alt="" style="zoom:50%;" /><h3 id="回溯算法-lt-重点-gt"><a href="#回溯算法-lt-重点-gt" class="headerlink" title="回溯算法&lt;重点&gt;"></a>回溯算法&lt;<font color=red>重点</font>&gt;</h3><p>所谓的回溯算法，实际上就是常说的DFS算法，深度优先搜索算法等等，再实际点就是递归中的一种，对决策树的一种遍历。</p><p>回溯的重点：</p><ol><li>选择的路径（就是你已经选择完，加入结果的路径）</li><li>选择的列表（就是目前当下你还可以选择的有哪些）</li><li>结束的条件（当到达决策树的底层的时候，不再选择的条件）</li></ol><p>代码模版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><font color=red>注意：这里backtrack里的参数不是一定非得这样</font></p><p>重要的部分在于for循环内部，首先是做出选择，然后可能会修改路径，修改选择列表等等，再进行递归，最后撤销回溯</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题，咋一看，可能有点难，实际上，仔细一想，针对每一个待填的空格，无非就只有1-9 9种选择，依次往里试填，找到合适的（假设为k），就往下一个待填空格走</p><p>因此，执行步骤如下：</p><ol><li>遍历行列，确定待填空格A的行列后，依次将1-9试填，找到合适的往下走</li><li>A填完后，下一个空格假设为B，同样，依次1-9试填，找到后，继续往下；如果1-9都不行，那么表示<font color=red>A或者A与A之前的空格都填错了，因此就需要回溯，简单点说，就是往回走，修改前面填过的</font>。修改过程看下一步</li><li>针对当前空格无法填入的问题，回溯修改，首先回溯到A空格，将A中填入的数字k用’.’代替，重新到步骤1中，从k到9继续试填，找到了往下走，如果k-9也没有合适的，表示A之前的空格填错了，继续类推往前修改</li></ol><p>由于这里只需要找到一种解法就可以，因此回溯模版中的返回类型可以用boolean代替</p><p>模版可以填充为下面这种形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">棋盘</span>):</span><br><span class="line">因为只要棋盘填满就可以返回，所以这里可以不设置返回条件</span><br><span class="line">    <span class="keyword">for</span> 每个待填的空格 <span class="keyword">in</span> 棋盘:</span><br><span class="line">      <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表(<span class="number">1</span>-<span class="number">9</span>):</span><br><span class="line">          <span class="keyword">if</span>(选择填入后合适):</span><br><span class="line">            填入（做选择）</span><br><span class="line">            //由于只需要一种解法，因此找到一组能填满棋盘的路径就返回</span><br><span class="line">            <span class="keyword">if</span>(backtrack(棋盘)): <span class="keyword">return</span> true</span><br><span class="line">            //后面某个空格没数字合适填入，就修改当前的空格数字</span><br><span class="line">          撤销选择 </span><br><span class="line">      //没有一个合适的数字能填入，返回false</span><br><span class="line">      <span class="keyword">return</span> false</span><br><span class="line">    //待填的都填完了，返回true</span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    backtrack(board);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> k=<span class="string">&#x27;1&#x27;</span>;k &lt;= <span class="string">&#x27;9&#x27;</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//判断每个数字填入是否合适</span></span><br><span class="line">                    <span class="keyword">if</span>(isValid(board,i,j,k))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(backtrack(board))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//只要找到完全合适的一组，就直接返回，意思是找到填满棋盘的一组就返回</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[row][i] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][col] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> (row/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> (col/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s1;i&lt;(s1+<span class="number">3</span>);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=s2;j&lt;(s2+<span class="number">3</span>);j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>leetcode后面还会有不少回溯类型的题目，希望到时候自己能一次做出来啊</p><p>番剧啥的，等！！这周六周末一定写！！</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的数独</title>
      <link href="/blog/article/181c4103.html"/>
      <url>/blog/article/181c4103.html</url>
      
        <content type="html"><![CDATA[<p>今天是久违的周六，而且天气也非常非常的好，按道理来说，今天的心情也应该是很不错的，可结果又被leetcode给搅乱了。先说好，今天这道题绝对不值得大家来学习，因为它的想法很直接，没有任何转弯，只是写来纪念下我这个憨憨在这道题上的悲惨经历。</p><p>当某个你看到这篇文章的时候，可以猜到我落笔这篇文章的时候是在哪嘛？？嘿嘿，我在图书馆里，至于为什么作为研究生的我不去自己的实验室专用工位，原因呢，很简单，因为实验室里的氛围太活跃了，好像不太适合我。呃，说了不少的废话。。。</p><img data-src="https://cdn.makiru.top/images/image-20211023105750410.png" style="zoom: 67%;" /><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>原题比较长，我就不敲那么多字了，简单点来说，就是需要判断一个9x9的数独是否有效，有效的标准是每行，每列，每个3x3中的数字不得重复，当然，3x3的方块是指从边缘计算开始，也就是说一共有9个方块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><h3 id="我的最初解法"><a href="#我的最初解法" class="headerlink" title="我的最初解法"></a>我的最初解法</h3><p>因为思路比较直接，我想都没想，就直接开干，不就是每行每列加每个方块嘛，我写三个函数来检验不就行了，于是，我真的这么做了（后来才知道自己当时得有多傻）</p><p>除此之外，关于数字是否重复我使用的是哈希表，具体代码如下（千万别笑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isColOk(board) &amp;&amp; isRowOk(board) &amp;&amp; isSquareOk(board))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRowOk</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map_temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map_temp.put(board[i][j],map_temp.getOrDefault(board[i][j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map_temp.get(board[i][j])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isColOk</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map_temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map_temp.put(board[i][j],map_temp.getOrDefault(board[i][j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map_temp.get(board[i][j])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSquareOk</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">3</span>, col = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(nums&lt;<span class="number">9</span>)&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;row)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;col)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(board[i][j],map.getOrDefault(board[i][j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(board[i][j])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j = col - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">9</span>)&#123;</span><br><span class="line">            i = row;</span><br><span class="line">            row += <span class="number">3</span>;</span><br><span class="line">            col = <span class="number">3</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = col;</span><br><span class="line">            col += <span class="number">3</span>;</span><br><span class="line">            i = row - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm,说过的，不许笑，没错，我直接将这个9x9的二维数组遍历了三次，结果可想而之：</p><img data-src="https://cdn.makiru.top/images/20211022111540.png" style="zoom:50%;" /><h3 id="最后的思路"><a href="#最后的思路" class="headerlink" title="最后的思路"></a>最后的思路</h3><p>后来，其实也就是第二天（因为我几乎都是晚上才会刷道题解解闷），我想既然复杂度这么高，干脆直接遍历一次不就好了，于是，我直接遍历一次二维数组，并且在遍历的过程中，将每个非’.’的字符写入先前的标记数组里（<font color=red>注意：这里我并没有采用哈希表来写了，因为哈希表实在是太难写了，我就直接用三个二维数组作为标记数组来用</font>），写入后，判断三个标记数组中关于这个字符的值是否大于1，大于1直接退出，否则继续，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历一次</span></span><br><span class="line">    <span class="type">int</span>[][] row = <span class="keyword">new</span> <span class="title class_">int</span>[board.length][<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[][] col = <span class="keyword">new</span> <span class="title class_">int</span>[board[<span class="number">0</span>].length][<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[][] square = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> (i/<span class="number">3</span>)*<span class="number">3</span>+(j/<span class="number">3</span>);</span><br><span class="line">                row[i][board[i][j]-<span class="string">&#x27;0&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">                col[j][board[i][j]-<span class="string">&#x27;0&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">                square[temp][board[i][j]-<span class="string">&#x27;0&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断</span></span><br><span class="line">                <span class="keyword">if</span>(row[i][board[i][j]-<span class="string">&#x27;0&#x27;</span>]&gt;<span class="number">1</span> || col[j][board[i][j]-<span class="string">&#x27;0&#x27;</span>]&gt;<span class="number">1</span> || square[temp][board[i][j]-<span class="string">&#x27;0&#x27;</span>]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>今天这篇文章呢，主要是用来打发下我周六的上午，因为，，我好困，论文论文看不下去，项目项目不想写，哎，我好想躺平（不可能的，，因为我还有好多想做的事没去做）</p><p>番嘛，再等等，快了快了，再过段时间不就是万圣夜了嘛，不知道大家有没有什么打算啊？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法那点事～</title>
      <link href="/blog/article/78ec962b.html"/>
      <url>/blog/article/78ec962b.html</url>
      
        <content type="html"><![CDATA[<p>今天呢，因为这几天做了一些关于二分法的题，就想着写篇文章记录一下对二分法的几种常用方法。实际上的原因是我怕自己过几天就忘了，所以写下防忘（其实我已经在onenote上做好笔记了，只是为了随时随地能看到，加深印象而已）</p><img data-src="https://cdn.makiru.top/images/image-20211019135323697.png" style="zoom: 67%;" /><span id="more"></span><h3 id="二分法的模版"><a href="#二分法的模版" class="headerlink" title="二分法的模版"></a>二分法的模版</h3><p>相信很多人都曾用过这个方法，因为它的时间复杂度是很低的，在一般情况下它的复杂度能够达到log(n)，因此很适合在有序的列表里进行元素的查找</p><p>那么，二分法的基本模版又是怎样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>注意：代码片段里的省略号处都是需要自己注意填写的地方</font></p><p>至于mid的计算方式：left + (right - left) &#x2F; 2是因为防止left + right溢出</p><h3 id="查找指定元素"><a href="#查找指定元素" class="headerlink" title="查找指定元素"></a>查找指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，注意下，这里的right&#x3D;nums.length - 1,表示这里的循环中的每一次搜索区间都是<strong>左闭右闭</strong>的（因为right的值是可以达到的），也正因为是左闭右闭的，所以while的循环条件里需要<strong>添加等号</strong></p><p>其次，由于是左闭右闭，每次循环中，对left与right的赋值都必须是闭合的，也就是说<strong>不能包括mid</strong>（因为mid已经判断过了）</p><h3 id="查找指定元素的最左边界"><a href="#查找指定元素的最左边界" class="headerlink" title="查找指定元素的最左边界"></a>查找指定元素的最左边界</h3><p>题目可能有点拗口，简单点来说，就是找到<font color=red>第一个大于等于指定元素的下标</font>（为什么会大于呢，因为如果没有这个元素，就会找第一个大于这个元素的下标值，比如[2,3,4,6,7]，target&#x3D;5，那么找到的值就是下标3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">left_Bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle]&gt;=target)&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;target)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">//if(left==nums.length) return -1;</span></span><br><span class="line">    <span class="comment">//return (nums[left]==target)?left:-1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：最后两行是指如果没有这个元素，就返回-1，有的话就返回left</p><p>解释：</p><ol><li>平时如果是搜索最左边界或者最右边界，就使用左闭右开（right &#x3D; nums.length），因为这样返回值更容易理解，为什么呢，因为左闭右开，表示while循环条件是不带等号，那么退出的时候就一定是left&#x3D;right的时候退出循环，试想两种极端情况：left一直不动，right一直动，最后返回值就是left&#x3D;0；right一直不动，left一直动，最后返回值就是left &#x3D; right &#x3D; nums.length。所以返回值就在[0,nums.length]</li><li><font color=red>由于是搜索最左边界，那么当middle的值等于target的时候，不直接返回，而是继续将right&#x3D;middle(或者right &#x3D; middle - 1，左闭右闭)，继续向左逼近</font></li><li>最后，返回值方面就看当middle等于target的时候，自己写的right赋值是什么了，比如说，right&#x3D;middle，这就表示返回值是left(或者right，两者相等)，如果是right &#x3D; middle - 1（这是将区间设置为左闭右闭的情况，不常用）,那么返回值就是lef t+ 1(right + 1)</li><li>如果要求没有该元素，返回-1，就判断我们返回的值left，如果等于nums.length，表示target比所有值都大，导致left不断向右移动；如果等于0，则表示target小于等于第一个值，需要判断第一个值是否等于target再进行返回</li></ol><h3 id="查找指定元素的最右边界"><a href="#查找指定元素的最右边界" class="headerlink" title="查找指定元素的最右边界"></a>查找指定元素的最右边界</h3><p>题目的实际意思，简单点来说，就是找到第一个大于指定元素的下标值，举个例说：[1,2,3,3,3,4,5]，target&#x3D;3</p><p>，那么返回值就是下标值5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle]&lt;=target)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> left-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if(left == 0) return -1;</span></span><br><span class="line">    <span class="comment">//return (nums[left-1]==target)?left-1:-1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>首先，这里也是使用的左闭右开（right&#x3D;nums.length），因此循环条件不带等号，right&#x3D;middle(right的赋值也需要是开的，middle已经判断过，[left,middle)  )，left&#x3D;middle + 1(left的赋值需要是闭的，[middle+1,right)  )</li><li><font color=red>当middle的值等于target的时候，不急着返回，而是将left继续向右逼近（因为找的是最右边界），left &#x3D; middle + 1</font></li><li>返回值方面，看middle等于target情况下的赋值：left &#x3D; middle + 1,所以最后返回的是left - 1(middle &#x3D; left - 1)</li><li>最后，如果需要元素不在则返回-1，需要根据left-1的值来判断，如果left&#x3D;0，那么left-1就越界，直接返回-1，如果left是nums.length，则需要判断nums.length-1的位置的值与target是否相等</li></ol><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我个人对二分法目前最常用的三种形式的理解，肯定是很粗浅的啦，望大佬勿喷～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑题—最长有效括号</title>
      <link href="/blog/article/62749c37.html"/>
      <url>/blog/article/62749c37.html</url>
      
        <content type="html"><![CDATA[<p>别再问我为啥这几天疯狂写博客了，其实上也算不上是写博客吧。一方面主要是想给自己增加点记忆，对大佬的做法能掌握的更熟点，理解的更透测点；另一方面是想给以后的自己看看以前的他是多么的傻</p><p>今天想讲的是一道关于查找有效括号的最长长度问题，说之前，我还是得吐槽一下我自己，为啥我这么笨，，这么多的题都不会写</p><img data-src="https://cdn.makiru.top/images/image-20211015190233378.jpeg" alt="" style="zoom: 33%;" /><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个只包含’(‘和’)’的字符串，找出最长有效的括号子串长度（必须连续，格式正确）</p><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一开始，我看这题竟然还是个困难题，心想，我去，现在困难题都这么简单了么，直接上手就是一顿操作，提交，结果傻眼了。后来仔细一看，原来我写的是求有效括号数（想撞墙）。</p><p>接着，就是直线思路：既然是跟括号有关，那肯定逃不了栈的使用啊，接着就是噩梦的起点，我一直尝试将字符串中的字符，是(就入栈，)则讨论分析，一眼看起来也没啥问题对吧，正常人不都这么想的嘛（可能世界上就我一个不正常人）。但是对于是)的情况我怎么都分析不出来，首先，)肯定是需要将栈顶的(弹出，并且计数，但是怎么判断是最大的长度呢？栈空就是嘛？显然不行，因为可能栈永远也没法空，只要第一个是(且无法匹配就行。</p><p>既然这样，又该怎么办呢？那就直接判断栈要么为空或者栈底为(时，就将目前的计数和之前的最大值中选择一个赋给最大值；接着，又出现了一个问题，字符串中间出现)无法匹配怎么办，这时计数肯定是需要暂停的，从无法匹配的字符下一个字符继续（但是事实上，这是没法判断的，<font color="red">因为我们对)字符的处理是不入栈，只是和栈顶比较</font>&gt;）</p><p>所以说，目前的问题就是：存在不匹配的(，肯定会在栈底累积，不匹配的)无法处理，判断倒是可以，直接利用当前栈顶是否存在(即可，没有表示无法匹配（写到这里，我竟然还对自己的思路抱有侥幸心理，又去试了一次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] s1 = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.push(s1[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                stack.push(s1[i]);    <span class="comment">//表示是未匹配成功的右括号</span></span><br><span class="line">                max = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(max&gt;ans)&#123;</span><br><span class="line">                    ans = max;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现，，我对无法匹配的左括号没法处理，因为我无法判断一个左括号是否能被匹配，以至于我不知道代码里的max在栈内还有左括号的时候该不该赋为0（进行下一轮计数，被隔断了）</p><p>于是，我针对左括号无法判断是否可以匹配这个问题，使出了大招，没错，就是再写个函数用来判断从当前i（左括号）处，向后遍历，用一个新的栈操作（懂了吧，不懂？看代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">    stack.push(s1[i]);</span><br><span class="line">    <span class="comment">//判断左括号是否能被匹配</span></span><br><span class="line">    <span class="keyword">if</span>(!left_is_ok(s1,i))&#123;</span><br><span class="line">      max = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//无法匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">left_is_ok</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">  Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">      stack.push(s[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">      <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懂了吧。。。。</p><p>虽然是通过了，但是，，结果却惨不忍睹：</p><img data-src="https://cdn.makiru.top/images/image-20211015220123807.png" alt="" style="zoom:50%;" /><p>（各路大佬别笑）</p><h3 id="大佬思路1"><a href="#大佬思路1" class="headerlink" title="大佬思路1"></a>大佬思路1</h3><p>依旧是利用栈，但是这个栈里存的不是s中的左右括号，而是括号的下标，这样就可以直接利用下标值计算长度了，说再多不如举个例子：</p><p>首先先初始化栈，需要在栈底添加一个可以区别任何其他字符的下标（-1），这样做的原因是因为在匹配中如果存在右括号不匹配，意思就是说栈里没有左括号与其匹配了，那接下来后面的子串里的有效序列我们就没法计算长度了（因为这个有效子串的开始下标是多少我们没有记录—开始下标也就是无法匹配的右括号下标），注意：<font color=red>一般的右括号我们是绝对不入栈的，只有无法匹配的才会入栈</font></p><p>比如说：(()))()，下标4的)则无法匹配，执行流程如下：</p><p> (：0入栈</p><p>(：1入栈</p><p>)：2，栈顶出栈，计算长度max &#x3D; 当前的i减去栈顶index(注意，不是刚才出栈的，是出栈后的栈顶) &#x3D; 2</p><p>)：3，栈顶出栈，计算长度max，这时发现栈空了，因此我们需要在栈底初始化时放个-1，这样，max &#x3D; 3 - (-1) &#x3D; 4 </p><p>)：4，栈顶出栈（此刻栈里只有个-1，因此出栈），发现栈底是空的，表示这个右括号无法匹配，所以直接将该右括号的4 入栈代替之前的-1</p><p>(：5，入栈</p><p>)：6，出栈（此刻栈里只有4），计算max &#x3D; Math.max(max,6-4) &#x3D; 4</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>) || s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] s1 = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                stack.push(i);      <span class="comment">//表示只有右边，永远不会被匹配到</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max, i - stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路里，比较精彩的地方有：在栈底一开始放个-1，用来判断右括号的无法匹配，只有当栈里只有-1，且当前字符是)，出栈才会造成栈空，这时便让这个)的下标代替-1，继续判断其他右括号，同时可以用来计算这个无法匹配)后面的子串里的有效括号长度（作为开头）</p><h3 id="大佬思路2"><a href="#大佬思路2" class="headerlink" title="大佬思路2"></a>大佬思路2</h3><p>这个思路，怎么说呢，真的是很难想到，如果我不是看了解析，我可能想破头也不会往这方面去想</p><p>思路大概上是这样的，将无法匹配的字符全部标记为1，能匹配的全部标记为0（利用栈很容易实现），标记完后，就是计算最长的0序列的长度</p><p>至于，代码就靠大家自己去写啦</p><h3 id="大佬思路3"><a href="#大佬思路3" class="headerlink" title="大佬思路3"></a>大佬思路3</h3><p>看了这个大佬的思路后，我才发现原来这是一道dp问题，气的我啊，都想撞墙</p><p>首先定义dp数组，dp[i]表示以下标为i的字符结尾的有效括号的最长长度（注意理解，举个例子，())，这里的i&#x3D;2时，dp[2]&#x3D;0）</p><p>遍历s字符串 </p><ol><li>如果当前字符为(，则直接dp设置为0</li><li>如果为)，则需要判断；如果i-1为(，则刚好可以与i处的)匹配，则dp[i] &#x3D;     dp[i-2] + 2；如果i-1为)，则需要往前查找，假设i应该匹配的位置是j，则j &#x3D;     i-1-dp[i-1]，如果j处为)，则直接dp[i] &#x3D; 0，否则，dp[i] &#x3D;     dp[j-1] + dp[i-1] + 2</li></ol><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span> || s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    Arrays.fill(dp,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] s1 = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; s1[<span class="number">0</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//判断s1[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(s1[i-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span> - dp[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; s1[j]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = dp[j-<span class="number">1</span>] + dp[i-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span> &amp;&amp; s1[j]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;ans)&#123;</span><br><span class="line">            ans = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>唉，难受啊，每次都能在评论区看到和我同病相怜的，怀疑自己的脑袋是怎么长的，希望下一次的博客是很久之后了（并且会是一部关于番剧的文章）</p><p>偷偷的告诉你们，，，我最近在追番哦，名字嘛，“女神宿舍的宿管君”以及“进化果实～不知不觉踏上胜利的人生～”，等看完了就写，别急～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串联所有单词的子串</title>
      <link href="/blog/article/44658eea.html"/>
      <url>/blog/article/44658eea.html</url>
      
        <content type="html"><![CDATA[<p>别问为啥距离昨天的两数相除，我这么快就又搬了一题上来，问就是我太菜（是真的菜，，咋都这么难）</p><p>今天，，其实昨天做的这道题—串联所有单词的子串，一直做到今天上午，最终还是输在了效率上，为啥子我的代码总是运行的这么慢？？或许这就是大佬与我这种菜鸡的区别所在</p><img data-src="https://cdn.makiru.top/images/image-20211013105940581.jpeg" alt="" style="zoom: 33%;" /><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个字符串s和一些长度相等的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。</p><p>注意，子串要与words中的单词完全匹配，中间不能有其他字符，不考虑串联顺序</p><p>举例：</p><pre><code>    输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]    输出：[0,9]    解释：    从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。    输出的顺序不重要, [9,0] 也是有效答案。</code></pre><h3 id="我的思路1"><a href="#我的思路1" class="headerlink" title="我的思路1"></a>我的思路1</h3><p>首先说下，我的思路在leetcode中也通过了，只是在效率上，实在是看不过去，刷新了我刷题上运行效率的下限（运行时间在2000左右，内存在38左右）</p><p>我的思路比较简单，i指向s的开头，j指向words的第一个元素，利用一个和words同样大小的bool数组表示元素是否已被使用。然后，就是从当前的i向后判断words大小个单词，如果全部符合，就记录下i，否则，就直接break，将i加1。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">g</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;words.length;m++)&#123;</span><br><span class="line">        g += words[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(g.equals(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean[] tag = <span class="keyword">new</span> <span class="title class_">Boolean</span>[words.length];</span><br><span class="line">    Arrays.fill(tag,Boolean.FALSE);</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.length())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i_temp</span> <span class="operator">=</span> i;      <span class="comment">//（1）</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;words.length &amp;&amp; i+len&lt;=s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.substring(i,i+len).equals(words[j]) &amp;&amp; tag[j]!=<span class="literal">true</span>)&#123;</span><br><span class="line">                tag[j] = <span class="literal">true</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i = i + len;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Arrays.asList(tag).contains(<span class="literal">false</span>))&#123;</span><br><span class="line">            ans.add(i_temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(tag,Boolean.FALSE);</span><br><span class="line">      i = i_temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实导致这个算法很慢的原因在于，我对i的移动范围太大，而且我没有一次性移动words的总长度，只是一个单词的长度</p><p>优化：可以在（1）后面直接将i到i+len_sum的子串提出来，再利用while循环判断该子串里是否包含了words里的所有单词，是则记录下当前的i，不是就恢复标志数组tag，并跳出while循环，直接将i加1</p><h3 id="我的思路2"><a href="#我的思路2" class="headerlink" title="我的思路2"></a>我的思路2</h3><p>按照刚才思路一后的优化，加上代替tag数组的HashMap，得出了下面的思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || words==<span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">word_num</span> <span class="operator">=</span> words.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one_word</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len_sum</span> <span class="operator">=</span> word_num * one_word;   <span class="comment">//窗口大小</span></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">        map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.length()-len_sum;i++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">word_temp</span> <span class="operator">=</span> s.substring(i,i+len_sum);</span><br><span class="line">        HashMap&lt;String,Integer&gt; map_temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(map);</span><br><span class="line">        <span class="comment">//判断该窗口中的单词是否刚好为给的单词</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j+one_word&lt;=len_sum)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> word_temp.substring(j,j+one_word);</span><br><span class="line">            <span class="keyword">if</span>(map_temp.containsKey(word) &amp;&amp; map_temp.get(word)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                map_temp.put(word,map_temp.get(word)-<span class="number">1</span>);</span><br><span class="line">                j = j + one_word;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路里，精彩的地方就是<strong>利用HashMap记录words里每个单词的个数</strong>，便于判断我们截取下来的子串里的单词是否为words里的，以及是否被使用过的（用过一次就将个数减1，直到0）</p><h3 id="大佬的思路"><a href="#大佬的思路" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>关于这种对字符串与其子串的类似的题目，可以想想<strong>滑动窗口</strong>的方法是否可以用</p><p>大致上的思路其实是类似的，只是这个思路的外循环只需要经历单个words里的单词长度，因为这样s里所有的单词都会被访问到</p><p>先看代码吧，边看代码边解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || words==<span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one_word</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">word_num</span> <span class="operator">=</span> words.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">        map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;one_word;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map_temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right+one_word&lt;=len)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(right,right+one_word);</span><br><span class="line">            right += one_word;</span><br><span class="line">            map_temp.put(word,map_temp.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//关键</span></span><br><span class="line">            <span class="keyword">while</span>(map_temp.getOrDefault(word,<span class="number">0</span>)&gt;map.getOrDefault(word,<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word_temp</span> <span class="operator">=</span> s.substring(left,left+one_word);</span><br><span class="line">                map_temp.put(word_temp,map_temp.get(word_temp)-<span class="number">1</span>);</span><br><span class="line">                left += one_word;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==word_num)&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，依旧是利用HashMap（map1）将单词的个数记录下来；接着，在循环的内部，首先定义left与right，left是指当前窗口的左边，right自然就是右边，新建一个map2，存放截取的子串里的单词个数（可能会有map1里没有的，没关系，继续看），count是用来记录当前子串里已经加入map2的个数</p><p>对当前截取子串的操作：将子串里的单词放进map2，并记录其次数，同时right移动，count++，再将该单词在map2里的次数与map1里比较，如果大于，则表明当前单词在该窗口中要么已经用完了，要么直接map1里没有该单词，于是当前的left-right窗口不行，便移动left，将窗口整体向后移，至于移到什么地方呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;wordgoodgoodgoodbestword&quot;</span>;</span><br><span class="line">String[] d = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;word&quot;</span>,<span class="string">&quot;good&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;good&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>以这个例子举例说明：当left在0，right移到第三个good的时候，会发现good用完了，那么就需要移动left，自然而然想到，需要将当前窗口移到第三个good刚好将good用完的地方，也就是将left移到第二个good的开头处。</p><p>实际上，如果当前的子串单词是map1里没有的，那么就可以直接将left移到right（该没有单词的下一个单词的开头）处，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;wordgoodgaodgoodbestword&quot;</span>;</span><br><span class="line">String[] d = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;word&quot;</span>,<span class="string">&quot;good&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;good&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>当前left在0，right在8，获取”goad”子串后，right&#x3D;12，发现”goad”在map1里没有，那么直接可以将left移到12</p><p>一定要记住：<font color=red>我们的每一轮开始都是有个基准的，比如说，上面这个例子的基准就是当前的i&#x3D;0，意思就是说，必须从0开始往后每四个是一个单词</font></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是我这个菜鸡在这道题上的一点理解，还是得膜拜各种大佬@—@</p><p>（希望明天的题目不至于再让我来写一篇博客记录了）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数相除</title>
      <link href="/blog/article/d9de2002.html"/>
      <url>/blog/article/d9de2002.html</url>
      
        <content type="html"><![CDATA[<p>从今天开始学习一下其他大佬，，在自己的小破站上记录一下自己在leetcode上遇到的坑和一些超级大佬的思想。</p><p>今天由于是第一次记录刷题的经验（原本我这个小破站是主打各种番剧的，尤其是那种，你懂的(&gt;^ω^&lt;)），可能会有些不足，还望海涵。。。。。</p><img data-src="https://cdn.makiru.top/images/image-20211011133149905.jpeg" alt="" style="zoom: 33%;" /><span id="more"></span><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定两个整数，dividend与divisor，两数相除，不能使用乘法，触法，mod运算，返回商，小数部分向零截断，当除法结果溢出，返回Integer.MAX_VALUE.</p><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>一开始我自然是按照最基本的方法去做，既然乘法与除法等都不让用，那我加法总可以吧，所以一开始我的做法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ans &lt;= dividend)&#123;</span><br><span class="line">ans += divisor;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tag * (k-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>结果嘛，显而易见的只过了两个测试用例，，到了第三个用例，就直接报了超出时间限制的错（很明显）</p><p>接下来，既然超出时间限制，那就加快累加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> divisor;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ans+ans&lt;=dividend)&#123;</span><br><span class="line">ans += ans;</span><br><span class="line">k += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我没有完整写出，举个例子：31&#x2F;3</p><p>3+3&#x3D;6        k&#x3D;2</p><p>6+6&#x3D;12      k&#x3D;4</p><p>12+12&#x3D;24     k&#x3D;8</p><p>24+24&#x3D;48&gt;31</p><p>说明最后的结果一定大于等于8，但是大多少，，我当时并没有想出方法，后面看了大神的方法才知道，先暂时不说</p><p>最后，我的想法就是递归，，可以我写了好久都没递归出来（对于递归我实在没什么法子，，脑袋太笨）</p><h3 id="本题解答思路"><a href="#本题解答思路" class="headerlink" title="本题解答思路"></a>本题解答思路</h3><ul><li><p>最常见的位操作（左移乘2）</p><p>思路上就是将除数不断移位，使其逼近被除数，举个例子：31&#x2F;3</p><p>3&lt;&lt;1 &#x3D; 6</p><p>3&lt;&lt;2 &#x3D; 12</p><p>3&lt;&lt;3 &#x3D; 24</p><p>3&lt;&lt;4 &#x3D; 48 &gt; 31</p><p>被除数&#x3D;被除数-24 &#x3D; 7</p><p>3&lt;&lt;1 &#x3D; 6</p><p>3&lt;&lt;2 &#x3D; 12 &gt; 7</p><p>被除数&#x3D;被除数-6 &#x3D; 1</p><p>1&lt;3</p><p>退出</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span>&#123;</span><br><span class="line">    <span class="comment">//判断符号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// -1表示负，1表示正</span></span><br><span class="line">    <span class="keyword">if</span>((dividend&gt;<span class="number">0</span> &amp;&amp; divisor&lt;<span class="number">0</span>) || (dividend&lt;<span class="number">0</span> &amp;&amp; divisor&gt;<span class="number">0</span>))&#123;</span><br><span class="line">        tag = -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dividend==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//溢出处理</span></span><br><span class="line">    <span class="keyword">if</span>(dividend==Integer.MIN_VALUE &amp;&amp; divisor==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">long</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>) dividend);</span><br><span class="line">    <span class="type">long</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>) divisor);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">//计算结果值</span></span><br><span class="line">    <span class="keyword">while</span> (ans&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d1 &lt; d2&lt;&lt;ans)&#123;</span><br><span class="line">            ans--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k += (<span class="number">1</span>&lt;&lt;ans);</span><br><span class="line">        d1 -= d2&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tag * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(注意，上述代码里的左移位数是直接从31开始往下减，这样可以对较大的数逼近的更快)</p><p>不知道细心的同学有没有发现啥，没错，移位的思想和我之前的第二种想法很像，只是我是加，它是移位</p></li><li><p>累加+递归</p><p>累加的想法就是我那个，至于递归，看看代码就懂了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dividend==Integer.MIN_VALUE &amp;&amp; divisor==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((dividend&lt;<span class="number">0</span> &amp;&amp; divisor&gt;<span class="number">0</span>) || (dividend&gt;<span class="number">0</span> &amp;&amp; divisor&lt;<span class="number">0</span>))&#123;</span><br><span class="line">        tag = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将被除数与除数全部转为负数（负数的范围比正数大）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> dividend&gt;<span class="number">0</span>?-dividend:dividend;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> divisor&gt;<span class="number">0</span>?-divisor:divisor;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> div(a,b);</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b1 + b1 &gt;= a &amp;&amp; b1 + b1 &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b1 += b1;</span><br><span class="line">        ans += ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + div(a - b1,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码里最精彩的地方不是递归，不是累加，而是对溢出的处理：</p><p>首先，现将被除数与除数全部转化为负数，（原因是在32位有符号整数中，负数的范围比正数大）；其次，通过判断b1+b1的符号来判断累加中是否溢出，因为<strong>两个负数累加后溢出一定是正数</strong></p></li></ul><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>  以上就是我在这道题里学到的东西—对溢出的特殊判断，以及我思路上的断线是在哪断的这个问题</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的一些烦心事</title>
      <link href="/blog/article/ff1ef1e.html"/>
      <url>/blog/article/ff1ef1e.html</url>
      
        <content type="html"><![CDATA[<p>在讲述我的烦心事之前，先给大家放一张我老婆大人的美图：</p><img data-src="https://cdn.makiru.top/images/image-20210922102751033.jpeg" style="zoom: 33%;" /><span id="more"></span><p>至于这些天一直没有更的原因嘛，开学的事是真的多（完全没想到）</p><p>刚开始来到学校，我很幸运的被分到了一间三人寝，里面的布局大概是这样的</p><img data-src="https://cdn.makiru.top/images/image-20210922103050914.png" style="zoom:50%;" /><p>而我则是很好运的被分到了右侧的上床下桌，到这里，相信大家就会问了，这有啥烦心的啊，实际上，一开始，我确实蛮开心的，可是后面嘛，不得不说，上铺是真的狗，我根本他喵的不能直起身来（因为实在是太矮了）</p><p>接着，再说一下我们宿舍的位置，我们在所谓的东32栋楼。这个位置嘛，离哪都远（除了河～），每次去食堂，或者去教室，图书馆，甚至电院与研究生院，都不得不骑着小单车</p><p>最近，我一直在为自己的以后做打算，做着做着才发现，原来我自己的未来完全看不清，我不知道以后能做些什么，或者该做些什么。作为一名较为普通的计算机系的研究生（本科与研究生所在的学校嘛，都比较硬），我不知道以后的路咋走。。。</p><p>直到今天，我想清楚了，，以后的路，，就让以后的自己去想吧，现在的我，需要做的就是多学点东西，至少学些以后在工作中能用到的东西（即使用不到，也应该会有些帮助。。。）。所以呢，可爱的小博主最近在学html5，当然，不是为了学前端，主要是为了以后在后端上能够走的轻松点，html5结束后应该就是css啦，js啦，等等～</p><p>给大家看看我这学期的课表吧</p><p><img data-src="https://cdn.makiru.top/images/classTable.png"></p><p>还行吧，，我目前的培养计划呢，主要是两学期，一共要修9门课，目前已经选了5门，我打算下学期再选4门</p><p>写完这篇发牢骚的文章后，，我就得去吃个午饭，屁颠屁颠的去教室坐着，等待下午的最优化了，啊！！！好烦啊，这两天我不知道为啥心情很复杂，奇了怪了</p><p>不过嘛，每个人呢，都会有自己的未来，急也是么用的。</p><p>因此呢，等待我的下一次更新吧（偷偷说下，我这几天其实嘛，一直在看龙族的小说，，不知道有么有人觉得孤独有时也是一种动力～）</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七夕快乐～</title>
      <link href="/blog/article/12a17dbf.html"/>
      <url>/blog/article/12a17dbf.html</url>
      
        <content type="html"><![CDATA[<p>今天是什么日子，想必我就不用说了吧，“七夕！！！”，传说中牛郎织女见面的日子，虽然今天上海是个下雨天，但是我相信并不妨碍他俩见面的，但好像和我关系并不大～扯远了，主要是想纪念下今天开心的一天。</p><p><img data-src="https://cdn.makiru.top/images/zhiwuyuan2.jpeg"></p><span id="more"></span><p>上面这张图呢，是今天和我一起的朋友拍的（当然是个男孩子），宝宝心里苦啊，为啥我没有女朋友啊（原因嘛，因为不想找～），今天早上7点准时在我那小小的床上被闹钟叫醒，然后就是日常的洗漱加早点，因为一起玩的人又不是小姐姐，也就没有想着咋穿咋打扮了（其实一直是这样，哈哈哈），接着便就是赶往汽车站，坐着徐闵线踏上了漫长的路程。。。。</p><p>我俩商量好的集合地点是上交的徐汇校区，我足足坐了两个多小时的车才到了徐汇区，差点坐晕在车上，不过还好，最终还是到了，结果嘛，—我迷路在了前往上交的路上，导航是真的垃圾。。明明几百米我硬是走了十几分钟。到了后发现朋友已经到了，便集合直接去了上海植物园的附近，打算先过去在它附近吃个午饭。</p><p>去了后才发现，我去，原来植物园附近没有吃饭的地～，于是便又是漫长的寻食之路，终于在上海南站的附近找了一家呷浦呷浦，免费打广告，火锅的味道是真的很不错，吃完差不多也就12点多吧，然后就骑着小单车去了植物园，在雨中骑车的感觉是真的很奇妙，有机会大家可以试试（当然不是暴风雨）。</p><p>在植物园里嘛，一开始以为会是蛮无聊的，结果意外的发现了几个室内的温室，有趣的热带植物各种各样，很有意思</p><p><img data-src="https://cdn.makiru.top/images/zhiwuyuan9.jpg"></p><p>这是刚进植物园发现的一朵莲花（这么高的像素，肯定不是我的手机拍的啦，下面的图都不是我手机拍的，，我是不是该换手机了？），还不错吧</p><p><img data-src="https://cdn.makiru.top/images/zhiwuyuan7.jpeg"></p><p>这植物是不是很有意思？其实现场看更有意思的，除了这个以外，比如还有吃虫子的植物，大家应该很熟悉的吧，还有见血封喉的植物哦，一开始还给我吓了一跳呢，还有不少有意思的多肉植物</p><p>温室逛完后，我们便又在植物园里逛了一会，下面几张图是真的很不错！！</p><p><img data-src="https://cdn.makiru.top/images/zhiwuyuan3.jpeg"></p><p>从植物园出来已经差不多两点多了，正好外面也已经开始下起了小雨，我们便坐着公交车加地铁前往了人民广场，当然嘛，去的路上还坐错了公交车，幸亏发现的早～</p><p>到了那边后，本来是想直接去看场电影的，结果，意想不到的事发生了，，那个点的票没了（七夕当然得看爱情片啦—“盛夏未来”），只能看16:45的场次了，不过又得在影院附近瞎逛了，还好影院旁边就是一家大商场，我们在里面把所有的楼层都逛了一遍—厉害吧，不过脚也废了。。。</p><p>终于快到时间了，我俩寻思着下来买点饮料，当然得是最实惠的coco啦，买好后直接奔向影厅，去了才发现，，原来不允许带饮品进去，最后只能寄放在影厅外面的冰箱里（因为是冰的嘛），关于这部电影嘛，吴磊和张子枫主演，剧情还算凑合，还可以吧，也不算多难看（当然也不算多好看）</p><p>看完就到了18:30了，肚子也差不多饿了，所以便火速前往大商场的负一楼，点了一份汉堡套餐（我那份汉堡是真的大，硬生生给我撑饱了），吃完我俩就走着去了上海的特色建筑—东方明珠，这是我大概第三次去了吧（第一次小时候爸妈带着去的，第二次嘛，，和前女友一起去的）</p><p><img data-src="https://cdn.makiru.top/images/PearloftheOrient.jpeg"></p><p>其实这个时候，雨已经开始下了，但是丝毫不影响今日份的开心～外滩上也是有着很多和我们一样心情的游客（当然啦，更多的是一对对的情侣啦，关于这点心里还是很酸的）</p><p>最后，便是前往地铁站各回各家各找各妈啦，然而回去的路上，朋友却因为看手机坐过了站（各位小朋友千万不要学哟），不得不再坐回来（此处笑出了鹅叫～（bushi  &lt;* *&gt;））</p><p>而我也差不多9点多回到了住的地方，洗了个简单的澡，就想着把今日份的开心记录下来，分享给每一个人～</p><p>至于番剧的推荐，，，抱歉大家，我又鸽了，下次必补（&lt;^ ^&gt;）</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七夕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>政宗君的复仇</title>
      <link href="/blog/article/a48e13d7.html"/>
      <url>/blog/article/a48e13d7.html</url>
      
        <content type="html"><![CDATA[<p>今天想和大家谈一谈我昨天晚上终于看完的一部泡面番，其实嘛，也不能完全算泡面番，毕竟人家也还是有很多不错的剧情的，这就需要大家去仔细的看看了，这部番的名字就是这篇博文的题目—政宗君的复仇（超级推荐小情侣一起看哦）</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-11_21-28-17.jpeg"></p><p>就想问，这个女孩可爱不？？？？<span id="more"></span></p><p>没得说，我以后的老婆必须长这样（哈哈哈，开个玩笑），其实，这是我整部番剧中最喜欢的女生，当然，她不是女主～</p><p>整部番大概的情节就是讲述一个小胖墩小时候经常会被人欺负，在一次被欺负的过程中，他被一位女生保护了下来，这就是我们的女主—安达垣爱姬，而这个小胖墩就是我们的男主—真壁政宗（肯定很好奇男主长啥样吧）</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-11_21-26-18.jpeg"></p><p>是不是很可爱，，因为被女主救了，所以小胖子一直和女主玩的很开心，后面小胖子想和女主告白，结果被拒了，然后嘛，便心生恨意，从此走上疯狂锻炼的道路，最后如愿以偿变成了一位身材超级好的帅哥，想先让女主喜欢上自己，自己再狠心地甩掉她，虽然最后的结局可想而知，不过我还是挑一点点说说。</p><p>对了，开头的那位女孩子是女主的仆人，平日里的形象是超级软糯，但是在作为男主师傅的时候，又是极其的高冷，至于软糯嘛，看看这张图就知道了</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-11_21-29-02.jpeg"></p><p>在男主想要向女主复仇的道路上，男主遇见了这位恩师—小岩井吉乃，实际上是因为吉乃知道男主就是小时候的那个小胖子，只是女主不知道而已</p><p>男主先后使出了奉承，欲擒故纵，英雄救美等手法，就在快要成功的时候，意外发生了，一位不速之客出现在了男女主的生活里，她就是我们的藤之宫宁子，说到这位大美女呢，实际上，她小时候是和男主见过的，而且双方的父母是很要好的朋友，宁子呢，小时候也和男主一样胖乎乎的，超级可爱，这里很可惜，没有截到图，大家自己去看看就知道了，宁子突然闯入男主生活，开场就直接白送，但是宁子的心地是真的很善良，本来自己的身体就很虚弱，为了不让朋友担心，还特地假装只是为了养生，虽然在后面的一些情节里，男主还是没有选择宁子，唉，真为宁子感到惋惜，不知道漫画里的结局是咋样的</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-12_22-35-11.jpeg"></p><p>番剧中大家还一起去了海岛上，真的，就这一段，给的福利是超级多的，比如啥美女泳装是必须的啦，情节方面也是没有什么可以挑剔的，在海岛上，男女主终于成为情侣了，虽然是假装的，福利啥的，就给大家看一张图吧，图床空间有限</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-12_22-03-32.jpeg"></p><p>到这里，其实剧情也快结束了，后面嘛，男主自然是没有复仇成功，女主嘛，可能有那么一点点喜欢上男主了，不过在oad情节里，女主是真的直接表达出自己心意了，至于女主长啥样，就是上面这张福利图啦，女主还有一个超级大特点，那就是胃口超级大，饿得非常快，吉乃基本上就是买饭小能手，也正是这个特点被男主抓到了，男主才有机会向女主靠近的。</p><p>整个番剧里，其实还有两个人是很有意思的，一个是朱里小十郎，这个人为什么有意思呢，因为他长得超级像女孩子，但是实际上却是个不折不扣的男孩子，甚至在最后的白雪公主比赛中，担任男主班的白雪公主，说到这里，差点忘记最后的一个重要情节，就是男主的情敌在最后几集里出现了，他叫雅宗兼次，至于为什么能成为情敌呢，因为女主把这个人当成了小时候的男主，原因是兼次现在的体型依旧是个小胖子，兼次主要是想依靠和女主接近来复兴自己已经落没的家族，而双方最后的比拼就是白雪公主表演大比拼，双方的表演人选我应该就不用说了吧（还是说下吧，女主班自然是女主演白雪公主，兼次演王子，男主班就是小十郎演白雪公主，男主演王子）。但是呢，兼次有女主班的班长等人帮助（将男主绑到小房间），而我们的男主也有师傅帮助（当然是同样的招数），就这样，按理来说，双方的表演本应都没法正常进行，不过男主并非一般人，三言两语直接将看守他的人说的痛哭流泪，趁机逃了出来，我们的兼次就没这么幸运了（毕竟绑他的是吉乃师傅），就这样，女主班的王子不见了，最后嘛，可想而知，男主为了不想让这场表演半途而废，就上去替演了女主班的王子（最后还真的吻了白雪公主哟～）故事到这里就真的完结撒花了</p><p>至于前面说的还有一个有意思的人是谁呢，就是男主的妈妈，给大家看张图，看看能不能看出这是男主的妈妈</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-07-11_21-31-10.jpeg"></p><p>是不是很惊讶？这也太萝莉了吧，超级可爱的好不好～虽然还有不少这位萝莉妈妈的图，但是限于空间，还是不放了，后面会放个图片链接，大家可以自己去看</p><p>这部番，总体上来说，已经算得上是我这段时间里看的比较有意思，比较好看的番剧了，还是蛮推荐大家去看看的</p><p>这段时间，博主更新文章的时间不是很固定，因为实验室的一些原因，可能会隔个几天才能更一次，所以很抱歉啦～</p><p>再向大家说说博主最近在做些啥，其实呢，我这段时间白天基本都是在学校的实验室里，上海这些天白天是真的超级热，每天早上7.30我从租的房子里醒过来，然后和室友吃吃饭就坐公交去学校，中间还要走点路，将近9.00到学校，这个点就已经超级热了，最后整的我都不得不撑伞了，唉～</p><p>然后就是在实验室里摸一整天的鱼。。。。</p><p>最后就是晚上9.00左右回来，洗洗就直接睡了，这也是为啥经常断更的原因（最近在做的项目是一个叫做智能计算平台的东东～）</p><p>所以，再次向大家诚恳的抱歉～</p><p>为表歉意，把这部番的一些精彩截图留个链接给大家，下次一定准时更</p><p>番剧截图：下载:<a href="https://qianyan.lanzoui.com/iL2aIrns09c">https://qianyan.lanzoui.com/iL2aIrns09c</a> 密码:48w2</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搞笑 </tag>
            
            <tag> 泡面番 </tag>
            
            <tag> 恋爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fgo泳装-沉底的一次</title>
      <link href="/blog/article/2c5a26ec.html"/>
      <url>/blog/article/2c5a26ec.html</url>
      
        <content type="html"><![CDATA[<img data-src="https://cdn.makiru.top/images/photo_2021-07-11_18-30-17.jpg" alt="" style="zoom:67%;" /><p>首先先说明下为啥这么长时间没有继续更了，原因嘛，待会再说，先告诉大家一个好消息，笔者考上了！！！—研究生，至于是哪所大学嘛，就不细说了，可以猜一下（后面有提示～）<span id="more"></span></p><p>为啥这么久没更了呢，因为我这段时间忙着去上海收拾东西，暑假被研究生导师抓去搬砖，所以这段时间实在是没有时间，还请各位看官见谅哈（不过也积累了不少素材），今天就借这篇文章纪念下我前段时间fgo中极其脸黑的一次，想必大家看到首页的图片也大概猜到一些了，没错！我又又又沉底了～</p><p>这次的活动是每年夏天暑假时期大概率会出的泳装池子，是不是很心动？不心动肯定是假的。。。</p><p>我当时应该是攒了140多个石头，真的是fgo抽卡爽，一直抽一直爽。结果嘛，可想而知，给大家看看我的成果</p><img data-src="https://cdn.makiru.top/images/20210708220343.png" style="zoom: 67%;" /><img data-src="https://cdn.makiru.top/images/20210708220402.png" style="zoom:67%;" /><p>没错！！！就这两张</p><p>我的心好疼，一张好的都没出啊！！！！</p><p>给大家带点福利，看看我之前泳装活动里拿到的剑阶葛饰北斋，超级好看～</p><img data-src="https://cdn.makiru.top/images/20210621001557.png" alt="" style="zoom:67%;" /><p>这几天我也把我的葛饰北斋升到了80级了，长这个样子，也是非常好看的</p><img data-src="https://cdn.makiru.top/images/20210702225435.jpg" alt="" style="zoom:67%;" /><p>说个有意思的事，前面不是说140个石头沉了嘛，结果第二天我登进去之后，发现fgo送了我12个石头，我单次单次的抽，你们猜我抽到了啥（虽然我不喜欢）</p><img data-src="https://cdn.makiru.top/images/photo_2021-07-11_18-43-44.jpg"  /><p>唉，上面就是我心凉的一次经历，不说了，待会还得去搬砖（瞎说的，去做“正经事”），至于笔者去了哪所学校嘛—秘密，就不告诉你们</p><p><img data-src="https://cdn.makiru.top/images/photo_2021-07-11_18-54-52.jpg"></p><p>拜拜啦～下次一定快点更，最近我也看了不少番哟。。。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只有我进入的隐藏地下城</title>
      <link href="/blog/article/18f5132c.html"/>
      <url>/blog/article/18f5132c.html</url>
      
        <content type="html"><![CDATA[<p>今天继续来说说这两天看的动漫吧—《只有我进入的隐藏地下城》，咋说呢，像我这种资深的lsp，看的时候都忍不住各种猥琐笑容，想必大家也能猜出这部番的精彩程度。介绍之前，先放张全家福吧</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-06-04_16-05-09.jpeg"></p><span id="more"></span><p>一开始知道这部番的名字后，还以为又是类似的地下城冒险，不过嘛，看完之后才发现这部番的主题不在于冒险，而在于主角是如何在不知不觉中开起了后宫。与往常一样，先介绍下这部番的大概内容（文章后面有惊喜哟）。我们的男主名叫诺尔，是贫穷贵族（又叫准贵族），在这部番的设定中，公爵是最高的层次。某一天，诺尔幸运的开启了一个藏匿了大量稀有魔物与宝物的隐藏迷宫，并且在迷宫里还拜了个师傅，就是上图中的蓝毛（名字都太难记，就直接色彩代替），蓝毛因为死锁咒被关在这个地下城里已经200多年了，蓝毛给了诺尔几项强大的技能—创作，赋予，编辑。。不得不说这几项技能是真的开挂，创作嘛，顾名思义，就是可以自己创作出自己想要的技能，赋予，就是可以将创作出的技能赋予给别人或者物，编辑就是既可以修改自己技能的属性也可以修改别人的技能属性。你瞧瞧，这不是开挂这是啥，，不过这么强大的技能肯定是需要一定代价的，那就是LP，也就是生命力，LP的存储也是有方法的，额，就是吃好吃的，满足购买欲，以及满足性欲（想必lsp们看到这就猜到了后续情节）。</p><p>在后面的情节中，男主先后用自己的技能帮助一个粉毛（就是下面这个，嘿嘿嘿），救了一位公爵的女儿（好像这个没图。。），不过请准备好纸巾</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-06-04_13-01-53.jpeg"></p><p>接着嘛，就是帮助一个郁金香狮子在地下城找到了自己的好朋友（好朋友变成了僵尸，狮子等了200多年），好朋友回到自己的故乡，而狮子也在诺尔家担负起看门的重任。</p><p>这期间肯定穿插着诺尔攒LP的一些精彩场景，大家有兴趣的可以自己去看看这部番（保证不亏），诺尔一家人打算开个卖各种稀有材料的店铺，可是店面确实重金难求，因此开店就暂时搁置了下来。在一次晚会上，有个叫啥怪盗的发出预言要偷走晚会上的一个啥人鱼之石（好像是这个名字），以及诺尔的青梅竹马（下面有图，黄毛），果不其然，怪盗造成混乱，将黄毛和宝石都偷走了，后宫都被抢了，我们的男主怎么可能不生气呢？直接开挂追上去，一个重力赋予，一个紫电加水炮就把怪盗打下来了，啧啧啧，这就是爱情的力量啊。</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-06-04_14-34-13.jpeg"></p><p>再继续下去，因为救了宝石，所以那个宝石的所有者给了诺尔一个极好的店面，因而店铺也正式开了起来，为了给店铺里找点稀有材料，以及帮自己的负责人增加名次，诺尔再次前往地下城，在这一次，他遇见了一个树之妖精，树之妖精向诺尔求救，原来她的本体被一只蜜蜂在肆意的吸食着魔力，这样下去，她就要消失了。诺尔依旧各种开挂，虽然第一次没打赢，不过第二次在师傅的指导下，借助其他魔物加自己编辑的能力，还是打赢了这只蜜蜂，而诺尔也在树之妖精的帮助下找到了两个宝物。</p><p>最后的情节还是蛮感人的，就是诺尔救师傅，诺尔在地下城中释放了死锁咒的本体，死锁咒此时已经变成了他师傅的模样，只有打败了死锁咒，师傅才能从地下城中出来，在这里，也说明了为啥蓝毛收诺尔为徒弟的原因，原来，200多年之前，有个和诺尔长得很像的人一直想拜蓝毛为师，不过蓝毛没答应，而那个人也是一直没放弃，跟在蓝毛身后，一次，蓝毛告诉他遇到那种超强的哥布林时，只需要用剑刺向它的眼睛就可以了，那个人高兴的说着自己要去试一试，几天之后，蓝毛如往常一般，来到酒馆喝酒，酒馆里的人告诉她她的徒弟出事了，蓝毛急忙前往，结果被告知那个人在超强哥布林手下救下了一个小姑娘，而使用的方法就是她教他的刺向眼睛。蓝毛心里无比自责，如果自己有好好教他的话，情况或许就不一样了。这也是为什么蓝毛一看见诺尔就收了他为徒弟的原因。这个徒弟也是很争气，在不懈的努力与坚持下，和自己的朋友合力除掉了死锁咒，师傅得救了。</p><p>故事到这里也就完一段落了，不得不说这部番是一部好番，大家有兴趣可以去看看，过几天我再讲我现在在看的一部番（也是lsp爱看的那种哟），下面就是惊喜啦</p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-06-04_14-56-34.jpeg"></p><p><img data-src="https://cdn.makiru.top/images/Snipaste_2021-06-04_13-25-39.jpeg"></p><p>（由于网站图床空间有限就放这些啦，想看其它的可以在下面留言啦）白白啦</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后宫 </tag>
            
            <tag> 冒险 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的姐姐</title>
      <link href="/blog/article/24d65ea2.html"/>
      <url>/blog/article/24d65ea2.html</url>
      
        <content type="html"><![CDATA[<p>唉，我的拖延症还真是严重的很啊，我们的永儿姐姐还没开始写呢，不过嘛，相必大家也知道我今天打算写的是啥了吧，正好趁着今天这个特殊的节日—儿童节（羡慕啊，我已经不属于这个行列了啊）</p><p>没错，正是我前天晚上熬夜看完的一部影片—“我的姐姐”，不得不说拍的是真的好，无论是人物心理的把握，还是场景的布置，都远非一些网络电影可比（这里就不透露是哪些啦）<span id="more"></span></p><p>至于为啥我要熬夜看呢，原因比较逗比，因为那天晚上我刚好抽到了爱奇艺的一日会员，嘻嘻嘻，刚好可以拿来看想追的影片啦，好像是熬到了3点半了吧，这段纯属废话，各位看官请往下继续看：</p><p>这部影片由张子枫主演，至于那小孩是谁演的我就不管啦，姐姐的演技是真的很强，尤其是那人物心理的把握，以及情感的流露是真的让我大开眼界，那哭戏简直了，眼泪真的和黄豆粒一样，本来我还以为人的眼泪是不会成豆状的（我错了），剧情啥的嘛，就简单介绍一下吧，影片开始，姐姐的父母在驾车途中，被一辆货车司机撞到，当场死亡，而此刻姐姐正在医院值班，很不幸的是当时父母在死前打给她的电话她并没有接（唉—笔者自配），而后面她才发现自己tm竟然还有个弟弟，可自己因为想要远离自己现在正在工作的地方，奋力准备考研，根本不想带自己这个从未接触过的亲弟弟（这里有一个比较现实的问题，就是父母替自己更改志愿，这里就不把笔者的个人看法强加给大家了），也正是因为这样，姐姐一直想着法儿给自己的弟弟找领养家庭，不过这个计划也一直遭到她的姑母反对（背景：姐姐曾经也是被姑母带大的，姑母家也十分困难），双方拉锯战就此展开</p><p>不过嘛，也没多久，在撞人司机的帮助下，（这里提下，这个司机，额，我也不知道到底有没有喝酒，只是他也有个女儿需要养，所以他清楚姐姐的处境）姐姐成功找到一个领养家庭，虽然一开始弟弟很不想去，不过最后还是为了姐姐想去北京的愿望，自己给那个领养家庭打电话想要和他们一起住（唉，小孩真懂事，虽然开始这个小孩很那啥，不过失去父母，还这么小，唉，不多说，说啥都是泪）。其实这个时候，姐姐已经心里想要自己带这个弟弟了，可是没想到弟弟选择了她的愿望，放弃了自己的亲情（泪崩），当然啦，最后在即将要前往北京的时候，姐姐还是选择了带自己的弟弟，故事到这里就结束了</p><p>影片中，每一个人物的刻画都是很到位，无论是喜欢赌钱的舅舅，还是太善良的姑母，都是片中非常吸引眼球的焦点所在，说到这里，就不得不谈下这个舅舅啦，前面我的剧情介绍比较简单，有些情节我并没有写下来，感兴趣的小伙伴可以自己去看看。这个舅舅呢，从一开始感觉就不是很好，因为他一直是为了姐姐的那套房子卖出去的钱，以及从撞人司机那里威胁拿到那两万块钱的事，给我的感觉就是一个小人，舅舅中间也带了弟弟一段时间，结果姐姐来看弟弟的时候直接傻眼了，弟弟也在外面和一群小孩在打牌，，耳朵上还有一根烟，，活生生一个小混混的样子，这给姐姐气的啊，就把弟弟给带回去了。可能到这里，大家都会觉得这个舅舅不称职，可是在后面的一个场景也直接给我傻眼了，就是姐姐从墓园出来的时候，舅舅正在那里坐着喝酒吃花生，看样子也是来祭拜的，聊了会后，在舅舅快走的时候，姐姐一句话直接让我懵圈，舅舅有时候看起来才像是我的爸爸一样，，，这是哪，我是谁，我要到哪里去？后来一想，有没有可能舅舅前面的只是不希望姐姐放弃这个弟弟而做出来的呢？好像舅舅也是一直关注着姐弟两人吧</p><p>反正得亏我是晚上大半夜看的，不然又是哭的稀里哗啦</p><p><img data-src="https://cdn.makiru.top/images/mySister1.jpeg"></p><img data-src="https://cdn.makiru.top/images/mySister2.jpeg" style="zoom:74%;" /><p>拜拜啦，下次一定永儿姐姐！！在此立下flag！！！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 催泪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客样式的美化</title>
      <link href="/blog/article/3cf823d3.html"/>
      <url>/blog/article/3cf823d3.html</url>
      
        <content type="html"><![CDATA[<p>今天继续水一篇文章吧，就讲讲目前我博客的一些新变化吧，个人觉得目前我的博客网站还是蛮好看的（厚脸皮。。）</p><p>先说明下，我使用的是next主题</p><p>介绍之前，再次哭诉下，唉，我是真的闲，都开始闲到水文章了，，<span id="more"></span></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>首先总体上说下我的网站在样式上的新变化</p><ol><li>在博客页面的左侧新加了个类似于留言板的板块</li><li>在页面左侧新加了个看板娘（小埋—超级卡哇伊）</li><li>适当优化了seo（将文章的url适当修改）</li><li>博客右侧添加了个性化的回到顶部标签（素材嘛，从其他大佬那爬过来的）</li><li>博客整体更换了背景图片，并透明化文章</li><li>评论框添加背景图</li></ol><p>至于怎么实现的，还请继续往下看……….</p><h3 id="新加板块"><a href="#新加板块" class="headerlink" title="新加板块"></a>新加板块</h3><p>其实嘛，这个功能的实现是非常简单的，接下来简单介绍下</p><p>第一步，想好自己要加的板块名字，我这里就用“唠叨唠叨”为例说明</p><p>第二步，进入博客根目录，打开命令行，输入：<code>hexo new page guestbook</code>,回车，这样的话，你就会在博客目录&#x2F;source&#x2F; 下生成guestbook目录，里面有个index.md，你可以适当的在里面加些想加的话，比如博主就是这样加的：</p><img data-src="https://cdn.makiru.top/images/image-20210522160950672.png" alt="" style="zoom:50%;" /><p>然后嘛，就是去修改主题的配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  guestbook: /guestbook/ || fa fa-book</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure><p>在menu这里添加一个guestbook</p><p>然后去更改主题的语言配置文件（zh-CN.yml和en.yml）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  guestbook: 唠叨唠叨</span><br><span class="line">  search: 搜索</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益 404</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: Home</span><br><span class="line">  archives: Archives</span><br><span class="line">  categories: Categories</span><br><span class="line">  tags: Tags</span><br><span class="line">  about: About</span><br><span class="line">  guestbook: Guestbook</span><br><span class="line">  search: Search</span><br><span class="line">  schedule: Schedule</span><br><span class="line">  sitemap: Sitemap</span><br><span class="line">  commonweal: Commonweal 404</span><br></pre></td></tr></table></figure><p>最后重新hexo g -d就可以了（但是嘛，留言板肯定是需要你自己先把评论系统设置好才行吧，这个我采用的是valine评论系统，听说这个系统不安全，会泄漏信息，，额，我也没啥好泄漏的）</p><h3 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h3><p>先看下成果吧</p><p><img data-src="https://cdn.makiru.top/images/image-20210522161825687.jpeg"></p><p>添加方法也比较简单</p><p>首先在博客根目录安装一个插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>根目录下创建新文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> live2d_models</span><br></pre></td></tr></table></figure><p>然后将下载好的模型放到该文件夹里，这里给出一些模型：</p><p><a href="https://qianyan.lanzoui.com/iSm5Zpcsoaj">https://qianyan.lanzoui.com/iSm5Zpcsoaj</a> 密码:4c1m</p><p>当然，放进去后还是需要修改点东西的，主要有两个地方，一个就是模型文件夹的名字，自己随意定义，我这里就用小埋的模型介绍，所以就定义为umaru，然后还有一个地方就是文件夹里的physics.json文件修改名字为umaru.model.json，其他地方可以不用动了（大佬请随意）</p><p>接下来修改博客配置文件（记住不是主题配置文件），添加下面的代码块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line">live2d:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 开启live2d</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  scriptFrom: <span class="built_in">local</span> <span class="comment"># 默认</span></span><br><span class="line">  pluginRootPath: live2d/ <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  pluginJsPath: lib/ <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  pluginModelPath: assets/ <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  tagMode: <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  debug: <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  display:</span><br><span class="line">     position: left</span><br><span class="line">  mobile:</span><br><span class="line">     show: <span class="literal">false</span>   </span><br><span class="line">  model:</span><br><span class="line">     scale: 1.0</span><br><span class="line">     use: umaru     <span class="comment">#这里的名字就是刚才定义文件夹的名字</span></span><br></pre></td></tr></table></figure><p>最后，重新编译上传就可以啦</p><h3 id="优化SEO"><a href="#优化SEO" class="headerlink" title="优化SEO"></a>优化SEO</h3><p>说优化，其实嘛，也谈不上啥优化，毕竟现在我的博客被谷歌收录的好像，，越来越少</p><p>实际上，就是安装个插件—hexo-abbrlink，在博客根目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>接下来便是修改博客的配置文件，添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">permalink: article/:abbrlink.html</span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  drafts: <span class="literal">false</span> <span class="comment">#(true)Process draft,(false)Do not process draft</span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  auto_category:</span><br><span class="line">     <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">     depth:</span><br></pre></td></tr></table></figure><p>注意到，上面的第一行，我们以后文章的链接就会是：域名&#x2F;article&#x2F;xxxxxx.html，所以说这里的article可以自己看着换，好像原本的是post</p><p>以后每次上传文章时，都会在文章首页加个<code>abbrlink: your_blog_url</code>，其实，这个也可以在写文章的时候自己加个有辨识度的url</p><h3 id="个性化回到顶部标签"><a href="#个性化回到顶部标签" class="headerlink" title="个性化回到顶部标签"></a>个性化回到顶部标签</h3><p>先看下是什么样的吧（借用的别人的图，我博客嘛，因为目前文章太少，看起来怪怪的）</p><p><img data-src="https://cdn.makiru.top/other/back-to-top.gif"></p><p>就是一只猫咪的标签</p><p>怎么加呢，首先，下载这个猫咪的图片：</p><p><a href="https://qianyan.lanzoui.com/idgP8pcwixa">https://qianyan.lanzoui.com/idgP8pcwixa</a> 密码:grz4</p><p>将这张图片放在博客根目录&#x2F;themes&#x2F;主题名称&#x2F;source&#x2F;images里</p><p>然后便是修改回到顶部的配置文件（博客根目录&#x2F;themes&#x2F;主题名称&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;back-to-top.styl），添加以下代码，记住：是添加，不是覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line">@media screen and (min-width: 900px) &#123;</span><br><span class="line">    .back-to-top &#123;</span><br><span class="line">      right: 60px;</span><br><span class="line">      width: 70px;  //图片素材宽度</span><br><span class="line">      height: 900px;  //图片素材高度</span><br><span class="line">      top: -900px;</span><br><span class="line">      bottom: <span class="built_in">unset</span>;</span><br><span class="line">      transition: all .5s ease-in-out;</span><br><span class="line">      background: url(<span class="string">&quot;/images/scroll.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">      //隐藏箭头图标</span><br><span class="line">      &gt; i &#123;</span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &amp;.back-to-top-on &#123;</span><br><span class="line">        bottom: <span class="built_in">unset</span>;</span><br><span class="line">        top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>到这里，差不多就可以了，编译上传，不行就先hexo clean</p><h3 id="更换整体背景"><a href="#更换整体背景" class="headerlink" title="更换整体背景"></a>更换整体背景</h3><p>其实嘛，一开始觉得next新主题的黑白配色蛮好看的，可后来嘛，看了别人的博客后，突然发现自己的不香了，就琢磨着换个背景</p><p>这里说个小插曲，就是一开始我在网上找了找大家是怎么换的，绝大多数都是在一个叫styles.styl文件里修改的，可是，我博客目录下怎么都找不到这个文件，问了不少人，结果我还以为自己用的主题是v5版本，然后就马上去下了个v7，还全部更换了一遍（就是前面所有的配置啥的），最后还是没找到那个文件，后来我仔细比对了下我原来的主题文件和现在的，，竟然一模一样，额，原来一开始用的就是v7。后来才知道是需要自己在主题配置文件中修改并新建这个文件………</p><p>废话不多说，首先，去你的主题配置文件中将下面的注释去掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line">custom_file_path:</span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure><p>然后在根目录&#x2F;source下新建文件夹_data，并在该文件夹中新建文件styles.styl，之后嘛，如果你对你的博客样式有任何想要修改的地方，都可以在这个文件里修改，当然啦，像啥head，sidebar等地方的修改，可能就需要去掉上面代码中的其他注释啦</p><p>这里就介绍个换背景，在styles.styl里添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//页面背景</span><br><span class="line">body &#123;</span><br><span class="line">    background:url(你背景图的地址，可以是外链，也可以是本地图片);  //我用的是外链，因为感觉本地图片加载好慢</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed; //不重复</span><br><span class="line">    background-size: cover;      //填充</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里其实背景就换完了，是不是很简单？当然，如果觉得自己的文章卡片如果能透明，进而看到完整的背景图的话，就可以继续往下看</p><p>在刚才的文件里继续添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的像搜索框啥的，如果没有也可以不添加，加了也没啥</p><p>编译加上传就可以啦</p><h3 id="valine添加背景图"><a href="#valine添加背景图" class="headerlink" title="valine添加背景图"></a>valine添加背景图</h3><p>先看下效果吧</p><p><img data-src="https://cdn.makiru.top/images/image-20210522183657328.png"></p><p>添加也是很简单的，就这个背景，唉，说起来都心累，我在这个背景上花的时间最多，因为它的设置也是需要在刚才的styles.styl上修改，我一开始并不知道可以自己新建，网上很多教程也是说的很模糊</p><p>在刚才的styles.styl里添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* comment-输入框背景图片 */</span><br><span class="line">.veditor &#123;</span><br><span class="line">background-image: url(图片url) !important;</span><br><span class="line">background-repeat: no-repeat !important;</span><br><span class="line">background-position: right !important;</span><br><span class="line">&#125;</span><br><span class="line">.veditor:focus &#123;</span><br><span class="line">background-position-y: 200px !important;</span><br><span class="line">transition: all .2s ease-in-out 0s !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的背景图我是用的别人的外链图，你们也可以用自己的</p><p>然后就是日常的编译上传就可以了，，至于评论系统里的博主，访客标识就有空再教大家吧</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>其实呢，除了上面说的这些，我还稍微修改了点样式，这些就有空再说啦，白白啦！</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画江湖，又回来啦！</title>
      <link href="/blog/article/8894c926.html"/>
      <url>/blog/article/8894c926.html</url>
      
        <content type="html"><![CDATA[<p>首先得说明一下这段时间长时间没更文的原因，因为笔者已经大四了，这几天正忙着准备答辩的事，昨天花了整整一个下午才答辩结束（当然，我只花了15分钟不到，可能有人问，那为啥要一个下午呢，唉，辛酸泪啊，因为得等大家都答辩结束才能走。。）</p><p>虽然忙着答辩，但是没人能阻挡得了我对动漫的热爱，今天要说的嘛，就是笔者很早很早之前就一直在等的国产动漫—画江湖之换世门生和画江湖之不良人，其实嘛，这两部动漫在我上大学前就分别出到了第一季与第三季，而就在前几天，它终于有后续了！！</p><p>不错！换世门生第二季，我们的永儿姐姐霸气登场！</p><p>不错！不良人第四季，我们的蚩梦小姐姐闪亮登场！</p><p>废话不多说，直接上图！</p><img data-src="https://cdn.makiru.top/images/mmexport1621326784655.jpg" alt="" style="zoom:50%;" /><span id="more"></span><p>好看吧，不得不说，我的审美永远都在社会的前潮</p><p>先说说不良人吧，换世门生下次一定，绝对不会把我们的永儿小姐姐放到一边去的</p><p>我们的蚩梦小姐姐为了救出自己的老爸，带着本人（绝对经典人物）和一个叫啥来着的药师，来到了娆疆，本来打算第二天去一个叫九黎寨的地方求救兵，结果嘛，被坑了，对方早就是毒公的人了，至于毒公是谁，记住他的别称—老王八，幸亏李星云和雪儿救援及时，后来嘛，三人一同前往万毒窟，但是呢，万毒窟外人只有身怀避毒珠才能进入，所以几人商量着去一个叫簋市子的地方，本来我还以为是咋弄到手，，结果嘛，就是偷，结果还遇到了同行—额，字竟然还打不出来，就是一群不能见光的人就对了，打斗时，这个地方的头头来了，然后嘛，千钧一发之际，李星云他们被一个叫龙公子的人救了，没想到，所谓的龙公子竟然就是张子凡，还有林轩，这里就不得不提下几人的装扮了，给大家看看哈</p><img data-src="https://cdn.makiru.top/images/mmexport1621341576767.jpg" alt="" style="zoom:50%;" /><p>是不是很好看</p><p>救是救了，可是万万没想到，这个龙公子竟然是过来和头头的女儿成婚的，咦，看看林轩的小眼神就知道她现在的怒气值有多高</p><img data-src="https://cdn.makiru.top/images/mmexport1621341589064.jpg" alt="" style="zoom:50%;" /><p>（林轩这套衣服看起来有点婴儿肥，不过嘛，可爱完事了）</p><p>后面嘛，就是和那伙怕光的人之间为避毒珠争斗的故事啦，这里就不细说，快进到蚩梦小姐姐的家乡吧</p><p>几人拿到避毒珠后顺利进入了万毒窟，在这里他们得知毒公要在五月初五举办迁阶大会，这是很不正常的，因为这一天无论是虫的毒性，还是控制的难度，都比平常难上好多，几人花了好大的功夫，在得知她老爸的下落，结果去了后才发现她老爸被下了虫术，原来来这里的路上蚩梦被抓了脚踝的那个人就是她的老爸，心里的仇恨与痛苦让她此时此刻只想杀掉那个老王八</p><p>就在这时，一对奇怪的连体人出现了，这两人武功不高，内力却是出奇的高，几人连番上阵都不是对手，李星云还为了保护蚩梦硬挨一拳头，到了濒死的地步，幸亏这时侯卿尸祖及时赶到，救下了众人，到了暂时安全的地方后，救李星云唯一的方法就是用化阳针，所以嘛，也只能蚩梦现学现卖了，可是偏偏到了最后一步，那两个二傻子来了，还带了帮手，导致蚩梦最后一针出了问题，几人顺利逃了出来，可是李星云已经没了气息（当然没死），就在众人以为他已经死了的时候，他又突然活了过来，只是全身功力尽废，当然，这件事并没有告诉任何人，只有后面雪儿发现了异常才得知，唉</p><p>众人前往死溪林，原因嘛，就是之前蚩梦老爸把一个物件放到了蚩梦的脚踝上，那玩意是死溪林的东西，几人进入死溪林后，那两个二傻子当然也紧跟不放，一路尾随进入死溪林，结果几人在一个山洞里遇到了一个奇怪的人，长啥样呢，给大家看看</p><img data-src="https://cdn.makiru.top/images/截屏2021-05-18 下午8.png" style="zoom: 33%;" /><p>是不是很酷！</p><p>这个奇怪的人原来是蚩梦的老妈！！</p><p>而且还是传说中十二峒的人！！！</p><p>直接一人挡住那几个二傻子，为众人离开争取时间</p><p>这一集最后有两句话我印象超级深刻：你到底是谁啊？   我是你老妈！</p><p>一个字，酷，两个字，很酷，三个字，非常酷</p><p>后天又可以看下一集啦，真期待啊，不得不说画江湖现在是越来越好了，听说了之前的夜轨行的评价不是很好，还以为画江湖要不行了，没想到啊，直接甩出一个重量级，爽！！！！</p><p>再过几天再讲讲换世门生吧，这可是我期待了很久的一部动漫，自从看完第一季一直就在期待第二季，白白啦！</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fgo-抽卡无语篇</title>
      <link href="/blog/article/5e03e086.html"/>
      <url>/blog/article/5e03e086.html</url>
      
        <content type="html"><![CDATA[<p>唉，最近fgo不是办那啥2000万下载活动嘛，我白嫖了个皇女，心里还是蛮舒服的，嘻嘻嘻，给你们看下我的皇女老婆</p><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-46.jpg" alt="" style="zoom:50%;" /><span id="more"></span><p>好看吧，我也这么觉得，不过嘛，昨晚我痛下心来花了183个大洋，买了些石头，打算第二次抽伊什塔尔，没错，是第二次！第一次是再往前几个夜晚，我花光攒了半年的石头，结果，唉！但是为了新老婆，我斥巨资，决心一定要抽出来，但是嘛，别说，就和你们想的一样，我还是如往常般的黑。</p><p>抽出来的是这几张（可惜都不是我想要的啊！！）</p><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-55.jpg" alt="" style="zoom:50%;" /><p>美杜莎，也还行吧，也蛮可爱的</p><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-51.jpg" alt="" style="zoom:50%;" /><p>最可恨的还是这张，竟然出了两次，，无语</p><p>好心累！！给大家看下之前没氪金出的货吧（昨夜还是第一次往fgo里充钱，有些后悔），下面的这些还是很久之前欧出来的，好像，嘿嘿，我也不太记得是啥时候的了，不过我记得最欧的是一个晚上出了一个ssr和两个sr</p><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-20.jpg" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-33.jpg" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-37.jpg" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-42.jpg" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-35-59.jpg" alt="" style="zoom:50%;" /><img data-src="https://cdn.makiru.top/images/photo_2021-05-12_15-36-04.jpg" alt="" style="zoom:50%;" /><p>好了，下次绝不再氪，（可能会小氪，关键昨晚一次氪的太多，穷人家的孩子你们不懂），拜拜啦！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heroku搭建v2ray+cf</title>
      <link href="/blog/article/40a5bf82.html"/>
      <url>/blog/article/40a5bf82.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章仅用来供大家学习使用，希望别用来做危害社会的事情。在此声明，出了什么问题与我无关（好像也没啥用呢）</p><p>其实呢，就是教大家怎么搭建一个日常备用的代理而已（也没什么太大的用处，学习而已）<span id="more"></span></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>首先，再次说明下，我国严禁网络代理的使用，也就是说谷歌，油管啥的在我国是不允许使用，所以该文章仅用来学习使用，出了问题自行负责。除此之外，大佬请出门右转，这里的文章只适合萌新小白。</p><p>需要事先准备的东西：</p><ol><li>一个heroku的账户</li><li>一个cloudflare的账户（没有？没事，待会教大家获取）</li><li>v2ray软件（没有没事，待会会发）</li><li>好像没了？额，，确实没了吧</li></ol><h4 id="heroku的介绍"><a href="#heroku的介绍" class="headerlink" title="heroku的介绍"></a>heroku的介绍</h4><p>实际上，heroku是一种云平台服务，大家只需要知道和云有关的东西是很牛逼的就行了，能做好多好多事</p><p>说到这里，就需要大家去注册heroku的账户：<a href="https://signup.heroku.com/">https://signup.heroku.com/</a></p><img data-src="https://cdn.makiru.top/images/image-20210506155506270.png" alt="" style="zoom: 25%;" /><p>select a language可以选择PHP，其他的按自己想的填就可</p><p>注册完后登录进去就行</p><h4 id="cloudflare介绍"><a href="#cloudflare介绍" class="headerlink" title="cloudflare介绍"></a>cloudflare介绍</h4><p>这个嘛，大家只要记得它可以用来反向代理流量的就行，也可以理解为让你看视频更快更流畅</p><p>注册嘛：<a href="https://dash.cloudflare.com/sign-up">https://dash.cloudflare.com/sign-up</a></p><img data-src="https://cdn.makiru.top/images/image-20210506160020386.png" alt="" style="zoom:25%;" /> <h4 id="v2ray介绍"><a href="#v2ray介绍" class="headerlink" title="v2ray介绍"></a>v2ray介绍</h4><p>v2rayN作为一款代理软件，目前还是比较好用的，不过嘛，我个人还是比较喜欢小猫咪的（clash），下载位置：<a href="https://github.com/2dust/v2rayN/releases/download/4.14/v2rayN-Core.zip">https://github.com/2dust/v2rayN/releases/download/4.14/v2rayN-Core.zip</a></p><p>这个是目前比较新的版本，喜欢其他版本的也可以自己去下，因为是github，可能下载都是个问题，所以放个我自己的盘吧：</p><p><a href="https://qianyan.lanzous.com/b0263wn9g">https://qianyan.lanzous.com/b0263wn9g</a>     密码:g8ro</p><h3 id="开始搞起来"><a href="#开始搞起来" class="headerlink" title="开始搞起来"></a>开始搞起来</h3><p>之前不是已经注册好heroku账号了嘛，登录进去，你们的界面应该和我这一样吧</p><img data-src="https://cdn.makiru.top/images/image-20210506163205887.png" alt="" style="zoom: 25%;" /><p>可能有人会说不一样吧，确实不一样，因为我已经建好了两个app了，大家按照我的做法，待会也就可以建好一个了，</p><p>保持这个界面不变，点击下面这个链接：<a href="https://dashboard.heroku.com/new?template=https://github.com/bclswl0827/v2ray-heroku">https://dashboard.heroku.com/new?template=https%3A%2F%2Fgithub.com%2Fbclswl0827%2Fv2ray-heroku</a>  进入下面的界面</p><img data-src="https://cdn.makiru.top/images/image-20210506163521178.png" alt="" style="zoom:25%;" /><p>App name 随你喜欢填，国家也可以选其他的，不过美国的好点，这里的UUID后面需要用到，不过也不用急着复制保存，后面还能找的到，填好后，点击depoly app即可，等出现your app was successfully depolyed就可以了，接着点击manage your app，进入管理界面。</p><p>然后再点击setting进入如下界面：</p><img data-src="https://cdn.makiru.top/images/image-20210506164230699.png" alt="" style="zoom:25%;" /><p>到这里，其实你的代理已经算是搭建好了，接下里便是v2ray那边的事了。</p><h3 id="v2rayN配置"><a href="#v2rayN配置" class="headerlink" title="v2rayN配置"></a>v2rayN配置</h3><p>打开v2rayN.exe，长这样：</p><img data-src="https://cdn.makiru.top/images/image_2021-05-06_16-45-05.png" alt="" style="zoom: 50%;" /><p>因为本来这张图有我的一些ip信息，所以处理过，别太介意</p><p>点击服务器，然后点击添加VMess服务器，进入如下界面：</p><img data-src="https://cdn.makiru.top/images/image_2021-05-06_16-50-30.png" alt="" style="zoom:60%;" /><p>地址栏填啥呢？在这里找：就是下面图中我划掉的部分，记住要把https:&#x2F;&#x2F;和最后面的&#x2F;删掉</p><img data-src="https://cdn.makiru.top/images/image-20210506165229199.png" alt="" style="zoom:50%;" /><p>端口填443（大佬应该知道其实443是不怎么安全的，没人搭建v2ray用443端口，因为很容易封，不过嘛，我们只是备用而已，不容易封）</p><p>用户id就是之前说的UUID啦，在哪找呢</p><p><img data-src="https://cdn.makiru.top/images/image-20210506165945811.png"></p><p>点击下Reveal Config Vars就会出现啦</p><p>传输协议选择ws，别名可以自己填个好管理的，路径填&#x2F;，底层传输安全选择tls，允许不安全连接选择true，点击确定即可</p><p>然后，选中你的服务器，右键点击设为活动服务器，接下来便可以进入谷歌啥的了。。</p><img data-src="https://cdn.makiru.top/images/image_2021-05-06_17-07-38.png" alt="" style="zoom: 67%;" /><p>如果对速度啥的没要求的朋友，到这其实就可以结束了，不过嘛，可能有和我一样的朋友，喜欢在油管上那种丝滑般的感觉，可以继续往下看。</p><h3 id="CF反向代理"><a href="#CF反向代理" class="headerlink" title="CF反向代理"></a>CF反向代理</h3><p>这里嘛，就需要之前注册好的cloudflare账号咯</p><p>登录进去，应该长这样：</p><img data-src="https://cdn.makiru.top/images/image-20210506171739750.png" alt="" style="zoom: 25%;" /><p>点击workers进去，界面长这样：</p><img data-src="https://cdn.makiru.top/images/image-20210506171918744.png" alt="" style="zoom:25%;" /><p>因为我之前已经弄过两个了，所以这里会有两个worker，因为有部分隐私信息，所以涂了点鸦</p><p>点击创建worker，进去，然后，将左侧的脚本代码全部删掉，换成下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(</span><br><span class="line">&quot;fetch&quot;,event =&gt; &#123;</span><br><span class="line">let url=new URL(event.request.url);</span><br><span class="line">url.hostname=&quot;域名&quot;;</span><br><span class="line">let request=new Request(url,event.request);</span><br><span class="line">event. respondWith(</span><br><span class="line">fetch(request)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>代码里的域名改为之前你填入v2rayN里的地址，就是我说别加https:&#x2F;&#x2F;和&#x2F;的那个，千万注意前后别加空格</p><p>点击保存并部署即可，测试一下，点击发送，成功的话是这样：</p><img data-src="https://cdn.makiru.top/images/image-20210506172625002.png" alt="" style="zoom:25%;" /><p>然后嘛，继续去v2rayN配置（注意，上图中的那个发送左边的地址复制下，待会有用）：</p><img data-src="https://cdn.makiru.top/images/image_2021-05-06_17-29-08.png" alt="" style="zoom:50%;" /><p>将刚才复制的地址除掉开头的https:&#x2F;&#x2F;和最后的&#x2F;填入地址栏，其他的不变，点击确认，便实现了反向代理，如果正常的话，油管的速度应该就可以上去了。</p><img data-src="https://cdn.makiru.top/images/image_2021-05-06_17-33-42.jpeg" alt="" style="zoom:50%;" /><p>上图只是随便测的速度，大佬别介意。。。</p><p>由于cf反向代理选择的ip可能并不太适合每个人所在地区的网络，因此我们需要选择适合本地网络的ip用于cf，所以需要使用到筛选ip的工具，我给个盘的链接，有需要自己下：<a href="https://qianyan.lanzous.com/inrLtov6uof">https://qianyan.lanzous.com/inrLtov6uof</a>          密码:2970</p><p>使用方法嘛，很简单，双击CF优选IP.bat就可以进入命令行界面，然后它会让你输入一个自己想要的速度上限，一般根据自己网络带宽看，我的校园网比较拉，在50左右，所以我填的是60，70，80，其实可以一个一个试，看看最高多少，就用那个ip</p><p>怎么用呢，很简单，把ip填入v2rayN之前那个地址栏，把地址栏的原本内容填入那个伪装域名就可以了。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>到这里，我相信大家就可以愉快的使用了，油管啥的也可以尽情看了，不过嘛，有一些需要注意的地方：</p><ol><li>因为heroku这个相当于给学生研究用的，所以别过度滥用，比如整天多人地去看4k视频啦，租借啥的啦，一不小心会被封号的哟</li><li>别用来做违法的事，多次声明，出了事与我无关</li><li>heroku好像多久不用会休眠来着，我也不太记得了，不过我的一直都没关，我也不常用，就用来搜点资料用用</li><li>最好只是个人使用，多人使用封号几率很大，并且最后一个账号下多建几个应用，就像前面一样建个3到4个，换着用，负载均衡</li></ol><p>以上便是所有的教程内容啦，下期见，拜拜～</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔法科高校的劣等生</title>
      <link href="/blog/article/6c8a55b2.html"/>
      <url>/blog/article/6c8a55b2.html</url>
      
        <content type="html"><![CDATA[<p>废话不多说，先上图！</p><img data-src="https://cdn.makiru.top/images/totalPic.jpeg" alt=""  /><span id="more"></span><p>说起这个番剧嘛，话可就多了。怎么说呢，其实这部番在我应该还是大一的时候就打算看了，只是看了看番的介绍之后，总觉得不符合那时候自己的口味，现在想想，当时的自己还真是年轻啊（嘿嘿）。如今已经快到毕业的时间了，再过两个月，就要踏入研究生新的生活，一切还是那么的快。</p><p>先说说这部番给我的一些小感受吧，首先，看的是真的爽，不过却并不同于那些类似龙傲天的动漫，番剧中人物的感情线也是蛮细腻的，总之一个字：快乐就对了！其次，番剧的长度也是不同于一般番剧的13话结束，而是已经上映了好几季哟，想想看，花一整天的时间看完整部番得是多么令人身心愉悦的事啊！不过嘛，有一点点小遗憾，就是目前关于这部番剧的追忆篇还没有开播，并且！！！我最关心的暑假篇去哪里了！！！！编剧，导演，出来解释下！好不容易小说里出现的福利篇结果没有任何制作的消息（不会是怕教坏小学生吧）。最后，番中的角色是真的好看，衣服的设计也是真的帅，男女主是真的配。</p><p>说了这么多，也该介绍下番的剧情了，这部番是根据小说改编而来，小说一共分为入学篇，九战篇，暑假篇，横滨骚乱篇，追忆篇，来访者篇等等，不过嘛，目前制作的包括：入学篇，九战篇，横滨骚乱篇以及来访者篇。这些其实也够看了，我们的男主名为司波达也，战力爆表，整部番里没他打不过的对手，他有个超级好看的妹妹，叫司波深雪（好像不是亲妹妹），深雪是个超级兄控，番剧里有好几处深雪吃醋的样子，超级卡哇伊（姨母笑）。</p><p><img data-src="https://cdn.makiru.top/images/xue.png"></p><p>番的开篇，达也和深雪进入了一所教授魔法的学校，达也的目的主要是成为深雪的守护者，入校后，深雪自然是优等生，而达也的能力并不体现在学校用于对学生测试的项目上，也就是说达也的普通魔法能力并不强，但这并不妨碍他撩妹的天然光环，刚进校，就遇见了我们的学生会会长（七草真由美，香菜配的哟），会长也是真的御姐风十足，入学篇主要发生了达也加入类似执法部的一些趣事，比如，剑道部的一些问题啦，巴拉巴拉的。</p><p><img data-src="https://cdn.makiru.top/images/qicao1.jpeg"></p><p>至于九战篇嘛，就是九所学校的魔法比赛啦，比赛的名字起的还都挺好听的，像啥幻境摘星啦，依我看来，这些比赛都是服装大赛，衣服是一个比一个好看。</p><p><img data-src="https://cdn.makiru.top/images/qicao2.jpeg"></p><p>（一个忍不住又上了一张会长的美照）</p><p>后面的剧情大家还是自己去看的好，不骗你，是真的好看，只要是女生都是女神级别，哎，这些建模师都真的是呕心沥血，都说玄机的美女是无敌，如今看来，应该加个前缀—国内，真不是假话，感觉很多番剧的女生都是媲美焰灵姬的等级，哎，大家就当本文是放美图照的吧，因为最近博主有点点力不从心（事先声明：不是看番看的肾虚）。</p><img data-src="https://cdn.makiru.top/images/qicao0.jpg" alt="" style="zoom:50%;" /><p><img data-src="https://cdn.makiru.top/images/totalPic1.jpeg"></p><p>剩下的就需要看官们自己去番剧里看咯，继续期待下一部番吧（偷偷先透露下：是进击的巨人哟）</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的学习2</title>
      <link href="/blog/article/2b2b6a93.html"/>
      <url>/blog/article/2b2b6a93.html</url>
      
        <content type="html"><![CDATA[<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>java线程是依靠synchronized进行同步的，使用synchronized的时候，锁住哪个对象是很重要的。</p><p>最好的方法是将synchronized逻辑封装起来，<span id="more"></span>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">    <span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">    c1.add(<span class="number">1</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">    c1.dec(<span class="number">3</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    System.out.println(c1.get());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">    c2.add(<span class="number">6</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">    c2.dec(<span class="number">3</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    System.out.println(c2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">count += n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">count -= n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样一来，无论实例化几个counter，都不会存在逻辑问题，因为锁住的对象是this</p><p>如果一个类被设计为允许多线程正确访问，我们就称该类是线程安全的，上面的counter类是线程安全的，java标准库java.lang.StringBuffer也是线程安全的。</p><p>不变类：String，Integer，LocalDate，它们所有成员变量都是final，只能读不能写，所以是线程安全的。</p><p>最后。类似math这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>可以用synchronized修饰方法，表示整个方法都必须用this实例加锁。对static方法加synchronized是锁住JVM为其自动创建的class实例。</p><p>针对上述代码中的get方法，由于只是读一个变量，是不需要同步的，但是如果是返回多个变量，则必须同步。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>java的线程锁是可重入的锁，可重入的锁就是指在获取到一个线程的锁后，依然可以继续获取这个锁（官方定义：JVM允许同一个线程重复获取同一个锁，这个能被同一线程反复获取的锁，就叫做可重入锁）。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">var</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter1</span>();</span><br><span class="line"><span class="comment">//var t2 = new Counter1();</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">t1.add(-<span class="number">4</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t1.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter1</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">dec(-n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">count += n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">count -= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果进入add方法内，表明已经获取到this的锁，add方法内调用dec()方法，则又需要获取一次this的锁。</p><p>获取可重入锁的同时，需要记录这是第几次获取，每获取一次记录+1，释放后-1，减到0时真正释放锁。</p><h4 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h4><p>多个线程之间获取锁的顺序存在一定问题，造成线程均无法正常结束，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>, another = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockA) &#123;</span><br><span class="line"><span class="built_in">this</span>.value += m;</span><br><span class="line">System.out.println(<span class="string">&quot;get add lockA&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockB) &#123;</span><br><span class="line"><span class="built_in">this</span>.another += m;</span><br><span class="line">System.out.println(<span class="string">&quot;get add lockB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockB) &#123;</span><br><span class="line"><span class="built_in">this</span>.value -= m;</span><br><span class="line">System.out.println(<span class="string">&quot;get dec lockB&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);    <span class="comment">//一定要注意，这里是为了避免将锁快速释放</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockA) &#123;</span><br><span class="line"><span class="built_in">this</span>.another -= m;</span><br><span class="line">System.out.println(<span class="string">&quot;get dec lockA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程t1执行add()，线程t2执行dec()，那么：</p><ol><li>线程t1：进入add()，获得lockA;</li><li>线程t2：进入dec()，获得lockB。</li></ol><p>接着：</p><ol><li>线程t1：准备获取lockB，失败，等待中；</li><li>线程t2：准备获取lockA，失败，等待中。</li></ol><p>之后就是无限等待，JVM无法正常关闭，只能强制关闭。</p><p>解决办法：可以适当调整锁的获取顺序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockA) &#123;</span><br><span class="line"><span class="built_in">this</span>.value -= m;</span><br><span class="line">System.out.println(<span class="string">&quot;get dec lockA&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(t1.lockB) &#123;</span><br><span class="line"><span class="built_in">this</span>.another -= m;</span><br><span class="line">System.out.println(<span class="string">&quot;get dec lockB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><p>主要用来解决多进程之间的协调问题，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望的结果是：线程1调用addTask()不断往队列添加任务，线程2可以调用getTask()获取任务，如果队列为空，等待，直到队列中有任务再返回。</p><p>实际上：while循环无法退出，因为进入getTask()时，已经获取了this的锁，不退出该方法，则其他线程无法再获取this的锁，也就无法调用addTask()。</p><p>wait()方法：可以使调用的线程释放锁，返回时再次尝试获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用while而不是if,是因为如果三个线程被唤醒，且都获得锁，肯定有一个能获得任务，另外两个可能依旧没法获得任务</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>notify()方法(或notifyAll()方法)：唤醒等待锁的线程，这样wait()方法才能返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    <span class="built_in">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.makiru.top/images/image-20210420233305922.png" alt="" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的学习1</title>
      <link href="/blog/article/b2223b29.html"/>
      <url>/blog/article/b2223b29.html</url>
      
        <content type="html"><![CDATA[<h3 id="多线程的基础"><a href="#多线程的基础" class="headerlink" title="多线程的基础"></a>多线程的基础</h3><p>现代操作系统都可以执行多任务，即可以同时运行多个任务，比如说，当你打开QQ的同时，你还可以播放音乐，cpu执行代码虽然都是一条一条执行的，但是即便是单核cpu，也可以同时运行多个任务，实际上只是cpu轮流执行多个任务而已。<span id="more"></span></p><p>进程与线程是存在区别的，一个进程可以包括多个线程或一个线程，但是至少一个。</p><img data-src="https://cdn.makiru.top/images/image-20210420131923151.png" alt="" style="zoom:50%;" /><p>java语言内置多线程支持：一个java程序实际上是一个JVM进程，JVM进程用一个主进程来执行main()方法，在main()方法内我们还可以执行多个线程。此外JVM还有负责垃圾回收的其他工作线程等。</p><p>一般情况下，多任务大多都是利用多线程实现的，多线程的难点在于：经常需要读写共享数据，还需要同步。</p><h3 id="新线程的创建"><a href="#新线程的创建" class="headerlink" title="新线程的创建"></a>新线程的创建</h3><p>要创建一个新线程很简单，只需要实例化一个Thread实例，然后调用它的start()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面创建的新线程不会做什么就结束了，如果想要让该线程做点什么，只需要覆写run()方法即可，或者直接利用lambda语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法执行和线程执行还是存在一定区别的，比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;thread start.....&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(<span class="string">&quot;thread end.....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread start.....</span><br><span class="line">thread end.....</span><br><span class="line">hello thread</span><br></pre></td></tr></table></figure><p>从这里可以看出，当线程t启动后，它是和主进程同时执行，也就是说最后一个打印语句的执行时间点是不确定的，可能在hello thread前，可能在其后，如果想要确定下来，可以利用Thread.sleep()方法使线程暂停一段时间。</p><p>线程里还有一个方法叫join()，表示等待该线程结束后，再往下继续执行自身线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;thread start.....&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;thread end.....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是指：当t线程结束后，才能执行其下面的main线程，所以打印结果一定是thread end在hello thread的后面。</p><p>java线程对象的状态包括：New，Runnable，Blocked，Waiting，Timed Waiting和Terminated。</p><h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>如果线程需要执行长时间任务，就有可能需要中断线程，中断线程其实就是其他线程给线程本身发个信号，线程本身收到信号后，结束执行run()方法，立刻结束运行，举个例子：如果需要下载一个100g的文件，如果下的太慢了，不想下了，就需要取消下载，这就是给线程一个信号，停止下载这个方法的执行。</p><p>中断线程很简单，直接在其他线程中对目标线程调用interrupt()方法，目标线程反复检测自身状态是否是interrupted状态，如果是，立刻停止执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main线程通过调用t.interrupt()通知t线程中断，但是t线程处于等待hello线程的结束中，该方法会立刻结束并抛出Interruptedexception，由于t线程中存在捕获异常，所以可以直接结束，t结束前，对hello线程也执行了interrupt()，所以hello线程也会结束。</p><p>还有一种中断方法，就是设置标志位running，将其设置为false即可中断线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>running是线程间共享的变量，因此需要使用volatile关键字确保每个线程都能读取到更新后的变量值。</p><p>实际上，该关键字的作用就是：</p><ol><li>每次访问变量时，总是获取驻内存的最新值；</li><li>每次修改变量后，立刻写回内存（时效性）。</li></ol><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>java程序中有时候需要根据需求设置一些无限循环的线程，比如定时触发的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束，问题是，谁来负责结束这个线程？</p><p>但是这类线程一般没有负责人来结束它，那就只能使用守护线程，守护线程是指为其他线程服务的线程，在JVM里，所有非守护线程执行完毕后，无论有没有守护线程，JVM都会退出。</p><p>如何将线程标记为守护线程？在调用start()方法前，调用setDaemon(true)将该线程标记为守护线程。</p><p>注意：守护线程没办法持有任何需要关闭的资源，如打开文件。</p><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说，对count加10000，减10000，最后结果应该为0，但是实际上结果不为0，这是因为操作顺序的原因。</p><p>保证一段代码的原子性，可以利用synchronized:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样最后的结果就是0，相当于每一次只能有一个线程对共享变量count进行操作。</p><p>在使用锁的时候，需要弄清楚到底谁与谁之间是不能同步执行的，不然可能会造成执行效率的下降。</p><p>不需要synchronized的操作包括：</p><ol><li>基本类型（long和double除外）赋值，例如：int n &#x3D; m;</li><li>引用类型赋值，例如：List<String> list &#x3D; anotherList。</li></ol><p>关于long和double，JVM没有明确定义为原子操作，但是在x64平台的JVM是将其当成原子操作实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妖精的旋律</title>
      <link href="/blog/article/eb4d6d8d.html"/>
      <url>/blog/article/eb4d6d8d.html</url>
      
        <content type="html"><![CDATA[<p>这部番，额，在国内因为过于血腥被定为禁番，不过嘛，在我看来，这部番剧还是有的看点的，先上点图吧</p><p><img data-src="https://cdn.makiru.top/images/yaojindexuanlv.jpeg"></p><span id="more"></span><p>刚开始看这部番的时候，其实我也有一点点不适，因为确实有些血腥，建议晕血的还是别看的好，第一集就非常的非常的暴力，我们的女主露西开头就非常暴力。</p><p>在这个动漫的世界里，存在着一种特别的生物：二觭人，它们的特点是头上有一对角，拥有着看不见的触手，这些手有着分割的能力，所以说，开头露西几乎都是将人直接分尸。故事开头，有一个专门研究二觭人的研究所，在某个神秘人的帮助下（也说不准是不是帮助），露西逃出了这个研究所，女主露西可以说是二觭人的祖先吧，因为她是第一代二觭人，拥有四只触手，最远射程10米，战力超强，不过在逃出的过程中，不小心被狙击手打到了脑袋，变相的可以说是失忆了，其实也不算，只能说是将露西意识内的善良一面释放了出来。</p><p>之后露西被海浪带到了男主浩太所在的城市，并和男主，男主的青梅竹马由香住在了叫枫庄的地方，这里插一句，露西失忆后超级可爱，完全没有之前那种血腥的氛围与气场，只会喵喵喵，所以也被浩太起名为妮悠。不过在过了一段平静的生活后，便因露西掰碎了男主妹妹送男主的贝壳（算是他妹遗物吧），浩太对露西发了火，露西跑了出去，其实是去海边找贝壳了，结果被前来杀她的人遇到了，幸亏在争执中露西撞到了头部，又变成了原本的露西，然后嘛，杀她的人就都领盒饭了，除了一个头头，被卸了一条腿和手，活了下来（后面这个人特逗比，也算是重情义的人吧），正好浩太也来找露西，当然也知道了露西的特殊性，以至于后面警察的询问也都有所隐瞒。</p><p>后面嘛，又是一段平静生活，二觭人7号被派来杀露西，7号这个人真的是很善良，也很可爱，不过她的触手比露西要多，距离也远点，与露西的第一战，露西就吃了点亏，不过嘛，真由也就顺道出场了，她生活在某一个离异重组家庭，毫不夸张地说，她生活在地狱，每当母亲不在身边，就会受到继父的性虐待，和母亲说，母亲还很恶劣地对她说，没她就好了，也因此，真由逃离了这个家，每天都住在海边的一个废弃车棚，靠着菜市场的碎面包和偶然遇到的旺太（狗狗）过着日子，真由出现在两者的打斗现场，劝阻不要打架，结果，7号（娜娜）怕她受伤，便跑出来保护真由，被露西抓住机会，卸了一条腿和胳膊，而真由也被露西扔到了路边。之后，露西又回到了枫庄，真由也住了进来，而娜娜则被送回了研究所，因伤势过重，被处以死刑，不过研究室的室长藏间没忍心，就给她造了条假腿和假手，并且送她回到了浩太的城市，在经过长时间的磨合，也和露西，浩太，住在了一起。</p><p><img data-src="https://cdn.makiru.top/images/header.jpeg"></p><p>后面的情节有一部分是追忆吧，主要是说浩太和露西以前的故事，露西很久以前住在孤儿院，因为头上的角不受人待见，因为自己养的狗被人虐杀，心底的恨与愤怒诱发了她原本毁灭人类的本性，不过后来遇到了男主浩太，被浩太的真诚打动，两人成为了好朋友，不过在最后一天，也就是庙会那一天，露西问浩太和他一起去庙会的人是男孩还是女孩的时候，浩太撒谎了，说是男孩，其实就是由香，这也就引发了后面一系列的情节，露西后面当然发现浩太骗了她，便大杀特杀，最后还在火车上当着浩太的面杀了他妹妹和父亲，这也成了浩太内心的深层次阴影，被浩太封锁在了心底，造成类似失忆，（哎，何必呢，都是爱情惹的祸，由香也爱男主，露西也爱，两人还真正的坦诚相待咯）</p><p>娜娜刺杀露西任务失败后，研究所没有放弃杀掉露西，最后派出了藏间室长的亲生女儿真理子35号，她是第三代二觭人，触手35只，距离超远，也很可怜，因为从小就被关在研究所，双腿残废，是研究所老大用来威胁控制藏间室长的工具，派真理子一方面因为她很强，有实力杀掉露西，一方面也是用来惩罚藏间私自放掉娜娜，当初生下真理子之前，藏间便亲手杀掉了很多刚出生的二觭人宝宝，结果自己的女儿也是二觭人，最后还是没忍心杀掉自己女儿，真理子也是超级可怜的，在后面的情节中，真理子很轻松地打败了娜娜与露西，不过这时藏间出现了，父女之间的感情还是极为深厚，真理子也是靠着这股想见到自己亲生父亲的信念才活到今天，藏间因内心的愧疚，选择与真理子一起死去，真理子最终在父亲藏间的怀抱中被引发体内炸弹一起身亡（漫画里真理子死之前还是用自己的触手将父亲救了出去，自己身亡）</p><p><img data-src="https://cdn.makiru.top/images/zhenlizi.jpeg"></p><p>露西在最后的情节中，也被浩太原谅了（其实原谅的是妮悠，很多看不懂的直接喷男主），露西最后与前来杀她的人打了起来，故事到这便接近结尾，娜娜与浩太，真由，由香生活在一起，露西不知是死是活，但是，有一天，男主一大家子人在吃饭的时候，门铃响了，浩太起身去开门，这是，屋内的音乐盒里的音乐声停了（这个音乐盒可以理解为露西的象征，因为最开始的露西便是被这个音乐盒吸引了），而那台早已坏了的挂钟却响了（挂钟是妮悠经常玩的，有一次还拆了），门前有一个身影，我个人非常希望是妮悠回来了，每个人都有自己的看法，仁者见仁，智者见智。</p><p>故事到此，真正结束，有人说男主是海王，渣，如果不是那个谎，也不会有这些事了，不过我想说的是，那个年龄的孩子如果真的能想到那么多，也就不是小孩子了，换谁都有可能撒那个谎，不过嘛，浩太对由香和露西的感情确实有那么点复杂，这里不过多分析，动漫结局还是好的，承受能力大的可以去看看，毁三观倒是谈不上，就是场景有点血腥，动不动就分尸那种。对露西的看法也是有很多种，其实嘛，小时候的露西还是蛮善良的，对一只流浪狗都能那么关心，亲眼看到自己关心呵护的狗狗在自己眼前被虐待杀死，换谁都会忍不住爆锤对方，后面的情节中，也说了露西被抓去研究所的经过，按理说她那么强的能力，怎么会被抓呢，其实是因为她的朋友被误认作是露西，被枪击中了，露西不想自己唯一的朋友再次从自己的面前死去，便请求藏间救她，藏间的条件便是将露西带回研究所，露西只能答应，不过最后还是没救回来，这也造成露西内心的黑暗化。露西其实真的是个很可怜的人，二觭人也并不能说是坏人，还是得看受谁的影响罢了，动漫里的二觭人，我个人觉得都是可怜的生命，最终似乎也只有娜娜过上了正常人的快乐生活，漫画里的露西并没有死去，最后用自己的身体融化救了浩太（好像是的，还没看），所以说嘛，整部番剧也是致郁系列，因为好人都会死………..</p><p>最后放几张图吧</p><p><img data-src="https://cdn.makiru.top/images/niyou.png"></p><img data-src="https://cdn.makiru.top/images/lucy.png" alt="" style="zoom: 55%;" />]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 治愈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四月是你的谎言</title>
      <link href="/blog/article/ba4f9ddf.html"/>
      <url>/blog/article/ba4f9ddf.html</url>
      
        <content type="html"><![CDATA[<p>今天我终于将之前一直没敢看的番剧—四月は君の嘘  看完了，之前一直没敢看是因为害怕自己又忍不住泪水，可能是自己泪腺太发达了吧，其实很早之前就知道这部番，不过一直给自己找借口没敢看而已。研究生考上了，毕设也差不多结尾了，心里还是<span id="more"></span>想给自己找虐吧，正好现在也是四月，看这部番最适合不过了。</p><p><img data-src="https://cdn.makiru.top/images/april.jpg"></p><p>番剧里，无论是宫园薰，有马公生，还是泽部椿，渡太亮，还是其他的角色，看的过程中，甚至有时候会觉得人真的会有这种人生吗，当宫园薰在病床上大吼着让公生去练习的时候，泪水还是不争气的出来了，因为我心里想到了他母亲的那句话，自己的时间不多了。。当看到椿向公生说出只能和自己谈恋爱的时候，心里又会忍不住地为椿加油打气，每一幕，每一个细节，都无时无刻不叩击着我的心，有害怕，有喜悦，有悲伤，有沙雕，这样一部番，我愿一直看下去。四月，我的谎言又该对谁诉说呢？</p><p>或许，下一个依旧是没有你的春天吧！</p><p>其实，相信很多人没看到结尾都能猜到熏的结局，毕竟并不是所有的番大结局都是团圆美好，但是，熏将永远住在公生的心里，这是毋庸置疑的，可能说到这，就会有人为椿打抱不平了吧。椿开始没有敢正视自己的感情（怎么可能只是弟弟呢），不过在有了这么多的经历后，她还是说出了自己的心声，如果说熏活在四月的谎言里，那么，椿便是从四月的谎言里走了出来。</p><p>公生的这十几年给了很多人前进的动力，无论是井川绘见，还是相座武士，都是在他的影响下一直向前，只是一个是为了将原本的公生找寻回来，一个是想要抓住自己心中如海市蜃楼般英雄的背影。最值得说的就是宫园薰和公生了，熏是在公生的影响下，选择了小提琴的道路，心里期盼着公生有一天能为自己伴奏，初中时，以自己喜欢渡亮太的谎言走进了公生的生活，无论是让他为自己伴奏，还是合奏爱的悲伤（超喜欢），都是希望他能够走出母亲的阴影。而后期的公生，则是用自己的琴声鼓励着熏，希望能够再合奏，而公生也就是在两人之间的相互帮助中不断成长，最终话中的那首曲子，真的是很感人呢，尽管我五音不全，却还是哭的稀里哗啦，熏最后的一瞥和那泪水…….</p><p>椿，公生的青梅竹马吧，可以这么说，不过外号大猩猩（听到了一定会被揍），总是想着将公生当成废物弟弟，在公生听不见琴声后，一直想着办法帮助他，鼓励他，一直想看到公生再次站在舞台上，喜欢一个人真的会让人疯狂呢，向公生说他喜欢着小香呢，这一幕又让我忍不住（还是在图书馆，，得亏坐在边上），公生的一声嗯，让椿最终还是说出了自己的心声，椿真的就一直站在公生的身边，守护着他，在未来的日子里，或许有椿的陪伴，这种伤痛会减轻很多吧。</p><p>公生经历这么多是真的成长了很多，当知道熏的病情时，当看到熏的手在病床的护栏上滑落时，心里真不是滋味，又一泪点，本来我还以为公生会一蹶不振呢，毕竟他弹琴的理由是为了熏，不过最后他并没有像之前母亲去世那样，放弃了音乐，而是在椿，渡的陪伴下继续踏上下一个春天的旅程。</p><p>哎，还是想哭，不过现在正在图书馆，还是回去之后再哭的好，以后想被虐就再刷一遍，番剧里其他角色都有着重要的作用，给公生的人生抹上了五彩斑斓的色彩，四月是你的谎言，真不是盖的，治愈，决定了，我要刷好几遍！！！</p><img data-src="https://cdn.makiru.top/images/Xun.jpg" alt=""  /><img data-src="https://cdn.makiru.top/images/zebuchun.jpg" alt=""  />]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 治愈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回复术士的重启人生</title>
      <link href="/blog/article/102a7c.html"/>
      <url>/blog/article/102a7c.html</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.makiru.top/images/shushi1.png"></p><p>这部番剧到今天第一季已经结束了，看完之后的感觉就是适合老司机看的番，全季绝无丝毫尿点，保证各位看官看的开心。<span id="more"></span></p><p>总体上来说，番剧的内容可能有那么点稍微反人类吧，不过观看的过程中却又没办法反对男主的想法，就是觉得男主这么做是对的，是合情合理的。但是看完后又会觉得男主到底有没有心理问题。男主拥有的能力是回复，也就是治愈能力，不过这个能力有个缺陷，就是被治愈者的所有经验都会传到男主的大脑，那种难以忍受的痛苦，也使得男主在勇者的团队中一直受不到重用。</p><p>男主的第一世：</p><p>在勇者的团队担任愈之勇者，队伍里还有术之勇者芙蕾雅，剑之勇者布蕾德，炮之勇者布列特-哈兰修特，这三个人都不把男主当成人，其中，芙蕾雅极其傲慢，内在腹黑扭曲嗜虐，是王国的第一王女，布蕾德（开始还以为是男的…..），重度女同性恋，极其厌恶男性，喜欢芙蕾雅，布列特，额，变态至极，喜欢男主，经常对男主做羞羞的事</p><p><img data-src="https://cdn.makiru.top/images/shushi2.png"></p><p><img data-src="https://cdn.makiru.top/images/shushi3.png"></p><p>男主经过长期的折磨后，对药物也有了一定的抗性，从而在最后的一次与魔王的战斗中，其他勇者都被魔王打败后，他抓住了机会，完成了所谓的复仇，并且最终打败了魔王，拿到了贤者之石，开启了他的第二世（最后魔王的流泪与话语挺感人的）</p><p><img data-src="https://cdn.makiru.top/images/shushi4.png"></p><p>男主的第二世：</p><p>开局直接开挂，拿到了精灵赋予的能看穿一切的眼睛</p><p><img data-src="https://cdn.makiru.top/images/shushi5.png"></p><p>与前世差不多，当上了愈之勇者，不过这一世，他提前练成了药物抗性的能力，使后面芙蕾雅的药罐子计划失败，成功将芙蕾雅变成了自己的第一个“宠物”，后面又买了一个“贴身”侍卫，是真的贴身哦，她叫刹那，是冰狼族的天才，但能力始终突破不了上限（后面原来和男主做羞羞的事可以提高，具体点来说是喝那啥，就不细说了，懂得都懂），三个人还一起拯救了刹那的故乡。</p><p><img data-src="https://cdn.makiru.top/images/202202111520409.png"></p><p>接下来便是对剑之勇者的复仇，三人来到布拉尼克，一个魔族与人类共存的城市，在这里，男主对布蕾德实施了报复，他将自己变成了一个很好看的女生，去酒馆里引诱布蕾德，而且还成功了，然后嘛，布蕾德被男主剔断了脚筋，并且玩了个“游戏”，让布蕾德在食欲与性欲下存活（人话：就是让她在三个五大三粗的男人面前，而且是被下了催情的极度饥饿的男人，活到第二天早上），哎，结果可想而知—被吃了。</p><p>值得说的是，在这座城市里，男主还遇见了上一世最后亲手杀掉的魔王，夏娃，现在还只是候选魔王，不过她的种族现在被当做是瘟疫般的灾难，所以一直四处躲藏，也被男主顺手救了，男主想知道上一世她最后的话是什么意思（现在知道了，八成是和男主约定好的实现最后人类与魔族友好共处的结局吧）。</p><p><img data-src="https://cdn.makiru.top/images/202202111520750.png"></p><p>这就是刹那酱的未来！！！！！</p><p>在布拉尼卡，王国的第二王女洛伦公主带着鹰眼和剑之勇者跑来要毁掉这个所谓魔族控制的城市，结果，鹰眼被男主劣化死掉了，而洛伦公主嘛，也被男主复了仇，和她姐一样，改变容貌，清除记忆，变成了最爱男主的妹妹。</p><p><img data-src="https://cdn.makiru.top/images/202202111520675.png"></p><p><img data-src="https://cdn.makiru.top/images/202202111520871.png"></p><p>对了，剧中还有一位剑圣，克蕾赫·葛莱列特，也被男主收服了，很强的。。</p><p>剧情发展到这就结束了，其实我还是蛮期待第二季的，不过听说在日本因为过于反人类，反社会，被下架了，所以有第二季的可能性不太大，不过还是有漫画可以看的嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A slient voice</title>
      <link href="/blog/article/775c74be.html"/>
      <url>/blog/article/775c74be.html</url>
      
        <content type="html"><![CDATA[<p>本文是将我的另一个网站上的文章迁移过来的，所以时间上可能有些对不上。。。</p><p>今天是一年一度的国庆加中秋，不对，仔细一看应该是昨天了，因为自己是个苦逼的考研党，还在奋斗的路上跑着，希望能一次上岸吧</p><p>但是嘛，人不能一直紧绷着，于是趁着这个举国欢庆的一天，我打开了尘封已久的动漫—A slient voice，很早之前就一直想看了，这是一部2016年的动漫电影了，整体看起来情节还算可以，不过整体上的连凑性可能会有那么点小间断，也许这是制作人的一种手法吧，看起来还是蛮有感觉的，全片在两个多小时左右，我是利用晚上在寝室的时间看完的，看完之后突然觉得自己的人生可能和影片中的男女主很像，怎么说呢，要是用我来打比方的话，可能我算是男女主的一个集合体吧。。。<span id="more"></span></p><p>昨晚太晚了，没忍住就去睡觉了（太困了），关于昨晚看的那部动漫呢，其实大体上的内容并不是很难理解，主要讲述的就是女主西宫硝子(Shoko Nishimiya)和男主Shoya Ishida（不知道该咋翻译哈）在学校期间的一些小故事，故事的开篇，男主给我的第一印象应该算是学校里的小混混类型的（后来才发现这其间的缘由），他有不少“好朋友“，比如Naoka Ueno，开始我还以为Naoka Ueno会是女主，额，其实这个Naoka Ueno也还是蛮关心男主的，故事发生到后来，女主西宫硝子转到男主的班上，她是一个聋哑人（准确来说不算哑），每次和别人聊天都是靠着一本笔记本（也可以算是男女主后面的一个纽带吧），不过男主也不知道因为啥原因，总是欺负女主，这里说明一下，女主因为失聪，所以耳朵上会带着助听器，开始是白色的哟，不管是上课还是下课，男主总是欺负西宫，而Ueno与西宫硝子之间的问题是在一次课上，老师让她读文章，读完后老师只是评论了下，随后叫了硝子，（说实话，读的听不懂），老师夸了她，接着便是男主，他没读，Ueno感觉上好像是很讨厌硝子。有一次男主把硝子的两个助听器从耳朵上直接拽了下来，导致硝子耳朵流血了（挺心疼的），之后硝子的母亲要求赔偿，男主的母亲为了赔偿，甚至把自己的耳环当场拽了下来，当我看到男主母亲的耳朵流血时，哇！！！男主真不懂事，剧情到这里，开始男主的经历介绍了，原来男主在硝子来之前也是被欺负的那类人，后来他发现只要欺负别人就可以和别人在一起玩了，于是便有了开场的小混混形象。硝子其实对男主挺不错的，每次会帮他擦掉桌子上别人写的骂他的话，但那次男主看到她擦桌子后便和她打起来了，那一句“我已经很努力了”真的好心酸。后来硝子便转学了。</p><p>之后男主和硝子都长大了不少，在手语学校里遇见了，然后嘛，就每周二去桥上喂面包给鱼，之后，男主向女主道歉了，女主后来竟然还向男主告白了！！！只不过男主没听懂，听成了moon，唉！这期间有个比较有意思的人物角色出场了，那就是硝子的“男朋友”，其实呢，就是硝子的妹妹西宫结弦，挺可爱的一个小女孩，是一个比较率直的人物，在男女主的关系中也有不小的作用，到这里，其实男女主之间感觉上关系已经恢复的七七八八了，只是后面的一个小插曲—男主又遇到了小学同学Ueno，没错，就是那个讨厌硝子的女生，她发现男主和硝子在一起后，心里也不知道咋想的，又像以前小学一样将硝子的助听器拿下来了（这里的助听器是红色的），男主心里的伤又被揭了，哎，可怜，不过这次他倒挺仗义，阻止了Ueno，后面嘛，就是一系列的找老同学道歉啥的剧情，其实我也没觉得硝子有啥错，而且我重头到尾不懂为啥要欺负她（守护好我们最好的硝子！！！！），高潮部分：男主和硝子，以及她妹妹一起做了个蛋糕给硝子母亲庆祝生日，硝子母亲心里也渐渐没那么抵触男主了，后来他们一起去看了烟火，中途硝子回家去了，而她妹妹正好让男主去她们家给她拿相机，正好撞上硝子站在阳台边沿，男主说时迟那时快，一把冲上去把硝子的手抓住了（还好没掉下去），不过男主掉下去了，这里体现了（力的作用是相互的！），后来男主就一直昏迷，而硝子和她妹妹，母亲就给男主的妈妈一直道歉，哎，Ueno也就更恨硝子了，不过这里Ueno和硝子母亲的打斗场面真的是很现实，打的原因当然是Ueno打硝子啦，硝子心里其实想的是只要她死了，男主也就不会再因为她而不开心了，这里，男主其实很早之前也是一直想死的，只不过在他妈妈的劝阻下停止了自杀（他自杀的原因其实也是和硝子很像的，都是源自于内心的一种自卑吧，也谈不上自卑，就是每天被很多人说着去死吧去死吧，任谁也不会正常），硝子心里很难过，晚上梦到了男主在那座桥上掉进了水里，硝子连忙跑到了那座桥，不过没看到男主，她在这里哭的好惨，男主也在这一刻醒了，他心里也很担心硝子，也跑到了这座桥，看到了硝子，到这里，男女主应该才算是正常的和好了，心里也没啥纠葛啥的，后面便是在硝子的帮助下，他和之前的小学同学一个个道歉，修复关系的过程了，这里面比较有趣的一个设定就是在男主的眼里，除了他心里真正认同的人，大家的脸上都会有着叉号挡着脸，后面的修复中，男主看到了原来自己也可以和她们一起笑，生活原来是很美好的，于是大家的叉号也就掉了下来，然后就是完结。</p><p>其实漫画还没有结束，我也还没看，打算有空再去看。。</p><p>再贴上几张我最喜欢的硝子图片吧（不许抢，我的！！！）</p><img data-src="https://cdn.makiru.top/images/xiaozi1.jpeg" alt="" style="zoom: 33%;" /><img data-src="https://cdn.makiru.top/images/xiaozi2.jpeg" alt="" style="zoom:33%;" /><img data-src="https://cdn.makiru.top/images/xiaozi3.jpeg" alt="" style="zoom:33%;" /><img data-src="https://cdn.makiru.top/images/xiaozi4.jpeg" alt="" style="zoom:33%;" /><img data-src="https://cdn.makiru.top/images/uneo.jpeg" alt="" style="zoom:33%;" /><p>有没有被可爱到啊，全是我的！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>樱花庄的宠物女孩</title>
      <link href="/blog/article/62bcf6d2.html"/>
      <url>/blog/article/62bcf6d2.html</url>
      
        <content type="html"><![CDATA[<p>这部番剧是最近看完的，看到中间的时候，笔主就忍不住的去搜了下最后的结局，虽然能够猜到最后的结局，但还是不忍心，结果还是给自己找虐</p><p>这部番大概就是讲空太（男主）因养猫而只能入住樱花庄—所谓的问题学生的宿舍，在这里生活所发生的的事情，后来女主—真白（国外女孩，超级天才，画画很强）来到了樱花庄，空太看到真白对画画的执着与认真，也是对着自己的游戏开发目标前进，但天不如人意，多次的企划书发表失败，在这里，笔主看到了几乎很多学生会有的问题（包括笔主）：上天为什么这么不公平，明明很努力，但却总是得不到该有的回报，反观那些天才们，永远是显得那么辉煌。笔主相信这些想法在很多人的心中都有过，毕竟天才并不是那么多，世界上也没有多少个樱花庄。<span id="more"></span></p><p>而在这一次次的失败中，笔主超喜欢的女生也入住了樱花庄—青山七海：与空太相同，都是在为自己的目标不断地奋斗，也是一个很平凡很普通的人。她的目标是成为一名声优，为了这个目标，她甚至与家里人闹翻离家出走，靠自己打工的钱养活自己，但尽管这样，高昂的房租依然压到了她，每天连饭都是吃不饱，番剧中的她肚子还总是咕咕叫（尤其在男主面前，特别可爱），之后在男主的推荐下，她也加入了樱花庄的团体中，虽然在这里，她和空太一样，总是被其他人的才能所伤害，但她没有丝毫的放弃，直到她第一次声优养成所考试的前几天，终于是累到了（好心疼），在她的坚持与真白的希望下（真白这里的希望，或许是一种对坚持执着的感同身受吧），她还是顶着发烧去参加了考试，但因为她的发烧，不仅未能达标，甚至还影响了她的两个朋友，这里的一个情景，让笔主很想哭，就是朋友们考试出来的那一刻，那天正好下着大雨，她们对着青山说着抱怨的话语，甚至说希望她今天不要来考试，笔主的心里很复杂，换作笔主来当两个朋友，或许心里也不会很好受，但还是为青山感到心疼，脸上不知道是雨水还是泪水，看的很心酸。</p><p>在接下来的日子里，青山也接受了空太以及樱花庄中其他朋友的帮助，从此，她的生活中也多了不少的乐趣，对空太的情感也是越来越深，直到第二次考试之前（圣诞节的前夜），她对空太说，等第二次的试镜结果出来后，她希望空太能够听她说些话，空太也是答应了，到这里，笔主真的很希望青山能够和空太在一起，但偏偏不遂人意，这一夜，空太仍然对真白表现得更类似于恋人的情感，“哭惨了！！”</p><p>期间还有不少的故事，比如文化祭上的游戏制作等，都很有意思，接下来，空太的第二次企划书还是被刷了，原因嘛，因为有一份企划和他的同属于音乐类，而且那一份遵守着传统的方式，或许是因为更有可行性吧，空太这次心态是彻底爆炸了，仍然是对着别人生气（尤其是真白），因为每一次他失败的同时，真白都是非常的成功，换作谁可能都是会很不好受，毕竟真的很不公平，才能有时候真的很伤人，这次失败还是发生在樱花庄要被拆的期间（原因是校方害怕真白因住在樱花庄坚持漫画的创作而影响前途给学校带来不好的名声），同时，青山这次也是被击垮了，因为她的试镜也是失败了，但她却并没有表现出来一丝丝的难受，她总是为别人，特别是空太，着想。在和樱花庄的伙伴们为阻止樱花庄被拆的命运，而不断地努力着，每天都是在寻求签名的奔波中度过，决定是否拆除的最后一天，依旧下着大雨，也就是在这一天，课堂上的青山，终于是忍受不了了，眼泪打在书本上，让人真的想哭，空太将她带到保健室，青山对他说没事，空太（这里笔主特别想抽空太）闻言后让青山睡会，有事叫他，之后便就出来了，在走廊上空太也是得到了自己第二次企划被刷的消息，再一次的问着命运为什么这样，这时，在龙之介—樱花庄的编程天才的提醒下，他想起了青山，总算明白了青山怎么可能没事，回到保健室发现青山已经不在了，出来找了一会在雨中看到了她，啊！！！！！这时候的青山真的好可怜好可怜，这时候的空太也是给了青山自己的怀抱，唉，真的很迟钝，可怜的青山，最后的晚上，真白为了保护樱花庄，同时觉得空太很讨厌自己，离开了樱花庄，然后嘛，老套路，空太去追真白，然后就是空太说喜欢真白，这个时候，青山也在空太的身后，眼中看起来是真的很难受，但她还是上前劝着真白回来，唉！在最后的毕业典礼上，大家最终还是保住了樱花庄，故事到这里基本结束了。</p><p>这是不可能的，后面的情节嘛，没有被拍成动漫，不过依然很虐人，青山也是在修学旅途中向空太表明了自己的心意，还吻了他，这个迟钝鬼这时候才看出青山的心意，虽然他明白青山会是一个很合适他的妻子，而两人在一起也一定会很幸福，但最后还是选了真白，这是为什么呢？其实呢，笔主的猜想，因为这是动漫，每一个年轻人，心中都是会有着自己理想中的恋人，那是一种很虚幻的感觉，因为这样的人既要有天才的能力，还要萌的可爱，但偏偏真白就是这样的一个人，而青山却是现实中最为合适的恋人，但又有多少年轻人在现实与理想中，选择前者呢？</p><p>青山与真白的选择，在笔主看来其实就是在现实与理想中的选择，如果理想真的存在，又有多少人选择现实呢，尽管这现实也是非常完美的存在</p><p>青山七海！！！我的老婆，谁也不许和我抢</p><p>理想与现实，我选择前者，即便是遍体鳞伤的代价</p><p>最后附上一张我老婆大人的图！！</p><img data-src="https://cdn.makiru.top/images/zhenbai.jpeg" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常番 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git ssl connect出错的问题</title>
      <link href="/blog/article/7172e25b.html"/>
      <url>/blog/article/7172e25b.html</url>
      
        <content type="html"><![CDATA[<p>本文主要说一下之前说hexo写完文章后，git deploy时总是会报SSL CONNECT 443的错，今天我试着按网上的一些方法做了下，像类似的设置IPV6的方法对我用处不大，一开始重启iterm还可以，不过后来也是不太行了<span id="more"></span></p><p>错误如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibreSSL SSL_connect: SSL_ERROR_SYSCALL <span class="keyword">in</span> connection to github.com:443</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>编辑~&#x2F;.gitconfig文件，添加下面的这段代码，代码可能会有些不同</p><p><img data-src="https://cdn.makiru.top/images/image-20210405105329661.png"></p><p>我之所以报错是因为设置了代理服务器，因为用的是socks代理，所以之前才会一直报错，至于这里的端口问题，每个人可能都不太一样，可以去自己的代理软件去查看（我的是clashx，一般都为7890）</p><p><font color=red>注意：如果上图中的不起作用，可以将socks5换成http，对应的，h也可以添加https的代理，那么，proxy的前缀则为https（我这边用socks5代理好像不太起作用——2022&#x2F;03&#x2F;22修改）</font></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遇事别紧张，办法总会有的，你不会不代表别人不会，但不会没事，去查呗，本人憨憨一枚，就是这么厚脸皮。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题的美化</title>
      <link href="/blog/article/e9a449dc.html"/>
      <url>/blog/article/e9a449dc.html</url>
      
        <content type="html"><![CDATA[<p>搭建完博客后，自然想到的就是将自己的博客变得更美观一点，因此，本文记录了本憨憨是如何将自己的博客弄得稍微好看了点，其实弄完后才会发现原来弄完会这么好看，就连写文档都会开心很多<span id="more"></span></p><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>我选择的是next主题，在前一篇博文里已经介绍过如何更换主题，接下来的操作就都将是修改主题文件中的配置文件，由于我选择的是next，所以接下来便以next主题为例介绍。</p><p>首先配置文件的位置是在：你的博客文件夹（我的就是hexo）&#x2F;theme&#x2F;，接下来的文件夹便是主题文件夹，进入后，就有个_config.yml文件，主题的大多数配置都在该文件夹里</p><p>next主题有四种样式，分别为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini   <span class="comment">#只需要去主题配置文件中修改即可</span></span><br></pre></td></tr></table></figure><p>我个人选择的是Gemini，其实后两种的区别不大，相比于前两种，页面更加丰富，留白也相对较少，样式如下：</p><img data-src="https://cdn.makiru.top/images/image-20210404211542968.png" alt="" style="zoom: 25%;" /><h3 id="评论区的实现"><a href="#评论区的实现" class="headerlink" title="评论区的实现"></a>评论区的实现</h3><p>我个人采用的是valine，我觉得用起来还是比较方便的，后台的管理也是很轻松，邮件通知也很好用</p><h4 id="第一步：注册账号"><a href="#第一步：注册账号" class="headerlink" title="第一步：注册账号"></a>第一步：注册账号</h4><p>首先去leancloud的国际版去注册个账号，国内版的有很大问题：<a href="https://us.leancloud.cn/">https://us.leancloud.cn/</a></p><h4 id="第二步：创建应用并部署"><a href="#第二步：创建应用并部署" class="headerlink" title="第二步：创建应用并部署"></a>第二步：创建应用并部署</h4><p>注册完之后，创建应用，选择开发版，创建class，选择不限制，选择云引擎的部署，点击项目部署，选择git部署，输入：<a href="https://github.com/DesertsP/Valine-Admin.git%EF%BC%8C%E7%82%B9%E5%87%BB%E9%83%A8%E7%BD%B2%E5%8D%B3%E5%8F%AF">https://github.com/DesertsP/Valine-Admin.git，点击部署即可</a></p><p>进入设置，按下图设置变量：</p><img data-src="https://cdn.makiru.top/images/2021040492335.png" alt="" style="zoom:33%;" /><p>​其中的smtp_pass需要去邮箱设置，这里就不介绍了，admim_url就是下面云引擎设置的域名，名称可以自己定（这里就是不用国内版的原因，国内版的没有这个送的域名，很麻烦，害我弄了好久才发现是这个问题）</p><h4 id="第三步：设置定时任务"><a href="#第三步：设置定时任务" class="headerlink" title="第三步：设置定时任务"></a>第三步：设置定时任务</h4><p>接下来就是设置下定时任务:</p><img data-src="https://cdn.makiru.top/images/image-20210404212733906.png" alt="" style="zoom:33%;" /><h4 id="第四步：修改配置文件"><a href="#第四步：修改配置文件" class="headerlink" title="第四步：修改配置文件"></a>第四步：修改配置文件</h4><p>然后就是去博客的主题配置文件中去定义valine的参数，比较新的next主题其实已经写好了，就需要自己调下，如下图：</p><img data-src="https://cdn.makiru.top/images/image-20210404213025705.png" alt="" style="zoom: 50%;" /><p>将这里的active:后面的设为valine</p><p><img data-src="https://cdn.makiru.top/images/image-20210404213215679.png"></p><p>这里的appid和appkey在刚才创建的应用的设置里的应用keys里就有，填入即可</p><p>接下来便是浏览器进入之前设置的那个avosapps.us&#x2F;sign-up的网址，设置管理员的密码账户，后面就可以在这个网址里管理评论</p><p>邮件通知在前面的环境变量设置中已经设置好了，然后就可以去自己的博客测试下了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实评论区的设置还是花了我点时间的，因为leancloud竟然还有国际版，我就说我怎么一直找不到avosapps.us的域名</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo搭建个人博客</title>
      <link href="/blog/article/85811f6c.html"/>
      <url>/blog/article/85811f6c.html</url>
      
        <content type="html"><![CDATA[<p>这是我第一次使用github以及hexo搭建的博客，在搭建的过程中，遇到了很多奇奇怪怪的问题，足足花了我将近一个上午的时间。在这里，我稍微记录一下我遇到的坑（其实就是两个大坑）<span id="more"></span></p><h3 id="我的环境"><a href="#我的环境" class="headerlink" title="我的环境"></a>我的环境</h3><p>Mac OS catalian</p><p>git version 2.28.0</p><p>Npm version 6.14.11</p><p>hexo-cli version 4.2.0</p><h3 id="搭建的前提准备"><a href="#搭建的前提准备" class="headerlink" title="搭建的前提准备"></a>搭建的前提准备</h3><p>首先需要在你的系统上安装好git和node.js，安装步骤如下：</p><p>git安装：使用mac自带的homebrew包管理系统安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>安装完成后，可以查看相应的版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>Node.js安装：去官网下载与系统相对应的pkg包：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>安装过程直接一直点默认即可，其中安装的位置可以自己选择</p><p>安装完成后同样可以查看是否安装成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>接下来将hexo的基本框架先利用npm下载到本地，可以自己先创建一个文件夹hexo（名称随意），最好给这个文件夹赋予写的权限（不弄也行，不过后面可能需要sudo啥的），然后cd到该目录下，安装hexo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，可以查看hexo的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>然后继续执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init     <span class="comment">#生成package.json文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   <span class="comment">#安装部署插件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install   <span class="comment">#安装依赖</span></span><br></pre></td></tr></table></figure><p>接着执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init   <span class="comment">#生成hexo的框架</span></span><br></pre></td></tr></table></figure><p>框架基本如下：</p><img data-src="https://cdn.makiru.top/images/2021040290855.png" alt="" style="zoom:50%;" /><p>到这里可以测试一下hexo是否安装好，在该目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g    <span class="comment">#生成文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s     <span class="comment">#启动服务</span></span><br></pre></td></tr></table></figure><p>在浏览器里前往：<a href="http://localhost:4000/">http://localhost:4000</a>如果没报啥错，博客网站出现了就是成功的</p><h3 id="github方面的准备"><a href="#github方面的准备" class="headerlink" title="github方面的准备"></a>github方面的准备</h3><p>首先你需要有一个github的账号，没有就去注册一个：<a href="https://github.com/">https://github.com</a>登录进去后，点击右上角头像左边的加号，选择new repository创建一个新的库，Repository name直接填 用户名.github.io（注意，是用户名，不是昵称，也就是目前你写库名字前面的owner的名字），然后直接点create repository即可</p><p>接下来进入本地系统的~&#x2F;.ssh目录下，查看是否有id_rsa以及id_rsa.pub两个文件，没有的话在该目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;Github的注册邮箱地址&quot;</span></span><br></pre></td></tr></table></figure><p>进入github头像的setting里，选择ssh and GPG keys，将之前获得的id_rsa里的内容复制到ssh keys的内容框里，名称随意</p><img data-src="https://cdn.makiru.top/images/2021040291819.png" alt="" style="zoom: 33%;" /><p>结束后到本地系统来看看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现以下提示即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;GitHub.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)</span><br></pre></td></tr></table></figure><p>接下来就可以一直选择默认回车下去，然后需要完善一些个人信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span>   <span class="comment">#输入注册时的username</span></span><br><span class="line">git config --global user.email  <span class="string">&quot;your email&quot;</span>  <span class="comment">#填写注册邮箱</span></span><br></pre></td></tr></table></figure><p>以上便完成了本地与github的连接</p><p>然后便是修改hexo文件夹下的_config.yml文件，主要是修改以下几个地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://your name.github.io</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/your name/your name.github.io.git</span><br><span class="line">  branch: main     #这里的main不能改为master，我就是这里被坑的</span><br></pre></td></tr></table></figure><p>修改完后，可以将自己喜欢的主题克隆到hexo文件夹下的子文件夹theme里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next  <span class="comment">#这里一定要注意：next主题的地址作者换掉了</span></span><br></pre></td></tr></table></figure><p>替换主题后，去hexo下的_config.yml下，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到这里便基本完工了，将本地的博客上传至github即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d   <span class="comment">#之后每次写完博客后，就可以直接利用这两句话上传</span></span><br></pre></td></tr></table></figure><p>然后，浏览器打开：your name.github.io应该便能进入博客里</p><p>写博客的话，在hexo目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>然后便是markdown的事了</p><h3 id="其中的坑"><a href="#其中的坑" class="headerlink" title="其中的坑"></a>其中的坑</h3><p>第一：现在github改了，不再使用master,而是main作为默认的分支名</p><p>第二：git上传的时候（也就是hexo d）总是会断掉，提示啥443错误，我暂时没解决，不过重新打开个命令界面一般可以上传成功，八成是代理的问题</p><p>第三：更换主题后（我用的是next），结果一直报错，本人憨憨一个，还不看错误提示，结果是next的项目文件换网址了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写此文章仅为记录自己的憨憨一上午</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
